/**
 * Platform-Specific Adapters for Verbalized Sampling
 *
 * Provides adapters for OpenCode, Claude Code, and Cursor platforms
 * Each adapter handles platform-specific conventions and requirements
 */

import { InjectionPatterns } from './injection-patterns.js';
import { VSResult } from './index.js';
import { readFile } from 'fs/promises';
import { join, basename, dirname } from 'path';

export interface PlatformAdapter {
  name: 'opencode' | 'claude' | 'cursor';
  description: string;
  fileExtensions: string[];
  defaultPaths: {
    agents: string;
    commands: string;
    skills: string;
  };
  conventions: {
    commentStyle: 'js' | 'md' | 'yaml' | 'html';
    frontMatter: boolean;
    indentation: 'spaces' | 'tabs';
    indentSize: number;
  };
  integration: {
    preferredPattern: string;
    autoInject: boolean;
    validation: boolean;
  };
}

export class PlatformAdapters {
  private static adapters: Map<string, PlatformAdapter> = new Map();

  static {
    this.initializeAdapters();
  }

  private static initializeAdapters(): void {
    // OpenCode Adapter
    this.adapters.set('opencode', {
      name: 'opencode',
      description: 'OpenCode platform adapter with flat structure and JSONC configuration',
      fileExtensions: ['.md', '.jsonc', '.ts', '.js'],
      defaultPaths: {
        agents: 'base-agents',
        commands: 'commands-simplified',
        skills: 'base-skills',
      },
      conventions: {
        commentStyle: 'md',
        frontMatter: true,
        indentation: 'spaces',
        indentSize: 2,
      },
      integration: {
        preferredPattern: 'frontmatter-section',
        autoInject: true,
        validation: true,
      },
    });

    // Claude Code Adapter
    this.adapters.set('claude', {
      name: 'claude',
      description: 'Claude Code platform adapter with command-based structure',
      fileExtensions: ['.md', '.mcp'],
      defaultPaths: {
        agents: 'agents',
        commands: 'commands-simplified',
        skills: 'skills',
      },
      conventions: {
        commentStyle: 'md',
        frontMatter: false,
        indentation: 'spaces',
        indentSize: 2,
      },
      integration: {
        preferredPattern: 'prepend-approach',
        autoInject: true,
        validation: true,
      },
    });

    // Cursor Adapter
    this.adapters.set('cursor', {
      name: 'cursor',
      description: 'Cursor platform adapter with .cursor directory structure',
      fileExtensions: ['.md', '.cursorrules'],
      defaultPaths: {
        agents: '.cursor/agents',
        commands: '.cursor/commands',
        skills: '.cursor/skills',
      },
      conventions: {
        commentStyle: 'md',
        frontMatter: true,
        indentation: 'spaces',
        indentSize: 2,
      },
      integration: {
        preferredPattern: 'frontmatter-section',
        autoInject: true,
        validation: true,
      },
    });
  }

  /**
   * Get adapter for platform
   */
  static getAdapter(platform: 'opencode' | 'claude' | 'cursor'): PlatformAdapter | undefined {
    return this.adapters.get(platform);
  }

  /**
   * Get all adapters
   */
  static getAllAdapters(): PlatformAdapter[] {
    return Array.from(this.adapters.values());
  }

  /**
   * Get platform-specific file paths
   */
  static getFilePaths(
    platform: 'opencode' | 'claude' | 'cursor',
    componentName: string,
    componentType: 'agents' | 'commands' | 'skills'
  ): string[] {
    const adapter = this.adapters.get(platform);
    if (!adapter) return [];

    const basePath = adapter.defaultPaths[componentType];
    const extension = this.getDefaultExtension(platform, componentType);

    return [
      join(basePath, `${componentName}${extension}`),
      join(basePath, componentName, `index${extension}`),
      join(basePath, componentName, `${componentName}${extension}`),
    ];
  }

  /**
   * Get default file extension for platform and component type
   */
  private static getDefaultExtension(
    platform: 'opencode' | 'claude' | 'cursor',
    componentType: 'agents' | 'commands' | 'skills'
  ): string {
    const extensions = {
      opencode: {
        agents: '.md',
        commands: '.md',
        skills: '.md',
      },
      claude: {
        agents: '.md',
        commands: '.md',
        skills: '.md',
      },
      cursor: {
        agents: '.md',
        commands: '.md',
        skills: '.md',
      },
    };

    return extensions[platform][componentType];
  }

  /**
   * Validate platform-specific file structure
   */
  static async validateFileStructure(
    platform: 'opencode' | 'claude' | 'cursor',
    filePath: string
  ): Promise<{ valid: boolean; errors: string[] }> {
    const adapter = this.adapters.get(platform);
    if (!adapter) {
      return { valid: false, errors: [`Unknown platform: ${platform}`] };
    }

    const errors: string[] = [];

    try {
      // Check if file exists
      const content = await readFile(filePath, 'utf-8');

      // Validate file extension
      const fileExtension = filePath.substring(filePath.lastIndexOf('.'));
      if (!adapter.fileExtensions.includes(fileExtension)) {
        errors.push(
          `Invalid file extension: ${fileExtension}. Expected: ${adapter.fileExtensions.join(', ')}`
        );
      }

      // Validate front matter if required
      if (adapter.conventions.frontMatter && fileExtension === '.md') {
        const lines = content.split('\n');
        if (lines[0] !== '---') {
          errors.push('Missing YAML front matter (should start with ---)');
        }
      }

      // Validate indentation
      const lines = content.split('\n');
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line.startsWith('\t') && adapter.conventions.indentation === 'spaces') {
          errors.push(`Line ${i + 1}: Uses tabs but platform expects spaces`);
          break;
        }
      }
    } catch (error) {
      errors.push(`Cannot read file: ${error}`);
    }

    return {
      valid: errors.length === 0,
      errors,
    };
  }

  /**
   * Format content for platform
   */
  static formatContent(
    platform: 'opencode' | 'claude' | 'cursor',
    content: string,
    componentType: 'agents' | 'commands' | 'skills'
  ): string {
    const adapter = this.adapters.get(platform);
    if (!adapter) return content;

    let formattedContent = content;

    // Apply indentation
    if (adapter.conventions.indentation === 'spaces') {
      const lines = formattedContent.split('\n');
      const formattedLines = lines.map((line) => {
        if (line.startsWith('\t')) {
          return line.replace(/\t/g, ' '.repeat(adapter.conventions.indentSize));
        }
        return line;
      });
      formattedContent = formattedLines.join('\n');
    }

    // Add platform-specific headers if needed
    if (platform === 'opencode' && componentType === 'agents') {
      if (!formattedContent.includes('```jsonc')) {
        formattedContent = this.addOpenCodeConfig(formattedContent);
      }
    }

    return formattedContent;
  }

  /**
   * Add OpenCode configuration block
   */
  private static addOpenCodeConfig(content: string): string {
    const config = `{
  "subagent": {
    "mode": "subagent",
    "model": "anthropic/claude-sonnet-4"
  }
}`;

    if (content.startsWith('---')) {
      // Insert after front matter
      const lines = content.split('\n');
      let insertIndex = 0;

      for (let i = 1; i < lines.length; i++) {
        if (lines[i] === '---') {
          insertIndex = i + 2;
          break;
        }
      }

      lines.splice(insertIndex, 0, '', '```jsonc', config, '```', '');
      return lines.join('\n');
    } else {
      return `---\n\n\`\`\`jsonc\n${config}\n\`\`\`\n\n${content}`;
    }
  }

  /**
   * Extract component information from file
   */
  static async extractComponentInfo(
    platform: 'opencode' | 'claude' | 'cursor',
    filePath: string
  ): Promise<{
    name: string;
    type: 'agents' | 'commands' | 'skills';
    description?: string;
    existingVS?: boolean;
  }> {
    const adapter = this.adapters.get(platform);
    if (!adapter) {
      throw new Error(`Unknown platform: ${platform}`);
    }

    const fileName = basename(filePath);
    const dirPath = dirname(filePath);

    // Determine component type from path
    let componentType: 'agents' | 'commands' | 'skills' = 'agents';
    for (const [type, path] of Object.entries(adapter.defaultPaths)) {
      if (dirPath.includes(path) || filePath.includes(path)) {
        componentType = type as 'agents' | 'commands' | 'skills';
        break;
      }
    }

    const name = fileName.replace(/\.[^/.]+$/, ''); // Remove extension

    try {
      const content = await readFile(filePath, 'utf-8');

      // Extract description
      let description: string | undefined;
      const lines = content.split('\n');
      for (const line of lines) {
        if (line.startsWith('# ')) {
          description = line.substring(2).trim();
          break;
        }
      }

      // Check for existing VS integration
      const existingVS =
        content.includes('VERBALIZED SAMPLING') || content.includes('verbalized_sampling');

      return {
        name,
        type: componentType,
        description,
        existingVS,
      };
    } catch (error) {
      return {
        name,
        type: componentType,
      };
    }
  }

  /**
   * Generate platform-specific integration
   */
  static async generateIntegration(
    platform: 'opencode' | 'claude' | 'cursor',
    componentType: 'agents' | 'commands' | 'skills',
    vsResult: VSResult,
    componentName: string
  ): Promise<string> {
    const adapter = this.adapters.get(platform);
    if (!adapter) {
      throw new Error(`Unknown platform: ${platform}`);
    }

    // Get platform-adapted pattern
    const pattern = InjectionPatterns.getPlatformPattern(
      componentType === 'agents' ? 'agent' : componentType === 'commands' ? 'command' : 'skill',
      platform,
      adapter.integration.preferredPattern
    );

    if (!pattern) {
      throw new Error(`No pattern found for ${componentType} on ${platform}`);
    }

    // Prepare data for template rendering
    const selectedStrategyObj = vsResult.strategies.strategies.find(
      (s) => s.name === vsResult.strategies.selected_strategy
    );

    // Prepare data for template rendering
    const data: any = {
      selectedStrategy: vsResult.strategies.selected_strategy,
      confidenceScore: vsResult.strategies.total_confidence,
      confidencePercentage: (vsResult.strategies.total_confidence * 100).toFixed(1),
      strategies: vsResult.strategies.strategies,
      generatedAt: new Date().toISOString(),
      componentName,
    };

    if (selectedStrategyObj) {
      data.selectedStrategyDescription = selectedStrategyObj.description;
      data.executionPlan = selectedStrategyObj.execution_plan.join('\n1. ');
    }

    // Render template
    const vsContent = InjectionPatterns.renderTemplate(pattern, data);

    // Format for platform
    return this.formatContent(platform, vsContent, componentType);
  }

  /**
   * Create platform-specific directory structure
   */
  static async createDirectoryStructure(
    platform: 'opencode' | 'claude' | 'cursor',
    basePath: string
  ): Promise<void> {
    const adapter = this.adapters.get(platform);
    if (!adapter) return;

    const { writeFile } = await import('fs/promises');

    // Create base directories
    for (const [, path] of Object.entries(adapter.defaultPaths)) {
      const fullPath = join(basePath, path);

      try {
        await writeFile(fullPath, '');
      } catch {
        // Directory might already exist or creation failed
      }
    }

    // Create platform-specific config files
    if (platform === 'opencode') {
      const opencodeConfig = {
        model: 'anthropic/claude-sonnet-4',
        agent: {
          build: { mode: 'primary' },
          plan: { mode: 'primary' },
        },
      };

      const configPath = join(basePath, 'opencode.jsonc');
      await writeFile(configPath, JSON.stringify(opencodeConfig, null, 2));
    }

    if (platform === 'cursor') {
      const cursorRules = `
# Cursor Rules for Verbalized Sampling Integration

## VS Integration Guidelines

- All agents should include verbalized sampling analysis
- Use frontmatter-section pattern for consistency
- Validate VS integration before committing
- Follow platform-specific conventions

## Auto-Integration

When enabled, verbalized sampling will be automatically injected into:
- Agent descriptions
- Command usage examples
- Skill implementation strategies

## Validation

Run validation before committing:
\`\`\`bash
cursor-vs-validate --path /path/to/component
\`\`\`
`;

      const rulesPath = join(basePath, '.cursorrules');
      await writeFile(rulesPath, cursorRules.trim());
    }
  }

  /**
   * Get platform statistics
   */
  static getStatistics(): {
    totalPlatforms: number;
    platforms: string[];
    supportedComponents: string[];
  } {
    return {
      totalPlatforms: this.adapters.size,
      platforms: Array.from(this.adapters.keys()),
      supportedComponents: ['agents', 'commands', 'skills'],
    };
  }
}

// Convenience exports
export { PlatformAdapters as Adapters };
