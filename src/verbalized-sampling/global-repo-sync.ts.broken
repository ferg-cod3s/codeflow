/**
 * Global Repository Synchronization for Verbalized Sampling
 *
 * Handles automated copying of VS prompts and integration patterns to global repositories
 * Supports bidirectional sync between local and global repositories
 */

import { readFile, writeFile, readdir, stat } from 'fs/promises';
import { join } from 'path';
import { execSync } from 'child_process';

export interface GlobalRepoConfig {
  name: string;
  url?: string;
  localPath: string;
  branch?: string;
  autoSync: boolean;
  lastSync?: string;
  components: ('agents' | 'commands' | 'skills')[];
  platforms: ('opencode' | 'claude' | 'cursor')[];
}

export interface SyncResult {
  success: boolean;
  operation: 'export' | 'import' | 'bidirectional';
  repoName: string;
  filesProcessed: number;
  filesUpdated: number;
  errors: string[];
  duration: number;
  timestamp: string;
}

export interface SyncConflict {
  filePath: string;
  localVersion: string;
  remoteVersion: string;
  conflictType: 'content' | 'metadata' | 'structure';
  resolution?: 'local' | 'remote' | 'merge' | 'skip';
}

export class GlobalRepoSync {
  private config: GlobalRepoConfig;
  private localVSPath: string;

  constructor(config: GlobalRepoConfig, localVSPath?: string) {
    this.config = config;
    this.localVSPath = localVSPath || join(process.cwd(), 'src', 'verbalized-sampling');
  }

  /**
   * Export VS components to global repository
   */
  async exportToGlobal(): Promise<SyncResult> {
    const startTime = Date.now();
    const result: SyncResult = {
      success: false,
      operation: 'export',
      repoName: this.config.name,
      filesProcessed: 0,
      filesUpdated: 0,
      errors: [],
      duration: 0,
      timestamp: new Date().toISOString(),
    };

    try {
      // Ensure global repo directory exists
      await this.ensureDirectory(this.config.localPath);

      // Create VS directory structure in global repo
      const globalVSPath = join(this.config.localPath, 'verbalized-sampling');
      await this.createVSDirectoryStructure(globalVSPath);

      // Export core VS files
      await this.exportCoreFiles(globalVSPath, result);

      // Export platform-specific files
      await this.exportPlatformFiles(globalVSPath, result);

      // Export integration templates
      await this.exportIntegrationTemplates(globalVSPath, result);

      // Update global repo metadata
      await this.updateGlobalMetadata(globalVSPath, result);

      // Commit changes if auto-sync is enabled
      if (this.config.autoSync) {
        await this.commitChanges(result);
      }

      result.success = result.errors.length === 0;
      result.duration = Date.now() - startTime;
    } catch (error) {
      result.errors.push(`Export failed: ${error}`);
      result.duration = Date.now() - startTime;
    }

    return result;
  }

  /**
   * Import VS components from global repository
   */
  async importFromGlobal(): Promise<SyncResult> {
    const startTime = Date.now();
    const result: SyncResult = {
      success: false,
      operation: 'import',
      repoName: this.config.name,
      filesProcessed: 0,
      filesUpdated: 0,
      errors: [],
      duration: 0,
      timestamp: new Date().toISOString(),
    };

    try {
      // Check if global repo exists
      const globalVSPath = join(this.config.localPath, 'verbalized-sampling');
      await this.validateGlobalRepo(globalVSPath, result);

      // Import core VS files
      await this.importCoreFiles(globalVSPath, result);

      // Import platform-specific files
      await this.importPlatformFiles(globalVSPath, result);

      // Import integration templates
      await this.importIntegrationTemplates(globalVSPath, result);

      // Update local metadata
      await this.updateLocalMetadata(result);

      result.success = result.errors.length === 0;
      result.duration = Date.now() - startTime;
    } catch (error) {
      result.errors.push(`Import failed: ${error}`);
      result.duration = Date.now() - startTime;
    }

    return result;
  }

  /**
   * Bidirectional synchronization with conflict resolution
   */
  async bidirectionalSync(): Promise<SyncResult> {
    const startTime = Date.now();
    const result: SyncResult = {
      success: false,
      operation: 'bidirectional',
      repoName: this.config.name,
      filesProcessed: 0,
      filesUpdated: 0,
      errors: [],
      duration: 0,
      timestamp: new Date().toISOString(),
    };

    try {
      // Detect conflicts
      const conflicts = await this.detectConflicts();

      if (conflicts.length > 0) {
        // Resolve conflicts
        await this.resolveConflicts(conflicts, result);
      }

      // Export local changes
      const exportResult = await this.exportToGlobal();
      result.filesProcessed += exportResult.filesProcessed;
      result.filesUpdated += exportResult.filesUpdated;
      result.errors.push(...exportResult.errors);

      // Import remote changes
      const importResult = await this.importFromGlobal();
      result.filesProcessed += importResult.filesProcessed;
      result.filesUpdated += importResult.filesUpdated;
      result.errors.push(...importResult.errors);

      result.success = result.errors.length === 0;
      result.duration = Date.now() - startTime;
    } catch (error) {
      result.errors.push(`Bidirectional sync failed: ${error}`);
      result.duration = Date.now() - startTime;
    }

    return result;
  }

  /**
   * Create VS directory structure in global repo
   */
  private async createVSDirectoryStructure(globalVSPath: string): Promise<void> {
    const directories = [
      'core',
      'platforms/opencode',
      'platforms/claude',
      'platforms/cursor',
      'templates/agents',
      'templates/commands',
      'templates/skills',
      'examples',
      'metadata',
    ];

    for (const dir of directories) {
      await this.ensureDirectory(join(globalVSPath, dir));
    }
  }

  /**
   * Export core VS files
   */
  private async exportCoreFiles(globalVSPath: string, result: SyncResult): Promise<void> {
    const coreFiles = [
      'index.ts',
      'strategy-generator.ts',
      'confidence-calculator.ts',
      'output-formatter.ts',
      'universal-integration.ts',
      'injection-patterns.ts',
      'platform-adapters.ts',
    ];

    const coreDir = join(globalVSPath, 'core');

    for (const file of coreFiles) {
      try {
        const localFile = join(this.localVSPath, file);
        const globalFile = join(coreDir, file);

        const content = await readFile(localFile, 'utf-8');
        await writeFile(globalFile, content, 'utf-8');

        result.filesProcessed++;
        result.filesUpdated++;
      } catch (error) {
        result.errors.push(`Failed to export core file ${file}: ${error}`);
      }
    }
  }

  /**
   * Export platform-specific files
   */
  private async exportPlatformFiles(globalVSPath: string, result: SyncResult): Promise<void> {
    for (const platform of this.config.platforms) {
      const platformDir = join(globalVSPath, 'platforms', platform);

      // Export platform-specific templates
      const templates = [
        `${platform}-agent-template.md`,
        `${platform}-command-template.md`,
        `${platform}-skill-template.md`,
      ];

      for (const template of templates) {
        try {
          const content = await this.generatePlatformTemplate(platform, template);
          const templateFile = join(platformDir, template);
          await writeFile(templateFile, content, 'utf-8');

          result.filesProcessed++;
          result.filesUpdated++;
        } catch (error) {
          result.errors.push(`Failed to export platform template ${template}: ${error}`);
        }
      }
    }
  }

  /**
   * Export integration templates
   */
  private async exportIntegrationTemplates(
    globalVSPath: string,
    result: SyncResult
  ): Promise<void> {
    for (const component of this.config.components) {
      try {
        const template = await this.generateIntegrationTemplate(component);
        const templateFile = join(globalVSPath, 'templates', component, 'integration-template.md');
        await writeFile(templateFile, template, 'utf-8');

        result.filesProcessed++;
        result.filesUpdated++;
      } catch (error) {
        result.errors.push(`Failed to export integration template for ${component}: ${error}`);
      }
    }
  }

  /**
   * Generate platform-specific template
   */
  private async generatePlatformTemplate(platform: string, templateName: string): Promise<string> {
    const componentType = templateName.includes('agent')
      ? 'agent'
      : templateName.includes('command')
        ? 'command'
        : 'skill';

    return `# ${platform.charAt(0).toUpperCase() + platform.slice(1)} ${componentType.charAt(0).toUpperCase() + componentType.slice(1)} Template

## Verbalized Sampling Integration

This template provides standardized verbalized sampling integration for ${platform} ${componentType}s.

### Usage

1. Copy this template to your ${componentType} directory
2. Customize the problem context and agent type
3. The system will automatically generate and rank strategies

### Integration Pattern

- **Platform**: ${platform}
- **Component Type**: ${componentType}
- **Preferred Pattern**: ${platform === 'claude' ? 'prepend-approach' : 'frontmatter-section'}

### Example Configuration

\`\`\`yaml
verbalized_sampling:
  enabled: true
  platform: ${platform}
  component_type: ${componentType}
  confidence_threshold: 0.7
  strategy_count: 3
\`\`\`

### Auto-Integration

When enabled, the system will automatically:
1. Analyze the ${componentType}'s purpose and context
2. Generate appropriate strategies
3. Inject the VS integration at the specified location
4. Update the ${componentType} configuration

### Validation

Run validation before committing:
\`\`\`bash
vs-validate --platform ${platform} --type ${componentType}
\`\`\`

---
*Generated by CodeFlow Verbalized Sampling System*
*Last updated: ${new Date().toISOString()}*
`;
  }

  /**
   * Generate integration template
   */
  private async generateIntegrationTemplate(component: string): Promise<string> {
    return `# ${component.charAt(0).toUpperCase() + component.slice(1)} Integration Template

## Verbalized Sampling Integration

This template provides standardized verbalized sampling integration for ${component} components.

### Structure

\`\`\`markdown
\`\`\`
`;
  }
}
