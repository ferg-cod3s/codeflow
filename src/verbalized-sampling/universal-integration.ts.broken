/**
 * Universal VS Integration System
 *
 * Provides cross-platform verbalized sampling integration for agents, commands, and skills
 * Supports OpenCode, Claude Code, and Cursor platforms
 */

import { VerbalizedSampling, VSRequest, VSResult } from '../verbalized-sampling/index.js';
import { readFile, writeFile } from 'fs/promises';
import { join } from 'path';

export interface PlatformConfig {
  name: 'opencode' | 'claude' | 'cursor';
  vsIntegrationPath: string;
  templatePath: string;
  injectionPattern: 'prepend' | 'append' | 'replace' | 'section';
  commentStyle: 'js' | 'md' | 'yaml';
}

export interface VSIntegrationConfig {
  enabled: boolean;
  autoInject: boolean;
  confidenceThreshold: number;
  strategyCount: number;
  outputFormat: 'json' | 'markdown' | 'terminal';
  platforms: PlatformConfig[];
}

export interface VSInjectionResult {
  success: boolean;
  platform: string;
  filePath: string;
  injectionType: string;
  originalSize: number;
  newSize: number;
  vsIntegration: {
    strategiesCount: number;
    selectedStrategy: string;
    confidenceScore: number;
  };
}

export class UniversalVSIntegration {
  private config: VSIntegrationConfig;
  private vs: VerbalizedSampling;

  constructor(config?: Partial<VSIntegrationConfig>) {
    this.config = {
      enabled: true,
      autoInject: true,
      confidenceThreshold: 0.7,
      strategyCount: 3,
      outputFormat: 'markdown',
      platforms: this.getDefaultPlatformConfigs(),
      ...config,
    };
    this.vs = new VerbalizedSampling();
  }

  public getDefaultPlatformConfigs(): PlatformConfig[] {
    return [
      {
        name: 'opencode',
        vsIntegrationPath: 'base-agents',
        templatePath: 'templates/vs-integration.md',
        injectionPattern: 'section',
        commentStyle: 'md',
      },
      {
        name: 'claude',
        vsIntegrationPath: 'commands-simplified',
        templatePath: 'templates/vs-integration.md',
        injectionPattern: 'prepend',
        commentStyle: 'md',
      },
      {
        name: 'cursor',
        vsIntegrationPath: '.cursor/agents',
        templatePath: 'templates/vs-integration.md',
        injectionPattern: 'section',
        commentStyle: 'md',
      },
    ];
  }

  /**
   * Generate VS integration content for a specific component
   */
  async generateVSIntegration(
    problem: string,
    agentType: 'research' | 'planning' | 'development',
    context?: any
  ): Promise<VSResult> {
    const request: VSRequest = {
      problem,
      agent_type: agentType,
      context,
      output_format: { format: this.config.outputFormat, verbose: true },
    };

    return await this.vs.execute(request);
  }

  /**
   * Inject VS integration into an agent file
   */
  async injectIntoAgent(
    agentPath: string,
    platform: PlatformConfig,
    problem: string,
    agentType: 'research' | 'planning' | 'development'
  ): Promise<VSInjectionResult> {
    try {
      // Read original agent file
      const originalContent = await readFile(agentPath, 'utf-8');
      const originalSize = originalContent.length;

      // Generate VS integration
      const vsResult = await this.generateVSIntegration(problem, agentType);

      // Format VS content for injection
      const vsContent = this.formatVSForInjection(vsResult, platform);

      // Inject VS content based on pattern
      const newContent = this.injectContent(originalContent, vsContent, platform);

      // Write updated content
      await writeFile(agentPath, newContent, 'utf-8');
      const newSize = newContent.length;

      return {
        success: true,
        platform: platform.name,
        filePath: agentPath,
        injectionType: platform.injectionPattern,
        originalSize,
        newSize,
        vsIntegration: {
          strategiesCount: vsResult.strategies.strategies.length,
          selectedStrategy: vsResult.strategies.selected_strategy,
          confidenceScore: vsResult.strategies.total_confidence,
        },
      };
    } catch (error) {
      return {
        success: false,
        platform: platform.name,
        filePath: agentPath,
        injectionType: platform.injectionPattern,
        originalSize: 0,
        newSize: 0,
        vsIntegration: {
          strategiesCount: 0,
          selectedStrategy: '',
          confidenceScore: 0,
        },
      };
    }
  }

  /**
   * Format VS result for platform-specific injection
   */
  private formatVSForInjection(vsResult: VSResult, platform: PlatformConfig): string {
    const commentStyle = this.getCommentStyle(platform.commentStyle);

    let vsContent = '';

    switch (platform.injectionPattern) {
      case 'prepend':
        vsContent = `${commentStyle.start} Verbalized Sampling Integration\n${commentStyle.middle} Generated strategies for problem-solving\n${commentStyle.end}\n\n`;
        break;

      case 'append':
        vsContent = `\n\n${commentStyle.start} Verbalized Sampling Integration\n${commentStyle.middle} Generated strategies for problem-solving\n${commentStyle.end}\n`;
        break;

      case 'section':
        vsContent = `\n\n${commentStyle.start} VERBALIZED SAMPLING INTEGRATION ${commentStyle.end}\n${commentStyle.start} ================================ ${commentStyle.end}\n\n`;
        break;

      case 'replace':
        vsContent = `${commentStyle.start} Verbalized Sampling Integration ${commentStyle.end}\n`;
        break;
    }

    // Add VS strategies content
    if (vsResult.strategies) {
      vsContent += `**Selected Strategy**: ${vsResult.strategies.selected_strategy}\n`;
      vsContent += `**Confidence**: ${(vsResult.strategies.total_confidence * 100).toFixed(1)}%\n\n`;

      vsContent += `**Available Strategies**:\n`;
      vsResult.strategies.strategies.forEach((strategy, index) => {
        vsContent += `${index + 1}. **${strategy.name}** (Confidence: ${(strategy.confidence_score * 100).toFixed(1)}%)\n`;
        if (strategy.execution_plan && strategy.execution_plan.length > 0) {
          vsContent += `   - Plan: ${strategy.execution_plan.slice(0, 2).join(', ')}...\n`;
        }
      });
    }

    return vsContent;
  }

  private getCommentStyle(style: 'js' | 'md' | 'yaml'): {
    start: string;
    middle: string;
    end: string;
  } {
    switch (style) {
      case 'js':
        return { start: '/*', middle: ' *', end: ' */' };
      case 'md':
        return { start: '<!--', middle: '  ', end: '-->' };
      case 'yaml':
        return { start: '#', middle: '#', end: '#' };
      default:
        return { start: '#', middle: '#', end: '#' };
    }
  }

  private injectContent(original: string, vsContent: string, platform: PlatformConfig): string {
    switch (platform.injectionPattern) {
      case 'prepend':
        return vsContent + original;

      case 'append':
        return original + vsContent;

      case 'section':
        // Insert after front matter or first section
        const lines = original.split('\n');
        let insertIndex = 0;

        // Skip front matter
        if (lines[0] === '---') {
          for (let i = 1; i < lines.length; i++) {
            if (lines[i] === '---') {
              insertIndex = i + 2; // After --- and blank line
              break;
            }
          }
        } else {
          // After first heading or description
          for (let i = 0; i < lines.length; i++) {
            if (lines[i].startsWith('#') || lines[i].trim() === '') {
              insertIndex = i + 1;
              break;
            }
          }
        }

        lines.splice(insertIndex, 0, '', vsContent);
        return lines.join('\n');

      case 'replace':
        // Replace existing VS section if found
        const vsSectionRegex = /\/\* Verbalized Sampling Integration[\s\S]*?\*\/\n*/g;
        if (vsSectionRegex.test(original)) {
          return original.replace(vsSectionRegex, vsContent + '\n');
        }
        return vsContent + original;

      default:
        return original + vsContent;
    }
  }

  /**
   * Batch inject VS into multiple agents
   */
  async batchInjectAgents(
    agents: Array<{
      path: string;
      platform: PlatformConfig;
      problem: string;
      agentType: 'research' | 'planning' | 'development';
    }>
  ): Promise<VSInjectionResult[]> {
    const results: VSInjectionResult[] = [];

    for (const agent of agents) {
      const result = await this.injectIntoAgent(
        agent.path,
        agent.platform,
        agent.problem,
        agent.agentType
      );
      results.push(result);
    }

    return results;
  }

  /**
   * Create VS integration template for a platform
   */
  async createPlatformTemplate(platform: PlatformConfig): Promise<string> {
    const template = `
# Verbalized Sampling Integration Template for ${platform.name.toUpperCase()}

This template provides standardized verbalized sampling integration for ${platform.name} agents.

## Usage

1. Include this template in your agent configuration
2. Set the appropriate problem context and agent type
3. The system will automatically generate and rank strategies

## Integration Pattern: ${platform.injectionPattern}

## Comment Style: ${platform.commentStyle}

## Example Configuration

\`\`\`yaml
verbalized_sampling:
  enabled: true
  confidence_threshold: ${this.config.confidenceThreshold}
  strategy_count: ${this.config.strategyCount}
  output_format: ${this.config.outputFormat}
\`\`\`

## Generated Content Structure

- **Selected Strategy**: The highest-confidence approach
- **Confidence Score**: Overall confidence percentage
- **Alternative Strategies**: Other viable approaches with their confidence scores
- **Execution Plans**: Brief overview of implementation steps

## Auto-Integration

When \`autoInject: true\`, the system will automatically:
1. Analyze the agent's purpose and context
2. Generate appropriate strategies
3. Inject the VS integration at the specified location
4. Update the agent configuration

## Manual Integration

For manual integration, use the following structure:

\`\`\`markdown
