/**
 * Validation and Testing Framework for Verbalized Sampling Integration
 *
 * Provides comprehensive validation, testing, and quality assurance for VS integration
 * Supports all platforms and component types
 */

import { readFile, writeFile, readdir, stat } from 'fs/promises';
import { join, basename, dirname, extname } from 'path';
import { Adapters } from './platform-adapters.js';
import { InjectionPatterns } from './injection-patterns.js';
import { executeVerbalizedSampling, VSRequest } from './index.js';

export interface ValidationResult {
  valid: boolean;
  componentType: 'agent' | 'command' | 'skill';
  platform: 'opencode' | 'claude' | 'cursor';
  filePath: string;
  errors: string[];
  warnings: string[];
  suggestions: string[];
  score: number; // 0-100 quality score
}

export interface TestResult {
  testName: string;
  passed: boolean;
  duration: number;
  details: string;
  error?: string;
}

export interface ValidationReport {
  timestamp: string;
  totalFiles: number;
  validFiles: number;
  invalidFiles: number;
  averageScore: number;
  results: ValidationResult[];
  testResults: TestResult[];
  summary: {
    byPlatform: Record<string, { total: number; valid: number; avgScore: number }>;
    byComponentType: Record<string, { total: number; valid: number; avgScore: number }>;
    commonErrors: Array<{ error: string; count: number }>;
    commonWarnings: Array<{ warning: string; count: number }>;
  };
}

export interface ValidationConfig {
  strictMode: boolean;
  includeWarnings: boolean;
  includeSuggestions: boolean;
  testVSGeneration: boolean;
  testIntegration: boolean;
  testPlatformCompliance: boolean;
  minQualityScore: number;
  platforms: ('opencode' | 'claude' | 'cursor')[];
  componentTypes: ('agent' | 'command' | 'skill')[];
}

export class VSValidationFramework {
  private config: ValidationConfig;

  constructor(config?: Partial<ValidationConfig>) {
    this.config = {
      strictMode: false,
      includeWarnings: true,
      includeSuggestions: true,
      testVSGeneration: true,
      testIntegration: true,
      testPlatformCompliance: true,
      minQualityScore: 70,
      platforms: ['opencode', 'claude', 'cursor'],
      componentTypes: ['agent', 'command', 'skill'],
      ...config,
    };
  }

  /**
   * Validate a single file
   */
  async validateFile(filePath: string): Promise<ValidationResult> {
    const result: ValidationResult = {
      valid: false,
      componentType: 'agent',
      platform: 'opencode',
      filePath,
      errors: [],
      warnings: [],
      suggestions: [],
      score: 0,
    };

    // Skip documentation files
    const fileName = basename(filePath).toLowerCase();
    if (
      fileName === 'readme.md' ||
      fileName === 'agents.md' ||
      fileName === 'contributing.md' ||
      fileName.startsWith('readme') ||
      fileName.includes('changelog') ||
      fileName.includes('license')
    ) {
      result.valid = true;
      result.score = 100;
      result.warnings.push('Documentation file - VS validation skipped');
      return result;
    }

    try {
      // Determine platform and component type
      const { platform, componentType } = await this.determineFileContext(filePath);
      result.platform = platform;
      result.componentType = componentType;

      // Read file content
      const content = await readFile(filePath, 'utf-8');

      // Validate file structure
      await this.validateFileStructure(filePath, platform, componentType, result);

      // Validate VS integration
      await this.validateVSIntegration(content, platform, componentType, result);

      // Validate platform compliance
      if (this.config.testPlatformCompliance) {
        await this.validatePlatformCompliance(content, platform, componentType, result);
      }

      // Test VS generation if enabled
      if (this.config.testVSGeneration) {
        await this.testVSGeneration(content, componentType, result);
      }

      // Calculate quality score
      result.score = this.calculateQualityScore(result);

      // Determine validity
      result.valid = result.errors.length === 0 && result.score >= this.config.minQualityScore;
    } catch (error) {
      result.errors.push(`Validation failed: ${error}`);
      result.valid = false;
      result.score = 0;
    }

    return result;
  }

  /**
   * Validate directory recursively
   */
  async validateDirectory(dirPath: string): Promise<ValidationReport> {
    const startTime = Date.now();
    const report: ValidationReport = {
      timestamp: new Date().toISOString(),
      totalFiles: 0,
      validFiles: 0,
      invalidFiles: 0,
      averageScore: 0,
      results: [],
      testResults: [],
      summary: {
        byPlatform: {},
        byComponentType: {},
        commonErrors: [],
        commonWarnings: [],
      },
    };

    try {
      // Find all relevant files
      const files = await this.findRelevantFiles(dirPath);
      report.totalFiles = files.length;

      // Validate each file
      for (const file of files) {
        const result = await this.validateFile(file);
        report.results.push(result);

        if (result.valid) {
          report.validFiles++;
        } else {
          report.invalidFiles++;
        }

        // Update summary statistics
        this.updateSummaryStatistics(result, report.summary);
      }

      // Run integration tests if enabled
      if (this.config.testIntegration) {
        report.testResults = await this.runIntegrationTests(dirPath);
      }

      // Calculate average score
      const totalScore = report.results.reduce((sum, result) => sum + result.score, 0);
      report.averageScore = report.totalFiles > 0 ? totalScore / report.totalFiles : 0;
    } catch (error) {
      // Add error to test results
      report.testResults.push({
        testName: 'Directory Validation',
        passed: false,
        duration: Date.now() - startTime,
        details: `Directory validation failed: ${error}`,
        error: error as string,
      });
    }

    return report;
  }

  /**
   * Determine file context (platform and component type)
   */
  private async determineFileContext(filePath: string): Promise<{
    platform: 'opencode' | 'claude' | 'cursor';
    componentType: 'agent' | 'command' | 'skill';
  }> {
    const fileName = basename(filePath);
    const dirPath = dirname(filePath);

    // Determine platform from path
    let platform: 'opencode' | 'claude' | 'cursor' = 'opencode';
    if (dirPath.includes('commands-simplified') || dirPath.includes('agents')) {
      platform = 'claude';
    } else if (dirPath.includes('.cursor')) {
      platform = 'cursor';
    }

    // Determine component type from path and filename
    let componentType: 'agent' | 'command' | 'skill' = 'agent';
    if (dirPath.includes('commands') || fileName.includes('command')) {
      componentType = 'command';
    } else if (dirPath.includes('skills') || fileName.includes('skill')) {
      componentType = 'skill';
    }

    return { platform, componentType };
  }

  /**
   * Validate file structure
   */
  private async validateFileStructure(
    filePath: string,
    platform: 'opencode' | 'claude' | 'cursor',
    componentType: 'agent' | 'command' | 'skill',
    result: ValidationResult
  ): Promise<void> {
    const adapter = Adapters.getAdapter(platform);
    if (!adapter) {
      result.errors.push(`Unknown platform: ${platform}`);
      return;
    }

    // Validate file extension
    const extension = extname(filePath);
    if (!adapter.fileExtensions.includes(extension)) {
      result.errors.push(
        `Invalid file extension: ${extension}. Expected: ${adapter.fileExtensions.join(', ')}`
      );
    }

    // Validate platform-specific structure
    const structureValidation = await Adapters.validateFileStructure(platform, filePath);
    if (!structureValidation.valid) {
      result.errors.push(...structureValidation.errors);
    }

    // Check for required sections based on component type
    const content = await readFile(filePath, 'utf-8');
    await this.validateRequiredSections(content, componentType, result);
  }

  /**
   * Validate required sections
   */
  private async validateRequiredSections(
    content: string,
    componentType: 'agent' | 'command' | 'skill',
    result: ValidationResult
  ): Promise<void> {
    const lines = content.split('\n');
    const hasHeadings = lines.some((line) => line.startsWith('#'));

    if (!hasHeadings) {
      result.warnings.push('No markdown headings found - consider adding structure');
    }

    // Check for front matter in agents
    if (componentType === 'agent') {
      if (!content.startsWith('---')) {
        result.warnings.push('Agent files should include YAML front matter');
      }
    }

    // Check for description
    const hasDescription = lines.some(
      (line) =>
        line.startsWith('# ') || line.match(/^description:\s*.+/i) || line.match(/^summary:\s*.+/i)
    );

    if (!hasDescription) {
      result.warnings.push('No description or summary found');
    }
  }

  /**
   * Validate VS integration
   */
  private async validateVSIntegration(
    content: string,
    platform: 'opencode' | 'claude' | 'cursor',
    componentType: 'agent' | 'command' | 'skill',
    result: ValidationResult
  ): Promise<void> {
    const hasVSIntegration =
      content.includes('VERBALIZED SAMPLING') || content.includes('verbalized_sampling');

    if (!hasVSIntegration) {
      result.warnings.push('No verbalized sampling integration found');
      result.suggestions.push('Consider adding VS integration for better decision-making');
      return;
    }

    // Validate VS structure
    await this.validateVSStructure(content, platform, componentType, result);
  }

  /**
   * Validate VS structure
   */
  private async validateVSStructure(
    content: string,
    platform: 'opencode' | 'claude' | 'cursor',
    componentType: 'agent' | 'command' | 'skill',
    result: ValidationResult
  ): Promise<void> {
    // Check for selected strategy
    const hasSelectedStrategy =
      content.includes('Selected Strategy') || content.includes('selected_strategy');

    if (!hasSelectedStrategy) {
      result.errors.push('VS integration missing selected strategy');
    }

    // Check for confidence score
    const hasConfidence = content.includes('Confidence:') || content.includes('confidence_score');

    if (!hasConfidence) {
      result.errors.push('VS integration missing confidence score');
    }

    // Check for strategy list
    const hasStrategyList =
      content.includes('Available Strategies') || content.includes('strategies:');

    if (!hasStrategyList) {
      result.warnings.push('VS integration missing strategy list');
    }

    // Validate pattern-specific requirements
    const pattern = InjectionPatterns.getPlatformPattern(
      componentType,
      platform,
      platform === 'claude' ? 'prepend-approach' : 'frontmatter-section'
    );

    if (pattern) {
      for (const variable of pattern.variables) {
        const placeholder = `{{${variable}}}`;
        if (content.includes(placeholder)) {
          result.errors.push(`Unresolved template variable: ${placeholder}`);
        }
      }
    }
  }

  /**
   * Validate platform compliance
   */
  private async validatePlatformCompliance(
    content: string,
    platform: 'opencode' | 'claude' | 'cursor',
    componentType: 'agent' | 'command' | 'skill',
    result: ValidationResult
  ): Promise<void> {
    const adapter = Adapters.getAdapter(platform);
    if (!adapter) return;

    // Check indentation
    const lines = content.split('\n');
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.startsWith('\t') && adapter.conventions.indentation === 'spaces') {
        result.errors.push(`Line ${i + 1}: Uses tabs but ${platform} expects spaces`);
        break;
      }
    }

    // Check front matter for platforms that require it
    if (adapter.conventions.frontMatter && !content.startsWith('---')) {
      result.warnings.push(`${platform} typically uses YAML front matter`);
    }

    // Platform-specific checks
    if (platform === 'opencode' && componentType === 'agent') {
      if (!content.includes('```jsonc')) {
        result.warnings.push('OpenCode agents should include JSONC configuration');
      }
    }
  }

  /**
   * Test VS generation
   */
  private async testVSGeneration(
    content: string,
    componentType: 'agent' | 'command' | 'skill',
    result: ValidationResult
  ): Promise<void> {
    try {
      // Extract problem from content
      const problem = this.extractProblemFromContent(content);
      if (!problem) {
        result.warnings.push('Could not extract problem for VS generation test');
        return;
      }

      // Test VS generation
      const request: VSRequest = {
        problem,
        agent_type:
          componentType === 'agent'
            ? 'research'
            : componentType === 'command'
              ? 'planning'
              : 'development',
        context: {
          existing_patterns: ['test-pattern'],
          constraints: ['test-constraint'],
        },
      };

      const vsResult = await executeVerbalizedSampling(request);

      // Validate VS result
      if (!vsResult.strategies || vsResult.strategies.strategies.length === 0) {
        result.errors.push('VS generation failed - no strategies generated');
      }

      if (!vsResult.strategies.selected_strategy) {
        result.errors.push('VS generation failed - no selected strategy');
      }

      if (vsResult.strategies.total_confidence < 0.5) {
        result.warnings.push('VS generation produced low confidence scores');
      }
    } catch (error) {
      result.errors.push(`VS generation test failed: ${error}`);
    }
  }

  /**
   * Extract problem from content
   */
  private extractProblemFromContent(content: string): string | null {
    const lines = content.split('\n');

    // Look for problem in common locations
    for (const line of lines) {
      if (line.startsWith('# ')) {
        return line.substring(2).trim();
      }
      if (line.toLowerCase().startsWith('problem:')) {
        return line.substring(9).trim();
      }
      if (line.toLowerCase().startsWith('description:')) {
        return line.substring(13).trim();
      }
    }

    return null;
  }

  /**
   * Calculate quality score
   */
  private calculateQualityScore(result: ValidationResult): number {
    let score = 100;

    // Deduct points for errors
    score -= result.errors.length * 20;

    // Deduct points for warnings
    score -= result.warnings.length * 5;

    // Bonus points for having VS integration
    const hasVS =
      result.errors.some((e) => e.includes('VS integration')) ||
      result.warnings.some((w) => w.includes('VS integration'));
    if (!hasVS) {
      score -= 10;
    }

    // Ensure score is within bounds
    return Math.max(0, Math.min(100, score));
  }

  /**
   * Find relevant files in directory
   */
  private async findRelevantFiles(dirPath: string): Promise<string[]> {
    const files: string[] = [];

    async function scanDirectory(currentPath: string): Promise<void> {
      try {
        const entries = await readdir(currentPath, { withFileTypes: true });

        for (const entry of entries) {
          const fullPath = join(currentPath, entry.name);

          if (entry.isDirectory()) {
            // Skip hidden directories and node_modules
            if (!entry.name.startsWith('.') && entry.name !== 'node_modules') {
              await scanDirectory(fullPath);
            }
          } else if (entry.isFile()) {
            const extension = extname(entry.name);
            if (['.md', '.jsonc', '.ts', '.js', '.cursorrules'].includes(extension)) {
              files.push(fullPath);
            }
          }
        }
      } catch {
        // Skip directories that can't be read
      }
    }

    await scanDirectory(dirPath);
    return files;
  }

  /**
   * Update summary statistics
   */
  private updateSummaryStatistics(
    result: ValidationResult,
    summary: ValidationReport['summary']
  ): void {
    // Update platform statistics
    if (!summary.byPlatform[result.platform]) {
      summary.byPlatform[result.platform] = { total: 0, valid: 0, avgScore: 0 };
    }
    summary.byPlatform[result.platform].total++;
    if (result.valid) {
      summary.byPlatform[result.platform].valid++;
    }

    // Update component type statistics
    if (!summary.byComponentType[result.componentType]) {
      summary.byComponentType[result.componentType] = { total: 0, valid: 0, avgScore: 0 };
    }
    summary.byComponentType[result.componentType].total++;
    if (result.valid) {
      summary.byComponentType[result.componentType].valid++;
    }

    // Track common errors and warnings
    for (const error of result.errors) {
      const existing = summary.commonErrors.find((e) => e.error === error);
      if (existing) {
        existing.count++;
      } else {
        summary.commonErrors.push({ error, count: 1 });
      }
    }

    for (const warning of result.warnings) {
      const existing = summary.commonWarnings.find((w) => w.warning === warning);
      if (existing) {
        existing.count++;
      } else {
        summary.commonWarnings.push({ warning, count: 1 });
      }
    }
  }

  /**
   * Run integration tests
   */
  private async runIntegrationTests(_dirPath: string): Promise<TestResult[]> {
    const testResults: TestResult[] = [];

    // Test platform adapters
    for (const platform of this.config.platforms) {
      const adapter = Adapters.getAdapter(platform);
      if (adapter) {
        testResults.push({
          testName: `Platform Adapter: ${platform}`,
          passed: true,
          duration: 0,
          details: `Adapter loaded successfully for ${platform}`,
        });
      } else {
        testResults.push({
          testName: `Platform Adapter: ${platform}`,
          passed: false,
          duration: 0,
          details: `Failed to load adapter for ${platform}`,
        });
      }
    }

    // Test injection patterns
    for (const componentType of this.config.componentTypes) {
      const patterns = InjectionPatterns.getAllPatterns(
        componentType === 'agent' ? 'agent' : componentType === 'command' ? 'command' : 'skill'
      );

      testResults.push({
        testName: `Injection Patterns: ${componentType}`,
        passed: patterns.length > 0,
        duration: 0,
        details: `Found ${patterns.length} patterns for ${componentType}`,
      });
    }

    // Test VS generation
    try {
      const testRequest: VSRequest = {
        problem: 'Test problem for validation',
        agent_type: 'research',
      };

      const startTime = Date.now();
      const vsResult = await executeVerbalizedSampling(testRequest);
      const duration = Date.now() - startTime;

      testResults.push({
        testName: 'VS Generation Test',
        passed: vsResult.strategies.strategies.length > 0,
        duration,
        details: `Generated ${vsResult.strategies.strategies.length} strategies in ${duration}ms`,
      });
    } catch (error) {
      testResults.push({
        testName: 'VS Generation Test',
        passed: false,
        duration: 0,
        details: `VS generation failed: ${error}`,
        error: error as string,
      });
    }

    return testResults;
  }

  /**
   * Generate validation report
   */
  async generateReport(report: ValidationReport, outputPath?: string): Promise<string> {
    const reportContent = this.formatReport(report);

    if (outputPath) {
      await writeFile(outputPath, reportContent, 'utf-8');
    }

    return reportContent;
  }

  /**
   * Format validation report
   */
  private formatReport(report: ValidationReport): string {
    const sections = [
      `# Verbalized Sampling Validation Report`,
      `Generated: ${report.timestamp}`,
      '',
      `## Summary`,
      `- Total Files: ${report.totalFiles}`,
      `- Valid Files: ${report.validFiles}`,
      `- Invalid Files: ${report.invalidFiles}`,
      `- Average Score: ${report.averageScore.toFixed(1)}/100`,
      '',
      `## Results by Platform`,
    ];

    for (const [platform, stats] of Object.entries(report.summary.byPlatform)) {
      sections.push(
        `- **${platform}**: ${stats.valid}/${stats.total} valid (${((stats.valid / stats.total) * 100).toFixed(1)}%)`
      );
    }

    sections.push('', '## Results by Component Type');

    for (const [componentType, stats] of Object.entries(report.summary.byComponentType)) {
      sections.push(
        `- **${componentType}**: ${stats.valid}/${stats.total} valid (${((stats.valid / stats.total) * 100).toFixed(1)}%)`
      );
    }

    if (report.summary.commonErrors.length > 0) {
      sections.push(
        '',
        '## Common Errors',
        ...report.summary.commonErrors.map(
          (error) => `- ${error.error} (${error.count} occurrences)`
        )
      );
    }

    if (report.summary.commonWarnings.length > 0) {
      sections.push(
        '',
        '## Common Warnings',
        ...report.summary.commonWarnings.map(
          (warning) => `- ${warning.warning} (${warning.count} occurrences)`
        )
      );
    }

    if (this.config.includeWarnings) {
      sections.push(
        '',
        '## Detailed Results',
        ...report.results.map((result) => this.formatValidationResult(result))
      );
    }

    if (report.testResults.length > 0) {
      sections.push(
        '',
        '## Test Results',
        ...report.testResults.map((test) => this.formatTestResult(test))
      );
    }

    return sections.join('\n');
  }

  /**
   * Format validation result
   */
  private formatValidationResult(result: ValidationResult): string {
    const status = result.valid ? '✅ Valid' : '❌ Invalid';
    const sections = [
      `### ${basename(result.filePath)} - ${status} (${result.score}/100)`,
      `- Platform: ${result.platform}`,
      `- Type: ${result.componentType}`,
    ];

    if (result.errors.length > 0) {
      sections.push('**Errors:**', ...result.errors.map((error) => `- ${error}`));
    }

    if (result.warnings.length > 0) {
      sections.push('**Warnings:**', ...result.warnings.map((warning) => `- ${warning}`));
    }

    if (result.suggestions.length > 0) {
      sections.push(
        '**Suggestions:**',
        ...result.suggestions.map((suggestion) => `- ${suggestion}`)
      );
    }

    sections.push('');
    return sections.join('\n');
  }

  /**
   * Format test result
   */
  private formatTestResult(test: TestResult): string {
    const status = test.passed ? '✅ Passed' : '❌ Failed';
    return `- **${test.testName}**: ${status} (${test.duration}ms) - ${test.details}`;
  }

  /**
   * Get current configuration
   */
  getConfig(): ValidationConfig {
    return { ...this.config };
  }

  /**
   * Update configuration
   */
  updateConfig(newConfig: Partial<ValidationConfig>): void {
    this.config = { ...this.config, ...newConfig };
  }
}

// Convenience functions
export async function validateVSFile(
  filePath: string,
  config?: Partial<ValidationConfig>
): Promise<ValidationResult> {
  const framework = new VSValidationFramework(config);
  return await framework.validateFile(filePath);
}

export async function validateVSDirectory(
  dirPath: string,
  config?: Partial<ValidationConfig>
): Promise<ValidationReport> {
  const framework = new VSValidationFramework(config);
  return await framework.validateDirectory(dirPath);
}

export async function runVSValidation(
  path: string,
  config?: Partial<ValidationConfig>
): Promise<ValidationReport> {
  const framework = new VSValidationFramework(config);

  const stats = await stat(path);
  if (stats.isDirectory()) {
    return await framework.validateDirectory(path);
  } else {
    const result = await framework.validateFile(path);
    return {
      timestamp: new Date().toISOString(),
      totalFiles: 1,
      validFiles: result.valid ? 1 : 0,
      invalidFiles: result.valid ? 0 : 1,
      averageScore: result.score,
      results: [result],
      testResults: [],
      summary: {
        byPlatform: {
          [result.platform]: { total: 1, valid: result.valid ? 1 : 0, avgScore: result.score },
        },
        byComponentType: {
          [result.componentType]: { total: 1, valid: result.valid ? 1 : 0, avgScore: result.score },
        },
        commonErrors: result.errors.map((error) => ({ error, count: 1 })),
        commonWarnings: result.warnings.map((warning) => ({ warning, count: 1 })),
      },
    };
  }
}
