#!/usr/bin/env node

/**
 * Verbalized Sampling CLI Tool
 *
 * Simple command-line interface for managing verbalized sampling integration
 */

import { writeFile } from 'fs/promises';
import { join } from 'path';
// Temporary stubs for missing imports
const runVSValidation = () => {
  console.log('VS validation temporarily disabled');
};
const Adapters = { opencode: {}, claude: {}, cursor: {} };
const InjectionPatterns = { getPatterns: () => [] };
const injectVSIntoComponent = () => {
  console.log('VS injection temporarily disabled');
};

function showHelp() {
  console.log(`
Verbalized Sampling CLI - Usage:

vs-cli <command> [options]

Commands:
  validate <path>     Validate VS integration in files or directories
  info               Show VS integration information and statistics
  init               Initialize VS integration in current directory
  test <problem>     Test VS generation with sample problem
  inject <file>      Inject VS integration into a specific file
  help               Show this help message

Examples:
  vs-cli validate .                    # Validate current directory
  vs-cli validate base-agents/         # Validate agents directory
  vs-cli test "How does auth work?"    # Test VS generation
  vs-cli info                          # Show system information
  vs-cli init                          # Initialize VS integration

Options for validate:
  --platform <opencode|claude|cursor>  Specify platform
  --type <agent|command|skill>         Specify component type
  --strict                             Enable strict validation
  --output <file>                      Save report to file
  --no-warnings                        Disable warnings
  --no-suggestions                     Disable suggestions
`);
}

async function handleValidate(path: string, options: any = {}) {
  try {
    console.log(`üîç Validating VS integration in: ${path}`);

    const config = {
      strictMode: options.strict || false,
      includeWarnings: options.warnings !== false,
      includeSuggestions: options.suggestions !== false,
      platforms: options.platform ? [options.platform] : ['opencode', 'claude', 'cursor'],
      componentTypes: options.type ? [options.type] : ['agent', 'command', 'skill'],
    };

    const report = await runVSValidation(path, config);

    if (options.output) {
      await writeFile(options.output, JSON.stringify(report, null, 2), 'utf-8');
      console.log(`üìÑ Report saved to: ${options.output}`);
    }

    // Print summary
    console.log(`\nüìä Validation Summary:`);
    console.log(`   Total files: ${report.totalFiles}`);
    console.log(`   Valid files: ${report.validFiles}`);
    console.log(`   Invalid files: ${report.invalidFiles}`);
    console.log(`   Average score: ${report.averageScore.toFixed(1)}/100`);

    if (report.invalidFiles > 0) {
      console.log(`\n‚ùå Validation failed with ${report.invalidFiles} invalid files`);
      process.exit(1);
    } else {
      console.log(`\n‚úÖ All files passed validation`);
    }
  } catch (error) {
    console.error(`‚ùå Validation failed: ${error}`);
    process.exit(1);
  }
}

async function handleInfo() {
  try {
    console.log(`üìä Verbalized Sampling Integration Information\n`);

    // Platform statistics
    const platformStats = Adapters.getStatistics();
    console.log(`üèóÔ∏è  Platform Support:`);
    console.log(`   Total platforms: ${platformStats.totalPlatforms}`);
    console.log(`   Supported platforms: ${platformStats.platforms.join(', ')}`);
    console.log(`   Component types: ${platformStats.supportedComponents.join(', ')}`);

    // Pattern statistics
    const patternStats = InjectionPatterns.getStatistics();
    console.log(`\nüé® Injection Patterns:`);
    console.log(`   Total patterns: ${patternStats.totalPatterns}`);
    console.log(`   By type:`);
    for (const [type, count] of Object.entries(patternStats.patternsByType)) {
      console.log(`     ${type}: ${count} patterns`);
    }

    // Available patterns by type
    const agentPatterns = InjectionPatterns.listPatternNames('agent');
    console.log(`\nü§ñ Agent Patterns:`);
    agentPatterns.forEach((pattern) => console.log(`   - ${pattern}`));

    const commandPatterns = InjectionPatterns.listPatternNames('command');
    console.log(`\n‚ö° Command Patterns:`);
    commandPatterns.forEach((pattern) => console.log(`   - ${pattern}`));

    const skillPatterns = InjectionPatterns.listPatternNames('skill');
    console.log(`\nüõ†Ô∏è  Skill Patterns:`);
    skillPatterns.forEach((pattern) => console.log(`   - ${pattern}`));

    console.log(`\n‚úÖ VS integration system is ready to use!`);
  } catch (error) {
    console.error(`‚ùå Failed to get information: ${error}`);
    process.exit(1);
  }
}

async function handleInit(options: any = {}) {
  try {
    console.log(`üöÄ Initializing VS integration...`);

    const platform = options.platform || 'opencode';

    // Create directory structure
    await Adapters.createDirectoryStructure(platform as any, process.cwd());

    // Create basic configuration
    const config = {
      verbalized_sampling: {
        enabled: true,
        platform,
        auto_inject: true,
        confidence_threshold: 0.7,
        strategy_count: 3,
        output_format: 'markdown',
      },
    };

    const configFile = join(process.cwd(), 'vs-config.json');
    await writeFile(configFile, JSON.stringify(config, null, 2), 'utf-8');

    console.log(`‚úÖ VS integration initialized successfully`);
    console.log(`   Platform: ${platform}`);
    console.log(`   Config file: ${configFile}`);
    console.log(`\nüìñ Next steps:`);
    console.log(`   1. Run 'vs-cli validate .' to check existing files`);
    console.log(`   2. Run 'vs-cli test <problem>' to test VS generation`);
  } catch (error) {
    console.error(`‚ùå Initialization failed: ${error}`);
    process.exit(1);
  }
}

async function handleTest(problem: string, options: any = {}) {
  try {
    console.log(`üß™ Testing VS generation`);
    console.log(`üìù Problem: ${problem}`);

    const { UniversalVSIntegration } = await import('./universal-integration.js');
    const integration = new UniversalVSIntegration();

    const vsResult = await integration.generateVSIntegration(
      problem,
      (options.type as any) || 'research',
      {
        existing_patterns: ['test-pattern'],
        constraints: ['test-constraint'],
      }
    );

    // Terminal format
    console.log(`\nüéØ Selected Strategy: ${vsResult.strategies.selected_strategy}`);
    console.log(`üìä Confidence: ${(vsResult.strategies.total_confidence * 100).toFixed(1)}%`);
    console.log(`\nüìã Available Strategies:`);

    vsResult.strategies.strategies.forEach((strategy, index) => {
      const isSelected = strategy.name === vsResult.strategies.selected_strategy;
      const icon = isSelected ? 'üëâ' : '  ';
      console.log(
        `${icon} ${index + 1}. ${strategy.name} (${(strategy.confidence_score * 100).toFixed(1)}%)`
      );
      if (strategy.execution_plan.length > 0) {
        console.log(`     ${strategy.execution_plan.slice(0, 2).join(' ‚Üí ')}...`);
      }
    });
  } catch (error) {
    console.error('‚ùå Test failed:', (error as Error).message);
    process.exit(1);
  }
}

async function handleInject(filePath: string, options: any = {}) {
  try {
    console.log(`üîß Injecting VS integration into: ${filePath}`);

    const platform = options.platform || 'opencode';
    const problem = options.problem || 'General problem solving';
    const agentType = options.type || 'research';

    const result = await injectVSIntoComponent(filePath, platform, problem, agentType);

    console.log(`‚úÖ VS integration injected successfully`);
    console.log(`   File: ${result.filePath}`);
    console.log(`   Pattern: ${result.injectionType}`);
    console.log(`   Strategies: ${result.vsIntegration.strategiesCount}`);
    console.log(`   Selected: ${result.vsIntegration.selectedStrategy}`);
    console.log(`   Confidence: ${(result.vsIntegration.confidenceScore * 100).toFixed(1)}%`);
  } catch (error) {
    console.error('‚ùå Injection failed:', (error as Error).message);
    process.exit(1);
  }
}

function parseOptions(args: string[]): { command: string; args: string[]; options: any } {
  const options: any = {};
  const commandArgs: string[] = [];

  for (let i = 1; i < args.length; i++) {
    const arg = args[i];

    if (arg.startsWith('--')) {
      const [key, value] = arg.substring(2).split('=');
      if (value) {
        options[key] = value;
      } else {
        // Flag without value
        options[key] = true;
      }
    } else if (arg.startsWith('-')) {
      const key = arg.substring(1);
      options[key] = true;
    } else {
      commandArgs.push(arg);
    }
  }

  return {
    command: args[0] || 'help',
    args: commandArgs,
    options,
  };
}

// Main execution
async function main() {
  const cliArgs = process.argv.slice(2);
  const { command, args, options } = parseOptions(cliArgs);

  switch (command) {
    case 'validate':
      if (args.length === 0) {
        console.error('‚ùå Please provide a path to validate');
        process.exit(1);
      }
      await handleValidate(args[0], options);
      break;

    case 'info':
      await handleInfo();
      break;

    case 'init':
      await handleInit(options);
      break;

    case 'test':
      if (args.length === 0) {
        console.error('‚ùå Please provide a problem to test');
        process.exit(1);
      }
      await handleTest(args.join(' '), options);
      break;

    case 'inject':
      if (args.length === 0) {
        console.error('‚ùå Please provide a file path to inject into');
        process.exit(1);
      }
      await handleInject(args[0], options);
      break;

    case 'help':
    default:
      showHelp();
      break;
  }
}

// Run main function
main().catch((error) => {
  console.error('‚ùå Unexpected error:', error);
  process.exit(1);
});
