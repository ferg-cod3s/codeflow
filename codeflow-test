#!/usr/bin/env node
// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = import.meta.require;

// src/optimization/performance.ts
import { readFile, stat } from "fs/promises";

class AgentParseCache {
  cache = new Map;
  errorCache = new Map;
  maxAge = 5 * 60 * 1000;
  hits = 0;
  misses = 0;
  async get(filePath) {
    try {
      const stats = await stat(filePath);
      const mtime = stats.mtime.getTime();
      const cachedEntry = this.cache.get(filePath);
      if (cachedEntry) {
        const isValid = Date.now() - cachedEntry.timestamp < this.maxAge && cachedEntry.mtime === mtime;
        if (isValid) {
          this.hits++;
          return cachedEntry.data;
        } else {
          this.cache.delete(filePath);
        }
      }
      const cachedError = this.errorCache.get(filePath);
      if (cachedError) {
        const isValid = Date.now() - cachedError.timestamp < this.maxAge && cachedError.mtime === mtime;
        if (isValid) {
          this.hits++;
          return cachedError.data;
        } else {
          this.errorCache.delete(filePath);
        }
      }
      this.misses++;
      return null;
    } catch {
      this.misses++;
      return null;
    }
  }
  async set(filePath, agent) {
    try {
      const stats = await stat(filePath);
      const mtime = stats.mtime.getTime();
      this.cache.set(filePath, {
        data: agent,
        timestamp: Date.now(),
        mtime
      });
    } catch {}
  }
  async setError(filePath, error) {
    try {
      const stats = await stat(filePath);
      const mtime = stats.mtime.getTime();
      this.errorCache.set(filePath, {
        data: error,
        timestamp: Date.now(),
        mtime
      });
    } catch {}
  }
  getStats() {
    const total = this.hits + this.misses;
    const hitRate = total > 0 ? this.hits / total * 100 : 0;
    return {
      hits: this.hits,
      misses: this.misses,
      hitRate: Math.round(hitRate * 100) / 100,
      cacheSize: this.cache.size + this.errorCache.size
    };
  }
  clear() {
    this.cache.clear();
    this.errorCache.clear();
    this.hits = 0;
    this.misses = 0;
  }
}

class SyncBatcher {
  onBatch;
  pending = new Set;
  timer = null;
  batchDelay = 500;
  maxBatchSize = 50;
  constructor(onBatch) {
    this.onBatch = onBatch;
  }
  add(filePath) {
    this.pending.add(filePath);
    if (this.pending.size >= this.maxBatchSize) {
      this.flush();
      return;
    }
    if (this.timer) {
      clearTimeout(this.timer);
    }
    this.timer = setTimeout(() => {
      this.flush();
    }, this.batchDelay);
  }
  flush() {
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }
    if (this.pending.size === 0) {
      return;
    }
    const filePaths = Array.from(this.pending);
    this.pending.clear();
    this.onBatch(filePaths).catch((error) => {
      console.error("Batch processing error:", error);
    });
  }
  getPendingCount() {
    return this.pending.size;
  }
}

class PerformanceMonitor {
  metrics = {
    fileWatchLatency: 0,
    agentParseTime: 0,
    syncOperationTime: 0,
    cacheHitRate: 0
  };
  parseCache = new AgentParseCache;
  syncBatcher;
  constructor(onSyncBatch) {
    this.syncBatcher = new SyncBatcher(onSyncBatch || (async () => {}));
  }
  async time(operation) {
    const start = performance.now();
    const result = await operation();
    const duration = performance.now() - start;
    return { result, duration };
  }
  getParseCache() {
    return this.parseCache;
  }
  getSyncBatcher() {
    return this.syncBatcher;
  }
  updateMetrics(updates) {
    Object.assign(this.metrics, updates);
  }
  getMetrics() {
    return {
      ...this.metrics,
      cache: this.parseCache.getStats()
    };
  }
  checkPerformanceTargets() {
    const cacheStats = this.parseCache.getStats();
    return {
      fileWatchLatency: {
        target: 1000,
        current: this.metrics.fileWatchLatency,
        passing: this.metrics.fileWatchLatency < 1000
      },
      agentParseTime: {
        target: 100,
        current: this.metrics.agentParseTime,
        passing: this.metrics.agentParseTime < 100
      },
      syncOperationTime: {
        target: 5000,
        current: this.metrics.syncOperationTime,
        passing: this.metrics.syncOperationTime < 5000
      },
      cacheHitRate: {
        target: 70,
        current: cacheStats.hitRate,
        passing: cacheStats.hitRate > 70
      }
    };
  }
  reset() {
    this.metrics = {
      fileWatchLatency: 0,
      agentParseTime: 0,
      syncOperationTime: 0,
      cacheHitRate: 0
    };
    this.parseCache.clear();
  }
}

class OptimizedFileReader {
  cache = new Map;
  maxAge = 2 * 60 * 1000;
  async readFile(filePath) {
    try {
      const stats = await stat(filePath);
      const mtime = stats.mtime.getTime();
      const cached = this.cache.get(filePath);
      if (cached) {
        const isValid = Date.now() - cached.timestamp < this.maxAge && cached.mtime === mtime;
        if (isValid) {
          return cached.data;
        } else {
          this.cache.delete(filePath);
        }
      }
      const content = await readFile(filePath, "utf-8");
      this.cache.set(filePath, {
        data: content,
        timestamp: Date.now(),
        mtime
      });
      return content;
    } catch (error) {
      throw new Error(`Failed to read file ${filePath}: ${error}`);
    }
  }
  clear() {
    this.cache.clear();
  }
  getSize() {
    return this.cache.size;
  }
}
var globalPerformanceMonitor, globalFileReader;
var init_performance = __esm(() => {
  globalPerformanceMonitor = new PerformanceMonitor;
  globalFileReader = new OptimizedFileReader;
});

// node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS((exports) => {
  var ALIAS = Symbol.for("yaml.alias");
  var DOC = Symbol.for("yaml.document");
  var MAP = Symbol.for("yaml.map");
  var PAIR = Symbol.for("yaml.pair");
  var SCALAR = Symbol.for("yaml.scalar");
  var SEQ = Symbol.for("yaml.seq");
  var NODE_TYPE = Symbol.for("yaml.node.type");
  var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
  var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
  var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
  var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
  var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
  var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
  function isCollection(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case MAP:
        case SEQ:
          return true;
      }
    return false;
  }
  function isNode(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case ALIAS:
        case MAP:
        case SCALAR:
        case SEQ:
          return true;
      }
    return false;
  }
  var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
  exports.ALIAS = ALIAS;
  exports.DOC = DOC;
  exports.MAP = MAP;
  exports.NODE_TYPE = NODE_TYPE;
  exports.PAIR = PAIR;
  exports.SCALAR = SCALAR;
  exports.SEQ = SEQ;
  exports.hasAnchor = hasAnchor;
  exports.isAlias = isAlias;
  exports.isCollection = isCollection;
  exports.isDocument = isDocument;
  exports.isMap = isMap;
  exports.isNode = isNode;
  exports.isPair = isPair;
  exports.isScalar = isScalar;
  exports.isSeq = isSeq;
});

// node_modules/yaml/dist/visit.js
var require_visit = __commonJS((exports) => {
  var identity = require_identity();
  var BREAK = Symbol("break visit");
  var SKIP = Symbol("skip children");
  var REMOVE = Symbol("remove node");
  function visit(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
      const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      visit_(null, node, visitor_, Object.freeze([]));
  }
  visit.BREAK = BREAK;
  visit.SKIP = SKIP;
  visit.REMOVE = REMOVE;
  function visit_(key, node, visitor, path) {
    const ctrl = callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
      replaceNode(key, path, ctrl);
      return visit_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
      if (identity.isCollection(node)) {
        path = Object.freeze(path.concat(node));
        for (let i = 0;i < node.items.length; ++i) {
          const ci = visit_(i, node.items[i], visitor, path);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (identity.isPair(node)) {
        path = Object.freeze(path.concat(node));
        const ck = visit_("key", node.key, visitor, path);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = visit_("value", node.value, visitor, path);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  async function visitAsync(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
      const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      await visitAsync_(null, node, visitor_, Object.freeze([]));
  }
  visitAsync.BREAK = BREAK;
  visitAsync.SKIP = SKIP;
  visitAsync.REMOVE = REMOVE;
  async function visitAsync_(key, node, visitor, path) {
    const ctrl = await callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
      replaceNode(key, path, ctrl);
      return visitAsync_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
      if (identity.isCollection(node)) {
        path = Object.freeze(path.concat(node));
        for (let i = 0;i < node.items.length; ++i) {
          const ci = await visitAsync_(i, node.items[i], visitor, path);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (identity.isPair(node)) {
        path = Object.freeze(path.concat(node));
        const ck = await visitAsync_("key", node.key, visitor, path);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = await visitAsync_("value", node.value, visitor, path);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  function initVisitor(visitor) {
    if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
      return Object.assign({
        Alias: visitor.Node,
        Map: visitor.Node,
        Scalar: visitor.Node,
        Seq: visitor.Node
      }, visitor.Value && {
        Map: visitor.Value,
        Scalar: visitor.Value,
        Seq: visitor.Value
      }, visitor.Collection && {
        Map: visitor.Collection,
        Seq: visitor.Collection
      }, visitor);
    }
    return visitor;
  }
  function callVisitor(key, node, visitor, path) {
    if (typeof visitor === "function")
      return visitor(key, node, path);
    if (identity.isMap(node))
      return visitor.Map?.(key, node, path);
    if (identity.isSeq(node))
      return visitor.Seq?.(key, node, path);
    if (identity.isPair(node))
      return visitor.Pair?.(key, node, path);
    if (identity.isScalar(node))
      return visitor.Scalar?.(key, node, path);
    if (identity.isAlias(node))
      return visitor.Alias?.(key, node, path);
    return;
  }
  function replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if (identity.isCollection(parent)) {
      parent.items[key] = node;
    } else if (identity.isPair(parent)) {
      if (key === "key")
        parent.key = node;
      else
        parent.value = node;
    } else if (identity.isDocument(parent)) {
      parent.contents = node;
    } else {
      const pt = identity.isAlias(parent) ? "alias" : "scalar";
      throw new Error(`Cannot replace node with ${pt} parent`);
    }
  }
  exports.visit = visit;
  exports.visitAsync = visitAsync;
});

// node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS((exports) => {
  var identity = require_identity();
  var visit = require_visit();
  var escapeChars = {
    "!": "%21",
    ",": "%2C",
    "[": "%5B",
    "]": "%5D",
    "{": "%7B",
    "}": "%7D"
  };
  var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);

  class Directives {
    constructor(yaml, tags) {
      this.docStart = null;
      this.docEnd = false;
      this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
      this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    clone() {
      const copy = new Directives(this.yaml, this.tags);
      copy.docStart = this.docStart;
      return copy;
    }
    atDocument() {
      const res = new Directives(this.yaml, this.tags);
      switch (this.yaml.version) {
        case "1.1":
          this.atNextDocument = true;
          break;
        case "1.2":
          this.atNextDocument = false;
          this.yaml = {
            explicit: Directives.defaultYaml.explicit,
            version: "1.2"
          };
          this.tags = Object.assign({}, Directives.defaultTags);
          break;
      }
      return res;
    }
    add(line, onError) {
      if (this.atNextDocument) {
        this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
        this.tags = Object.assign({}, Directives.defaultTags);
        this.atNextDocument = false;
      }
      const parts = line.trim().split(/[ \t]+/);
      const name = parts.shift();
      switch (name) {
        case "%TAG": {
          if (parts.length !== 2) {
            onError(0, "%TAG directive should contain exactly two parts");
            if (parts.length < 2)
              return false;
          }
          const [handle, prefix] = parts;
          this.tags[handle] = prefix;
          return true;
        }
        case "%YAML": {
          this.yaml.explicit = true;
          if (parts.length !== 1) {
            onError(0, "%YAML directive should contain exactly one part");
            return false;
          }
          const [version] = parts;
          if (version === "1.1" || version === "1.2") {
            this.yaml.version = version;
            return true;
          } else {
            const isValid = /^\d+\.\d+$/.test(version);
            onError(6, `Unsupported YAML version ${version}`, isValid);
            return false;
          }
        }
        default:
          onError(0, `Unknown directive ${name}`, true);
          return false;
      }
    }
    tagName(source, onError) {
      if (source === "!")
        return "!";
      if (source[0] !== "!") {
        onError(`Not a valid tag: ${source}`);
        return null;
      }
      if (source[1] === "<") {
        const verbatim = source.slice(2, -1);
        if (verbatim === "!" || verbatim === "!!") {
          onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
          return null;
        }
        if (source[source.length - 1] !== ">")
          onError("Verbatim tags must end with a >");
        return verbatim;
      }
      const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
      if (!suffix)
        onError(`The ${source} tag has no suffix`);
      const prefix = this.tags[handle];
      if (prefix) {
        try {
          return prefix + decodeURIComponent(suffix);
        } catch (error) {
          onError(String(error));
          return null;
        }
      }
      if (handle === "!")
        return source;
      onError(`Could not resolve tag: ${source}`);
      return null;
    }
    tagString(tag) {
      for (const [handle, prefix] of Object.entries(this.tags)) {
        if (tag.startsWith(prefix))
          return handle + escapeTagName(tag.substring(prefix.length));
      }
      return tag[0] === "!" ? tag : `!<${tag}>`;
    }
    toString(doc) {
      const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
      const tagEntries = Object.entries(this.tags);
      let tagNames;
      if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
        const tags = {};
        visit.visit(doc.contents, (_key, node) => {
          if (identity.isNode(node) && node.tag)
            tags[node.tag] = true;
        });
        tagNames = Object.keys(tags);
      } else
        tagNames = [];
      for (const [handle, prefix] of tagEntries) {
        if (handle === "!!" && prefix === "tag:yaml.org,2002:")
          continue;
        if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
          lines.push(`%TAG ${handle} ${prefix}`);
      }
      return lines.join(`
`);
    }
  }
  Directives.defaultYaml = { explicit: false, version: "1.2" };
  Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
  exports.Directives = Directives;
});

// node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS((exports) => {
  var identity = require_identity();
  var visit = require_visit();
  function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
      const sa = JSON.stringify(anchor);
      const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
      throw new Error(msg);
    }
    return true;
  }
  function anchorNames(root) {
    const anchors = new Set;
    visit.visit(root, {
      Value(_key, node) {
        if (node.anchor)
          anchors.add(node.anchor);
      }
    });
    return anchors;
  }
  function findNewAnchor(prefix, exclude) {
    for (let i = 1;; ++i) {
      const name = `${prefix}${i}`;
      if (!exclude.has(name))
        return name;
    }
  }
  function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map;
    let prevAnchors = null;
    return {
      onAnchor: (source) => {
        aliasObjects.push(source);
        prevAnchors ?? (prevAnchors = anchorNames(doc));
        const anchor = findNewAnchor(prefix, prevAnchors);
        prevAnchors.add(anchor);
        return anchor;
      },
      setAnchors: () => {
        for (const source of aliasObjects) {
          const ref = sourceObjects.get(source);
          if (typeof ref === "object" && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
            ref.node.anchor = ref.anchor;
          } else {
            const error = new Error("Failed to resolve repeated object (this should not happen)");
            error.source = source;
            throw error;
          }
        }
      },
      sourceObjects
    };
  }
  exports.anchorIsValid = anchorIsValid;
  exports.anchorNames = anchorNames;
  exports.createNodeAnchors = createNodeAnchors;
  exports.findNewAnchor = findNewAnchor;
});

// node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS((exports) => {
  function applyReviver(reviver, obj, key, val) {
    if (val && typeof val === "object") {
      if (Array.isArray(val)) {
        for (let i = 0, len = val.length;i < len; ++i) {
          const v0 = val[i];
          const v1 = applyReviver(reviver, val, String(i), v0);
          if (v1 === undefined)
            delete val[i];
          else if (v1 !== v0)
            val[i] = v1;
        }
      } else if (val instanceof Map) {
        for (const k of Array.from(val.keys())) {
          const v0 = val.get(k);
          const v1 = applyReviver(reviver, val, k, v0);
          if (v1 === undefined)
            val.delete(k);
          else if (v1 !== v0)
            val.set(k, v1);
        }
      } else if (val instanceof Set) {
        for (const v0 of Array.from(val)) {
          const v1 = applyReviver(reviver, val, v0, v0);
          if (v1 === undefined)
            val.delete(v0);
          else if (v1 !== v0) {
            val.delete(v0);
            val.add(v1);
          }
        }
      } else {
        for (const [k, v0] of Object.entries(val)) {
          const v1 = applyReviver(reviver, val, k, v0);
          if (v1 === undefined)
            delete val[k];
          else if (v1 !== v0)
            val[k] = v1;
        }
      }
    }
    return reviver.call(obj, key, val);
  }
  exports.applyReviver = applyReviver;
});

// node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS((exports) => {
  var identity = require_identity();
  function toJS(value, arg, ctx) {
    if (Array.isArray(value))
      return value.map((v, i) => toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === "function") {
      if (!ctx || !identity.hasAnchor(value))
        return value.toJSON(arg, ctx);
      const data = { aliasCount: 0, count: 1, res: undefined };
      ctx.anchors.set(value, data);
      ctx.onCreate = (res2) => {
        data.res = res2;
        delete ctx.onCreate;
      };
      const res = value.toJSON(arg, ctx);
      if (ctx.onCreate)
        ctx.onCreate(res);
      return res;
    }
    if (typeof value === "bigint" && !ctx?.keep)
      return Number(value);
    return value;
  }
  exports.toJS = toJS;
});

// node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS((exports) => {
  var applyReviver = require_applyReviver();
  var identity = require_identity();
  var toJS = require_toJS();

  class NodeBase {
    constructor(type) {
      Object.defineProperty(this, identity.NODE_TYPE, { value: type });
    }
    clone() {
      const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      if (!identity.isDocument(doc))
        throw new TypeError("A document argument is required");
      const ctx = {
        anchors: new Map,
        doc,
        keep: true,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS.toJS(this, "", ctx);
      if (typeof onAnchor === "function")
        for (const { count, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count);
      return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
    }
  }
  exports.NodeBase = NodeBase;
});

// node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS((exports) => {
  var anchors = require_anchors();
  var visit = require_visit();
  var identity = require_identity();
  var Node = require_Node();
  var toJS = require_toJS();

  class Alias extends Node.NodeBase {
    constructor(source) {
      super(identity.ALIAS);
      this.source = source;
      Object.defineProperty(this, "tag", {
        set() {
          throw new Error("Alias nodes cannot have tags");
        }
      });
    }
    resolve(doc, ctx) {
      let nodes;
      if (ctx?.aliasResolveCache) {
        nodes = ctx.aliasResolveCache;
      } else {
        nodes = [];
        visit.visit(doc, {
          Node: (_key, node) => {
            if (identity.isAlias(node) || identity.hasAnchor(node))
              nodes.push(node);
          }
        });
        if (ctx)
          ctx.aliasResolveCache = nodes;
      }
      let found = undefined;
      for (const node of nodes) {
        if (node === this)
          break;
        if (node.anchor === this.source)
          found = node;
      }
      return found;
    }
    toJSON(_arg, ctx) {
      if (!ctx)
        return { source: this.source };
      const { anchors: anchors2, doc, maxAliasCount } = ctx;
      const source = this.resolve(doc, ctx);
      if (!source) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new ReferenceError(msg);
      }
      let data = anchors2.get(source);
      if (!data) {
        toJS.toJS(source, null, ctx);
        data = anchors2.get(source);
      }
      if (!data || data.res === undefined) {
        const msg = "This should not happen: Alias anchor was not resolved?";
        throw new ReferenceError(msg);
      }
      if (maxAliasCount >= 0) {
        data.count += 1;
        if (data.aliasCount === 0)
          data.aliasCount = getAliasCount(doc, source, anchors2);
        if (data.count * data.aliasCount > maxAliasCount) {
          const msg = "Excessive alias count indicates a resource exhaustion attack";
          throw new ReferenceError(msg);
        }
      }
      return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
      const src = `*${this.source}`;
      if (ctx) {
        anchors.anchorIsValid(this.source);
        if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new Error(msg);
        }
        if (ctx.implicitKey)
          return `${src} `;
      }
      return src;
    }
  }
  function getAliasCount(doc, node, anchors2) {
    if (identity.isAlias(node)) {
      const source = node.resolve(doc);
      const anchor = anchors2 && source && anchors2.get(source);
      return anchor ? anchor.count * anchor.aliasCount : 0;
    } else if (identity.isCollection(node)) {
      let count = 0;
      for (const item of node.items) {
        const c = getAliasCount(doc, item, anchors2);
        if (c > count)
          count = c;
      }
      return count;
    } else if (identity.isPair(node)) {
      const kc = getAliasCount(doc, node.key, anchors2);
      const vc = getAliasCount(doc, node.value, anchors2);
      return Math.max(kc, vc);
    }
    return 1;
  }
  exports.Alias = Alias;
});

// node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS((exports) => {
  var identity = require_identity();
  var Node = require_Node();
  var toJS = require_toJS();
  var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";

  class Scalar extends Node.NodeBase {
    constructor(value) {
      super(identity.SCALAR);
      this.value = value;
    }
    toJSON(arg, ctx) {
      return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
    }
    toString() {
      return String(this.value);
    }
  }
  Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
  Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
  Scalar.PLAIN = "PLAIN";
  Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
  Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
  exports.Scalar = Scalar;
  exports.isScalarValue = isScalarValue;
});

// node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS((exports) => {
  var Alias = require_Alias();
  var identity = require_identity();
  var Scalar = require_Scalar();
  var defaultTagPrefix = "tag:yaml.org,2002:";
  function findTagObject(value, tagName, tags) {
    if (tagName) {
      const match = tags.filter((t) => t.tag === tagName);
      const tagObj = match.find((t) => !t.format) ?? match[0];
      if (!tagObj)
        throw new Error(`Tag ${tagName} not found`);
      return tagObj;
    }
    return tags.find((t) => t.identify?.(value) && !t.format);
  }
  function createNode(value, tagName, ctx) {
    if (identity.isDocument(value))
      value = value.contents;
    if (identity.isNode(value))
      return value;
    if (identity.isPair(value)) {
      const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
      map.items.push(value);
      return map;
    }
    if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
      value = value.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
    let ref = undefined;
    if (aliasDuplicateObjects && value && typeof value === "object") {
      ref = sourceObjects.get(value);
      if (ref) {
        ref.anchor ?? (ref.anchor = onAnchor(value));
        return new Alias.Alias(ref.anchor);
      } else {
        ref = { anchor: null, node: null };
        sourceObjects.set(value, ref);
      }
    }
    if (tagName?.startsWith("!!"))
      tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
      if (value && typeof value.toJSON === "function") {
        value = value.toJSON();
      }
      if (!value || typeof value !== "object") {
        const node2 = new Scalar.Scalar(value);
        if (ref)
          ref.node = node2;
        return node2;
      }
      tagObj = value instanceof Map ? schema[identity.MAP] : (Symbol.iterator in Object(value)) ? schema[identity.SEQ] : schema[identity.MAP];
    }
    if (onTagObj) {
      onTagObj(tagObj);
      delete ctx.onTagObj;
    }
    const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
    if (tagName)
      node.tag = tagName;
    else if (!tagObj.default)
      node.tag = tagObj.tag;
    if (ref)
      ref.node = node;
    return node;
  }
  exports.createNode = createNode;
});

// node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS((exports) => {
  var createNode = require_createNode();
  var identity = require_identity();
  var Node = require_Node();
  function collectionFromPath(schema, path, value) {
    let v = value;
    for (let i = path.length - 1;i >= 0; --i) {
      const k = path[i];
      if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
        const a = [];
        a[k] = v;
        v = a;
      } else {
        v = new Map([[k, v]]);
      }
    }
    return createNode.createNode(v, undefined, {
      aliasDuplicateObjects: false,
      keepUndefined: false,
      onAnchor: () => {
        throw new Error("This should not happen, please report a bug.");
      },
      schema,
      sourceObjects: new Map
    });
  }
  var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;

  class Collection extends Node.NodeBase {
    constructor(type, schema) {
      super(type);
      Object.defineProperty(this, "schema", {
        value: schema,
        configurable: true,
        enumerable: false,
        writable: true
      });
    }
    clone(schema) {
      const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (schema)
        copy.schema = schema;
      copy.items = copy.items.map((it) => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    addIn(path, value) {
      if (isEmptyPath(path))
        this.add(value);
      else {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (identity.isCollection(node))
          node.addIn(rest, value);
        else if (node === undefined && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
    deleteIn(path) {
      const [key, ...rest] = path;
      if (rest.length === 0)
        return this.delete(key);
      const node = this.get(key, true);
      if (identity.isCollection(node))
        return node.deleteIn(rest);
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    getIn(path, keepScalar) {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (rest.length === 0)
        return !keepScalar && identity.isScalar(node) ? node.value : node;
      else
        return identity.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
      return this.items.every((node) => {
        if (!identity.isPair(node))
          return false;
        const n = node.value;
        return n == null || allowScalar && identity.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
      });
    }
    hasIn(path) {
      const [key, ...rest] = path;
      if (rest.length === 0)
        return this.has(key);
      const node = this.get(key, true);
      return identity.isCollection(node) ? node.hasIn(rest) : false;
    }
    setIn(path, value) {
      const [key, ...rest] = path;
      if (rest.length === 0) {
        this.set(key, value);
      } else {
        const node = this.get(key, true);
        if (identity.isCollection(node))
          node.setIn(rest, value);
        else if (node === undefined && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
  }
  exports.Collection = Collection;
  exports.collectionFromPath = collectionFromPath;
  exports.isEmptyPath = isEmptyPath;
});

// node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS((exports) => {
  var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
  function indentComment(comment, indent) {
    if (/^\n+$/.test(comment))
      return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
  }
  var lineComment = (str, indent, comment) => str.endsWith(`
`) ? indentComment(comment, indent) : comment.includes(`
`) ? `
` + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
  exports.indentComment = indentComment;
  exports.lineComment = lineComment;
  exports.stringifyComment = stringifyComment;
});

// node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS((exports) => {
  var FOLD_FLOW = "flow";
  var FOLD_BLOCK = "block";
  var FOLD_QUOTED = "quoted";
  function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
      return text;
    if (lineWidth < minContentWidth)
      minContentWidth = 0;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
      return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === "number") {
      if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
        folds.push(0);
      else
        end = lineWidth - indentAtStart;
    }
    let split = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
      i = consumeMoreIndentedLines(text, i, indent.length);
      if (i !== -1)
        end = i + endStep;
    }
    for (let ch;ch = text[i += 1]; ) {
      if (mode === FOLD_QUOTED && ch === "\\") {
        escStart = i;
        switch (text[i + 1]) {
          case "x":
            i += 3;
            break;
          case "u":
            i += 5;
            break;
          case "U":
            i += 9;
            break;
          default:
            i += 1;
        }
        escEnd = i;
      }
      if (ch === `
`) {
        if (mode === FOLD_BLOCK)
          i = consumeMoreIndentedLines(text, i, indent.length);
        end = i + indent.length + endStep;
        split = undefined;
      } else {
        if (ch === " " && prev && prev !== " " && prev !== `
` && prev !== "\t") {
          const next = text[i + 1];
          if (next && next !== " " && next !== `
` && next !== "\t")
            split = i;
        }
        if (i >= end) {
          if (split) {
            folds.push(split);
            end = split + endStep;
            split = undefined;
          } else if (mode === FOLD_QUOTED) {
            while (prev === " " || prev === "\t") {
              prev = ch;
              ch = text[i += 1];
              overflow = true;
            }
            const j = i > escEnd + 1 ? i - 2 : escStart - 1;
            if (escapedFolds[j])
              return text;
            folds.push(j);
            escapedFolds[j] = true;
            end = j + endStep;
            split = undefined;
          } else {
            overflow = true;
          }
        }
      }
      prev = ch;
    }
    if (overflow && onOverflow)
      onOverflow();
    if (folds.length === 0)
      return text;
    if (onFold)
      onFold();
    let res = text.slice(0, folds[0]);
    for (let i2 = 0;i2 < folds.length; ++i2) {
      const fold = folds[i2];
      const end2 = folds[i2 + 1] || text.length;
      if (fold === 0)
        res = `
${indent}${text.slice(0, end2)}`;
      else {
        if (mode === FOLD_QUOTED && escapedFolds[fold])
          res += `${text[fold]}\\`;
        res += `
${indent}${text.slice(fold + 1, end2)}`;
      }
    }
    return res;
  }
  function consumeMoreIndentedLines(text, i, indent) {
    let end = i;
    let start = i + 1;
    let ch = text[start];
    while (ch === " " || ch === "\t") {
      if (i < start + indent) {
        ch = text[++i];
      } else {
        do {
          ch = text[++i];
        } while (ch && ch !== `
`);
        end = i;
        start = i + 1;
        ch = text[start];
      }
    }
    return end;
  }
  exports.FOLD_BLOCK = FOLD_BLOCK;
  exports.FOLD_FLOW = FOLD_FLOW;
  exports.FOLD_QUOTED = FOLD_QUOTED;
  exports.foldFlowLines = foldFlowLines;
});

// node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var foldFlowLines = require_foldFlowLines();
  var getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
  });
  var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
  function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
      return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
      return false;
    for (let i = 0, start = 0;i < strLen; ++i) {
      if (str[i] === `
`) {
        if (i - start > limit)
          return true;
        start = i + 1;
        if (strLen - start <= limit)
          return false;
      }
    }
    return true;
  }
  function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
      return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    let str = "";
    let start = 0;
    for (let i = 0, ch = json[i];ch; ch = json[++i]) {
      if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
        str += json.slice(start, i) + "\\ ";
        i += 1;
        start = i;
        ch = "\\";
      }
      if (ch === "\\")
        switch (json[i + 1]) {
          case "u":
            {
              str += json.slice(start, i);
              const code = json.substr(i + 2, 4);
              switch (code) {
                case "0000":
                  str += "\\0";
                  break;
                case "0007":
                  str += "\\a";
                  break;
                case "000b":
                  str += "\\v";
                  break;
                case "001b":
                  str += "\\e";
                  break;
                case "0085":
                  str += "\\N";
                  break;
                case "00a0":
                  str += "\\_";
                  break;
                case "2028":
                  str += "\\L";
                  break;
                case "2029":
                  str += "\\P";
                  break;
                default:
                  if (code.substr(0, 2) === "00")
                    str += "\\x" + code.substr(2);
                  else
                    str += json.substr(i, 6);
              }
              i += 5;
              start = i + 1;
            }
            break;
          case "n":
            if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
              i += 1;
            } else {
              str += json.slice(start, i) + `

`;
              while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                str += `
`;
                i += 2;
              }
              str += indent;
              if (json[i + 2] === " ")
                str += "\\";
              i += 1;
              start = i + 1;
            }
            break;
          default:
            i += 1;
        }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
  }
  function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes(`
`) || /[ \t]\n|\n[ \t]/.test(value))
      return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
    return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
      qs = doubleQuotedString;
    else {
      const hasDouble = value.includes('"');
      const hasSingle = value.includes("'");
      if (hasDouble && !hasSingle)
        qs = singleQuotedString;
      else if (hasSingle && !hasDouble)
        qs = doubleQuotedString;
      else
        qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
  }
  var blockEndNewlines;
  try {
    blockEndNewlines = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
  } catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
  }
  function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    if (!blockQuote || /\n[\t ]+$/.test(value)) {
      return quotedString(value, ctx);
    }
    const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
    const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
      return literal ? `|
` : `>
`;
    let chomp;
    let endStart;
    for (endStart = value.length;endStart > 0; --endStart) {
      const ch = value[endStart - 1];
      if (ch !== `
` && ch !== "\t" && ch !== " ")
        break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf(`
`);
    if (endNlPos === -1) {
      chomp = "-";
    } else if (value === end || endNlPos !== end.length - 1) {
      chomp = "+";
      if (onChompKeep)
        onChompKeep();
    } else {
      chomp = "";
    }
    if (end) {
      value = value.slice(0, -end.length);
      if (end[end.length - 1] === `
`)
        end = end.slice(0, -1);
      end = end.replace(blockEndNewlines, `$&${indent}`);
    }
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0;startEnd < value.length; ++startEnd) {
      const ch = value[startEnd];
      if (ch === " ")
        startWithSpace = true;
      else if (ch === `
`)
        startNlPos = startEnd;
      else
        break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
      value = value.substring(start.length);
      start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? "2" : "1";
    let header = (startWithSpace ? indentSize : "") + chomp;
    if (comment) {
      header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
      if (onComment)
        onComment();
    }
    if (!literal) {
      const foldedValue = value.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
      let literalFallback = false;
      const foldOptions = getFoldOptions(ctx, true);
      if (blockQuote !== "folded" && type !== Scalar.Scalar.BLOCK_FOLDED) {
        foldOptions.onOverflow = () => {
          literalFallback = true;
        };
      }
      const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent, foldFlowLines.FOLD_BLOCK, foldOptions);
      if (!literalFallback)
        return `>${header}
${indent}${body}`;
    }
    value = value.replace(/\n+/g, `$&${indent}`);
    return `|${header}
${indent}${start}${value}${end}`;
  }
  function plainString(item, ctx, onComment, onChompKeep) {
    const { type, value } = item;
    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
    if (implicitKey && value.includes(`
`) || inFlow && /[[\]{},]/.test(value)) {
      return quotedString(value, ctx);
    }
    if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
      return implicitKey || inFlow || !value.includes(`
`) ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes(`
`)) {
      return blockString(item, ctx, onComment, onChompKeep);
    }
    if (containsDocumentMarker(value)) {
      if (indent === "") {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      } else if (implicitKey && indent === indentStep) {
        return quotedString(value, ctx);
      }
    }
    const str = value.replace(/\n+/g, `$&
${indent}`);
    if (actualString) {
      const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
      const { compat, tags } = ctx.doc.schema;
      if (tags.some(test) || compat?.some(test))
        return quotedString(value, ctx);
    }
    return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
    let { type } = item;
    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
      if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
        type = Scalar.Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
      switch (_type) {
        case Scalar.Scalar.BLOCK_FOLDED:
        case Scalar.Scalar.BLOCK_LITERAL:
          return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
        case Scalar.Scalar.QUOTE_DOUBLE:
          return doubleQuotedString(ss.value, ctx);
        case Scalar.Scalar.QUOTE_SINGLE:
          return singleQuotedString(ss.value, ctx);
        case Scalar.Scalar.PLAIN:
          return plainString(ss, ctx, onComment, onChompKeep);
        default:
          return null;
      }
    };
    let res = _stringify(type);
    if (res === null) {
      const { defaultKeyType, defaultStringType } = ctx.options;
      const t = implicitKey && defaultKeyType || defaultStringType;
      res = _stringify(t);
      if (res === null)
        throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
  }
  exports.stringifyString = stringifyString;
});

// node_modules/yaml/dist/stringify/stringify.js
var require_stringify = __commonJS((exports) => {
  var anchors = require_anchors();
  var identity = require_identity();
  var stringifyComment = require_stringifyComment();
  var stringifyString = require_stringifyString();
  function createStringifyContext(doc, options) {
    const opt = Object.assign({
      blockQuote: true,
      commentString: stringifyComment.stringifyComment,
      defaultKeyType: null,
      defaultStringType: "PLAIN",
      directives: null,
      doubleQuotedAsJSON: false,
      doubleQuotedMinMultiLineLength: 40,
      falseStr: "false",
      flowCollectionPadding: true,
      indentSeq: true,
      lineWidth: 80,
      minContentWidth: 20,
      nullStr: "null",
      simpleKeys: false,
      singleQuote: null,
      trueStr: "true",
      verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
      case "block":
        inFlow = false;
        break;
      case "flow":
        inFlow = true;
        break;
      default:
        inFlow = null;
    }
    return {
      anchors: new Set,
      doc,
      flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
      indent: "",
      indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
      inFlow,
      options: opt
    };
  }
  function getTagObject(tags, item) {
    if (item.tag) {
      const match = tags.filter((t) => t.tag === item.tag);
      if (match.length > 0)
        return match.find((t) => t.format === item.format) ?? match[0];
    }
    let tagObj = undefined;
    let obj;
    if (identity.isScalar(item)) {
      obj = item.value;
      let match = tags.filter((t) => t.identify?.(obj));
      if (match.length > 1) {
        const testMatch = match.filter((t) => t.test);
        if (testMatch.length > 0)
          match = testMatch;
      }
      tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
    } else {
      obj = item;
      tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
      const name = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
      throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
  }
  function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
    if (!doc.directives)
      return "";
    const props = [];
    const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
    if (anchor && anchors.anchorIsValid(anchor)) {
      anchors$1.add(anchor);
      props.push(`&${anchor}`);
    }
    const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
    if (tag)
      props.push(doc.directives.tagString(tag));
    return props.join(" ");
  }
  function stringify(item, ctx, onComment, onChompKeep) {
    if (identity.isPair(item))
      return item.toString(ctx, onComment, onChompKeep);
    if (identity.isAlias(item)) {
      if (ctx.doc.directives)
        return item.toString(ctx);
      if (ctx.resolvedAliases?.has(item)) {
        throw new TypeError(`Cannot stringify circular structure without alias nodes`);
      } else {
        if (ctx.resolvedAliases)
          ctx.resolvedAliases.add(item);
        else
          ctx.resolvedAliases = new Set([item]);
        item = item.resolve(ctx.doc);
      }
    }
    let tagObj = undefined;
    const node = identity.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
    tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
      ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
    if (!props)
      return str;
    return identity.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
  }
  exports.createStringifyContext = createStringifyContext;
  exports.stringify = stringify;
});

// node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var stringify = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = identity.isNode(key) && key.comment || null;
    if (simpleKeys) {
      if (keyComment) {
        throw new Error("With simple keys, key nodes cannot have comments");
      }
      if (identity.isCollection(key) || !identity.isNode(key) && typeof key === "object") {
        const msg = "With simple keys, collection cannot be used as a key value";
        throw new Error(msg);
      }
    }
    let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
    ctx = Object.assign({}, ctx, {
      allNullValues: false,
      implicitKey: !explicitKey && (simpleKeys || !allNullValues),
      indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
      if (simpleKeys)
        throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
      explicitKey = true;
    }
    if (ctx.inFlow) {
      if (allNullValues || value == null) {
        if (keyCommentDone && onComment)
          onComment();
        return str === "" ? "?" : explicitKey ? `? ${str}` : str;
      }
    } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
      str = `? ${str}`;
      if (keyComment && !keyCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    if (keyCommentDone)
      keyComment = null;
    if (explicitKey) {
      if (keyComment)
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      str = `? ${str}
${indent}:`;
    } else {
      str = `${str}:`;
      if (keyComment)
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if (identity.isNode(value)) {
      vsb = !!value.spaceBefore;
      vcb = value.commentBefore;
      valueComment = value.comment;
    } else {
      vsb = false;
      vcb = null;
      valueComment = null;
      if (value && typeof value === "object")
        value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && identity.isScalar(value))
      ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
      ctx.indent = ctx.indent.substring(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
    let ws = " ";
    if (keyComment || vsb || vcb) {
      ws = vsb ? `
` : "";
      if (vcb) {
        const cs = commentString(vcb);
        ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
      }
      if (valueStr === "" && !ctx.inFlow) {
        if (ws === `
`)
          ws = `

`;
      } else {
        ws += `
${ctx.indent}`;
      }
    } else if (!explicitKey && identity.isCollection(value)) {
      const vs0 = valueStr[0];
      const nl0 = valueStr.indexOf(`
`);
      const hasNewline = nl0 !== -1;
      const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
      if (hasNewline || !flow) {
        let hasPropsLine = false;
        if (hasNewline && (vs0 === "&" || vs0 === "!")) {
          let sp0 = valueStr.indexOf(" ");
          if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
            sp0 = valueStr.indexOf(" ", sp0 + 1);
          }
          if (sp0 === -1 || nl0 < sp0)
            hasPropsLine = true;
        }
        if (!hasPropsLine)
          ws = `
${ctx.indent}`;
      }
    } else if (valueStr === "" || valueStr[0] === `
`) {
      ws = "";
    }
    str += ws + valueStr;
    if (ctx.inFlow) {
      if (valueCommentDone && onComment)
        onComment();
    } else if (valueComment && !valueCommentDone) {
      str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
    } else if (chompKeep && onChompKeep) {
      onChompKeep();
    }
    return str;
  }
  exports.stringifyPair = stringifyPair;
});

// node_modules/yaml/dist/log.js
var require_log = __commonJS((exports) => {
  var node_process = __require("process");
  function debug(logLevel, ...messages) {
    if (logLevel === "debug")
      console.log(...messages);
  }
  function warn(logLevel, warning) {
    if (logLevel === "debug" || logLevel === "warn") {
      if (typeof node_process.emitWarning === "function")
        node_process.emitWarning(warning);
      else
        console.warn(warning);
    }
  }
  exports.debug = debug;
  exports.warn = warn;
});

// node_modules/yaml/dist/schema/yaml-1.1/merge.js
var require_merge = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var MERGE_KEY = "<<";
  var merge = {
    identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
    default: "key",
    tag: "tag:yaml.org,2002:merge",
    test: /^<<$/,
    resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
      addToJSMap: addMergeToJSMap
    }),
    stringify: () => MERGE_KEY
  };
  var isMergeKey = (ctx, key) => (merge.identify(key) || identity.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge.tag && tag.default);
  function addMergeToJSMap(ctx, map, value) {
    value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (identity.isSeq(value))
      for (const it of value.items)
        mergeValue(ctx, map, it);
    else if (Array.isArray(value))
      for (const it of value)
        mergeValue(ctx, map, it);
    else
      mergeValue(ctx, map, value);
  }
  function mergeValue(ctx, map, value) {
    const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!identity.isMap(source))
      throw new Error("Merge sources must be maps or map aliases");
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value2] of srcMap) {
      if (map instanceof Map) {
        if (!map.has(key))
          map.set(key, value2);
      } else if (map instanceof Set) {
        map.add(key);
      } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
        Object.defineProperty(map, key, {
          value: value2,
          writable: true,
          enumerable: true,
          configurable: true
        });
      }
    }
    return map;
  }
  exports.addMergeToJSMap = addMergeToJSMap;
  exports.isMergeKey = isMergeKey;
  exports.merge = merge;
});

// node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS((exports) => {
  var log = require_log();
  var merge = require_merge();
  var stringify = require_stringify();
  var identity = require_identity();
  var toJS = require_toJS();
  function addPairToJSMap(ctx, map, { key, value }) {
    if (identity.isNode(key) && key.addToJSMap)
      key.addToJSMap(ctx, map, value);
    else if (merge.isMergeKey(ctx, key))
      merge.addMergeToJSMap(ctx, map, value);
    else {
      const jsKey = toJS.toJS(key, "", ctx);
      if (map instanceof Map) {
        map.set(jsKey, toJS.toJS(value, jsKey, ctx));
      } else if (map instanceof Set) {
        map.add(jsKey);
      } else {
        const stringKey = stringifyKey(key, jsKey, ctx);
        const jsValue = toJS.toJS(value, stringKey, ctx);
        if (stringKey in map)
          Object.defineProperty(map, stringKey, {
            value: jsValue,
            writable: true,
            enumerable: true,
            configurable: true
          });
        else
          map[stringKey] = jsValue;
      }
    }
    return map;
  }
  function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
      return "";
    if (typeof jsKey !== "object")
      return String(jsKey);
    if (identity.isNode(key) && ctx?.doc) {
      const strCtx = stringify.createStringifyContext(ctx.doc, {});
      strCtx.anchors = new Set;
      for (const node of ctx.anchors.keys())
        strCtx.anchors.add(node.anchor);
      strCtx.inFlow = true;
      strCtx.inStringifyKey = true;
      const strKey = key.toString(strCtx);
      if (!ctx.mapKeyWarned) {
        let jsonStr = JSON.stringify(strKey);
        if (jsonStr.length > 40)
          jsonStr = jsonStr.substring(0, 36) + '..."';
        log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
        ctx.mapKeyWarned = true;
      }
      return strKey;
    }
    return JSON.stringify(jsKey);
  }
  exports.addPairToJSMap = addPairToJSMap;
});

// node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS((exports) => {
  var createNode = require_createNode();
  var stringifyPair = require_stringifyPair();
  var addPairToJSMap = require_addPairToJSMap();
  var identity = require_identity();
  function createPair(key, value, ctx) {
    const k = createNode.createNode(key, undefined, ctx);
    const v = createNode.createNode(value, undefined, ctx);
    return new Pair(k, v);
  }

  class Pair {
    constructor(key, value = null) {
      Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
      this.key = key;
      this.value = value;
    }
    clone(schema) {
      let { key, value } = this;
      if (identity.isNode(key))
        key = key.clone(schema);
      if (identity.isNode(value))
        value = value.clone(schema);
      return new Pair(key, value);
    }
    toJSON(_, ctx) {
      const pair = ctx?.mapAsMap ? new Map : {};
      return addPairToJSMap.addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
      return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
    }
  }
  exports.Pair = Pair;
  exports.createPair = createPair;
});

// node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS((exports) => {
  var identity = require_identity();
  var stringify = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify2(collection, ctx, options);
  }
  function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false;
    const lines = [];
    for (let i = 0;i < items.length; ++i) {
      const item = items[i];
      let comment2 = null;
      if (identity.isNode(item)) {
        if (!chompKeep && item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
        if (item.comment)
          comment2 = item.comment;
      } else if (identity.isPair(item)) {
        const ik = identity.isNode(item.key) ? item.key : null;
        if (ik) {
          if (!chompKeep && ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
        }
      }
      chompKeep = false;
      let str2 = stringify.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
      if (comment2)
        str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
      if (chompKeep && comment2)
        chompKeep = false;
      lines.push(blockItemPrefix + str2);
    }
    let str;
    if (lines.length === 0) {
      str = flowChars.start + flowChars.end;
    } else {
      str = lines[0];
      for (let i = 1;i < lines.length; ++i) {
        const line = lines[i];
        str += line ? `
${indent}${line}` : `
`;
      }
    }
    if (comment) {
      str += `
` + stringifyComment.indentComment(commentString(comment), indent);
      if (onComment)
        onComment();
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
      indent: itemIndent,
      inFlow: true,
      type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0;i < items.length; ++i) {
      const item = items[i];
      let comment = null;
      if (identity.isNode(item)) {
        if (item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, false);
        if (item.comment)
          comment = item.comment;
      } else if (identity.isPair(item)) {
        const ik = identity.isNode(item.key) ? item.key : null;
        if (ik) {
          if (ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, false);
          if (ik.comment)
            reqNewline = true;
        }
        const iv = identity.isNode(item.value) ? item.value : null;
        if (iv) {
          if (iv.comment)
            comment = iv.comment;
          if (iv.commentBefore)
            reqNewline = true;
        } else if (item.value == null && ik?.comment) {
          comment = ik.comment;
        }
      }
      if (comment)
        reqNewline = true;
      let str = stringify.stringify(item, itemCtx, () => comment = null);
      if (i < items.length - 1)
        str += ",";
      if (comment)
        str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
      if (!reqNewline && (lines.length > linesAtValue || str.includes(`
`)))
        reqNewline = true;
      lines.push(str);
      linesAtValue = lines.length;
    }
    const { start, end } = flowChars;
    if (lines.length === 0) {
      return start + end;
    } else {
      if (!reqNewline) {
        const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
        reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
      }
      if (reqNewline) {
        let str = start;
        for (const line of lines)
          str += line ? `
${indentStep}${indent}${line}` : `
`;
        return `${str}
${indent}${end}`;
      } else {
        return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
      }
    }
  }
  function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
      comment = comment.replace(/^\n+/, "");
    if (comment) {
      const ic = stringifyComment.indentComment(commentString(comment), indent);
      lines.push(ic.trimStart());
    }
  }
  exports.stringifyCollection = stringifyCollection;
});

// node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS((exports) => {
  var stringifyCollection = require_stringifyCollection();
  var addPairToJSMap = require_addPairToJSMap();
  var Collection = require_Collection();
  var identity = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();
  function findPair(items, key) {
    const k = identity.isScalar(key) ? key.value : key;
    for (const it of items) {
      if (identity.isPair(it)) {
        if (it.key === key || it.key === k)
          return it;
        if (identity.isScalar(it.key) && it.key.value === k)
          return it;
      }
    }
    return;
  }

  class YAMLMap extends Collection.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:map";
    }
    constructor(schema) {
      super(identity.MAP, schema);
      this.items = [];
    }
    static from(schema, obj, ctx) {
      const { keepUndefined, replacer } = ctx;
      const map = new this(schema);
      const add = (key, value) => {
        if (typeof replacer === "function")
          value = replacer.call(obj, key, value);
        else if (Array.isArray(replacer) && !replacer.includes(key))
          return;
        if (value !== undefined || keepUndefined)
          map.items.push(Pair.createPair(key, value, ctx));
      };
      if (obj instanceof Map) {
        for (const [key, value] of obj)
          add(key, value);
      } else if (obj && typeof obj === "object") {
        for (const key of Object.keys(obj))
          add(key, obj[key]);
      }
      if (typeof schema.sortMapEntries === "function") {
        map.items.sort(schema.sortMapEntries);
      }
      return map;
    }
    add(pair, overwrite) {
      let _pair;
      if (identity.isPair(pair))
        _pair = pair;
      else if (!pair || typeof pair !== "object" || !("key" in pair)) {
        _pair = new Pair.Pair(pair, pair?.value);
      } else
        _pair = new Pair.Pair(pair.key, pair.value);
      const prev = findPair(this.items, _pair.key);
      const sortEntries = this.schema?.sortMapEntries;
      if (prev) {
        if (!overwrite)
          throw new Error(`Key ${_pair.key} already set`);
        if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
          prev.value.value = _pair.value;
        else
          prev.value = _pair.value;
      } else if (sortEntries) {
        const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
        if (i === -1)
          this.items.push(_pair);
        else
          this.items.splice(i, 0, _pair);
      } else {
        this.items.push(_pair);
      }
    }
    delete(key) {
      const it = findPair(this.items, key);
      if (!it)
        return false;
      const del = this.items.splice(this.items.indexOf(it), 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const it = findPair(this.items, key);
      const node = it?.value;
      return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? undefined;
    }
    has(key) {
      return !!findPair(this.items, key);
    }
    set(key, value) {
      this.add(new Pair.Pair(key, value), true);
    }
    toJSON(_, ctx, Type) {
      const map = Type ? new Type : ctx?.mapAsMap ? new Map : {};
      if (ctx?.onCreate)
        ctx.onCreate(map);
      for (const item of this.items)
        addPairToJSMap.addPairToJSMap(ctx, map, item);
      return map;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      for (const item of this.items) {
        if (!identity.isPair(item))
          throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
      }
      if (!ctx.allNullValues && this.hasAllNullValues(false))
        ctx = Object.assign({}, ctx, { allNullValues: true });
      return stringifyCollection.stringifyCollection(this, ctx, {
        blockItemPrefix: "",
        flowChars: { start: "{", end: "}" },
        itemIndent: ctx.indent || "",
        onChompKeep,
        onComment
      });
    }
  }
  exports.YAMLMap = YAMLMap;
  exports.findPair = findPair;
});

// node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS((exports) => {
  var identity = require_identity();
  var YAMLMap = require_YAMLMap();
  var map = {
    collection: "map",
    default: true,
    nodeClass: YAMLMap.YAMLMap,
    tag: "tag:yaml.org,2002:map",
    resolve(map2, onError) {
      if (!identity.isMap(map2))
        onError("Expected a mapping for this tag");
      return map2;
    },
    createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
  };
  exports.map = map;
});

// node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS((exports) => {
  var createNode = require_createNode();
  var stringifyCollection = require_stringifyCollection();
  var Collection = require_Collection();
  var identity = require_identity();
  var Scalar = require_Scalar();
  var toJS = require_toJS();

  class YAMLSeq extends Collection.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:seq";
    }
    constructor(schema) {
      super(identity.SEQ, schema);
      this.items = [];
    }
    add(value) {
      this.items.push(value);
    }
    delete(key) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        return false;
      const del = this.items.splice(idx, 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        return;
      const it = this.items[idx];
      return !keepScalar && identity.isScalar(it) ? it.value : it;
    }
    has(key) {
      const idx = asItemIndex(key);
      return typeof idx === "number" && idx < this.items.length;
    }
    set(key, value) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        throw new Error(`Expected a valid index, not ${key}.`);
      const prev = this.items[idx];
      if (identity.isScalar(prev) && Scalar.isScalarValue(value))
        prev.value = value;
      else
        this.items[idx] = value;
    }
    toJSON(_, ctx) {
      const seq = [];
      if (ctx?.onCreate)
        ctx.onCreate(seq);
      let i = 0;
      for (const item of this.items)
        seq.push(toJS.toJS(item, String(i++), ctx));
      return seq;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      return stringifyCollection.stringifyCollection(this, ctx, {
        blockItemPrefix: "- ",
        flowChars: { start: "[", end: "]" },
        itemIndent: (ctx.indent || "") + "  ",
        onChompKeep,
        onComment
      });
    }
    static from(schema, obj, ctx) {
      const { replacer } = ctx;
      const seq = new this(schema);
      if (obj && Symbol.iterator in Object(obj)) {
        let i = 0;
        for (let it of obj) {
          if (typeof replacer === "function") {
            const key = obj instanceof Set ? it : String(i++);
            it = replacer.call(obj, key, it);
          }
          seq.items.push(createNode.createNode(it, undefined, ctx));
        }
      }
      return seq;
    }
  }
  function asItemIndex(key) {
    let idx = identity.isScalar(key) ? key.value : key;
    if (idx && typeof idx === "string")
      idx = Number(idx);
    return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
  }
  exports.YAMLSeq = YAMLSeq;
});

// node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS((exports) => {
  var identity = require_identity();
  var YAMLSeq = require_YAMLSeq();
  var seq = {
    collection: "seq",
    default: true,
    nodeClass: YAMLSeq.YAMLSeq,
    tag: "tag:yaml.org,2002:seq",
    resolve(seq2, onError) {
      if (!identity.isSeq(seq2))
        onError("Expected a sequence for this tag");
      return seq2;
    },
    createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
  };
  exports.seq = seq;
});

// node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS((exports) => {
  var stringifyString = require_stringifyString();
  var string = {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify(item, ctx, onComment, onChompKeep) {
      ctx = Object.assign({ actualString: true }, ctx);
      return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
    }
  };
  exports.string = string;
});

// node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var nullTag = {
    identify: (value) => value == null,
    createNode: () => new Scalar.Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar.Scalar(null),
    stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
  };
  exports.nullTag = nullTag;
});

// node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var boolTag = {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
    stringify({ source, value }, ctx) {
      if (source && boolTag.test.test(source)) {
        const sv = source[0] === "t" || source[0] === "T";
        if (value === sv)
          return source;
      }
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
  };
  exports.boolTag = boolTag;
});

// node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS((exports) => {
  function stringifyNumber({ format, minFractionDigits, tag, value }) {
    if (typeof value === "bigint")
      return String(value);
    const num = typeof value === "number" ? value : Number(value);
    if (!isFinite(num))
      return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
    let n = JSON.stringify(value);
    if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
      let i = n.indexOf(".");
      if (i < 0) {
        i = n.length;
        n += ".";
      }
      let d = minFractionDigits - (n.length - i - 1);
      while (d-- > 0)
        n += "0";
    }
    return n;
  }
  exports.stringifyNumber = stringifyNumber;
});

// node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var stringifyNumber = require_stringifyNumber();
  var floatNaN = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
  };
  var floatExp = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
  };
  var float = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
      const node = new Scalar.Scalar(parseFloat(str));
      const dot = str.indexOf(".");
      if (dot !== -1 && str[str.length - 1] === "0")
        node.minFractionDigits = str.length - dot - 1;
      return node;
    },
    stringify: stringifyNumber.stringifyNumber
  };
  exports.float = float;
  exports.floatExp = floatExp;
  exports.floatNaN = floatNaN;
});

// node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
  var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
  function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value) && value >= 0)
      return prefix + value.toString(radix);
    return stringifyNumber.stringifyNumber(node);
  }
  var intOct = {
    identify: (value) => intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
    stringify: (node) => intStringify(node, 8, "0o")
  };
  var int = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
  };
  var intHex = {
    identify: (value) => intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: (node) => intStringify(node, 16, "0x")
  };
  exports.int = int;
  exports.intHex = intHex;
  exports.intOct = intOct;
});

// node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS((exports) => {
  var map = require_map();
  var _null = require_null();
  var seq = require_seq();
  var string = require_string();
  var bool = require_bool();
  var float = require_float();
  var int = require_int();
  var schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.boolTag,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float
  ];
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var map = require_map();
  var seq = require_seq();
  function intIdentify(value) {
    return typeof value === "bigint" || Number.isInteger(value);
  }
  var stringifyJSON = ({ value }) => JSON.stringify(value);
  var jsonScalars = [
    {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify: stringifyJSON
    },
    {
      identify: (value) => value == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: () => null,
      stringify: stringifyJSON
    },
    {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true$|^false$/,
      resolve: (str) => str === "true",
      stringify: stringifyJSON
    },
    {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
      stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
    },
    {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: (str) => parseFloat(str),
      stringify: stringifyJSON
    }
  ];
  var jsonError = {
    default: true,
    tag: "",
    test: /^/,
    resolve(str, onError) {
      onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
      return str;
    }
  };
  var schema = [map.map, seq.seq].concat(jsonScalars, jsonError);
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS((exports) => {
  var node_buffer = __require("buffer");
  var Scalar = require_Scalar();
  var stringifyString = require_stringifyString();
  var binary = {
    identify: (value) => value instanceof Uint8Array,
    default: false,
    tag: "tag:yaml.org,2002:binary",
    resolve(src, onError) {
      if (typeof node_buffer.Buffer === "function") {
        return node_buffer.Buffer.from(src, "base64");
      } else if (typeof atob === "function") {
        const str = atob(src.replace(/[\n\r]/g, ""));
        const buffer = new Uint8Array(str.length);
        for (let i = 0;i < str.length; ++i)
          buffer[i] = str.charCodeAt(i);
        return buffer;
      } else {
        onError("This environment does not support reading binary tags; either Buffer or atob is required");
        return src;
      }
    },
    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
      if (!value)
        return "";
      const buf = value;
      let str;
      if (typeof node_buffer.Buffer === "function") {
        str = buf instanceof node_buffer.Buffer ? buf.toString("base64") : node_buffer.Buffer.from(buf.buffer).toString("base64");
      } else if (typeof btoa === "function") {
        let s = "";
        for (let i = 0;i < buf.length; ++i)
          s += String.fromCharCode(buf[i]);
        str = btoa(s);
      } else {
        throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
      }
      type ?? (type = Scalar.Scalar.BLOCK_LITERAL);
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
        const n = Math.ceil(str.length / lineWidth);
        const lines = new Array(n);
        for (let i = 0, o = 0;i < n; ++i, o += lineWidth) {
          lines[i] = str.substr(o, lineWidth);
        }
        str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? `
` : " ");
      }
      return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
    }
  };
  exports.binary = binary;
});

// node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS((exports) => {
  var identity = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();
  var YAMLSeq = require_YAMLSeq();
  function resolvePairs(seq, onError) {
    if (identity.isSeq(seq)) {
      for (let i = 0;i < seq.items.length; ++i) {
        let item = seq.items[i];
        if (identity.isPair(item))
          continue;
        else if (identity.isMap(item)) {
          if (item.items.length > 1)
            onError("Each pair must have its own sequence indicator");
          const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
          if (item.commentBefore)
            pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
          if (item.comment) {
            const cn = pair.value ?? pair.key;
            cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
          }
          item = pair;
        }
        seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
      }
    } else
      onError("Expected a sequence for this tag");
    return seq;
  }
  function createPairs(schema, iterable, ctx) {
    const { replacer } = ctx;
    const pairs2 = new YAMLSeq.YAMLSeq(schema);
    pairs2.tag = "tag:yaml.org,2002:pairs";
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
      for (let it of iterable) {
        if (typeof replacer === "function")
          it = replacer.call(iterable, String(i++), it);
        let key, value;
        if (Array.isArray(it)) {
          if (it.length === 2) {
            key = it[0];
            value = it[1];
          } else
            throw new TypeError(`Expected [key, value] tuple: ${it}`);
        } else if (it && it instanceof Object) {
          const keys = Object.keys(it);
          if (keys.length === 1) {
            key = keys[0];
            value = it[key];
          } else {
            throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
          }
        } else {
          key = it;
        }
        pairs2.items.push(Pair.createPair(key, value, ctx));
      }
    return pairs2;
  }
  var pairs = {
    collection: "seq",
    default: false,
    tag: "tag:yaml.org,2002:pairs",
    resolve: resolvePairs,
    createNode: createPairs
  };
  exports.createPairs = createPairs;
  exports.pairs = pairs;
  exports.resolvePairs = resolvePairs;
});

// node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS((exports) => {
  var identity = require_identity();
  var toJS = require_toJS();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var pairs = require_pairs();

  class YAMLOMap extends YAMLSeq.YAMLSeq {
    constructor() {
      super();
      this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
      this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
      this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
      this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
      this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
      this.tag = YAMLOMap.tag;
    }
    toJSON(_, ctx) {
      if (!ctx)
        return super.toJSON(_);
      const map = new Map;
      if (ctx?.onCreate)
        ctx.onCreate(map);
      for (const pair of this.items) {
        let key, value;
        if (identity.isPair(pair)) {
          key = toJS.toJS(pair.key, "", ctx);
          value = toJS.toJS(pair.value, key, ctx);
        } else {
          key = toJS.toJS(pair, "", ctx);
        }
        if (map.has(key))
          throw new Error("Ordered maps must not include duplicate keys");
        map.set(key, value);
      }
      return map;
    }
    static from(schema, iterable, ctx) {
      const pairs$1 = pairs.createPairs(schema, iterable, ctx);
      const omap2 = new this;
      omap2.items = pairs$1.items;
      return omap2;
    }
  }
  YAMLOMap.tag = "tag:yaml.org,2002:omap";
  var omap = {
    collection: "seq",
    identify: (value) => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: "tag:yaml.org,2002:omap",
    resolve(seq, onError) {
      const pairs$1 = pairs.resolvePairs(seq, onError);
      const seenKeys = [];
      for (const { key } of pairs$1.items) {
        if (identity.isScalar(key)) {
          if (seenKeys.includes(key.value)) {
            onError(`Ordered maps must not include duplicate keys: ${key.value}`);
          } else {
            seenKeys.push(key.value);
          }
        }
      }
      return Object.assign(new YAMLOMap, pairs$1);
    },
    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
  };
  exports.YAMLOMap = YAMLOMap;
  exports.omap = omap;
});

// node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
      return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
  var trueTag = {
    identify: (value) => value === true,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar.Scalar(true),
    stringify: boolStringify
  };
  var falseTag = {
    identify: (value) => value === false,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
    resolve: () => new Scalar.Scalar(false),
    stringify: boolStringify
  };
  exports.falseTag = falseTag;
  exports.trueTag = trueTag;
});

// node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var stringifyNumber = require_stringifyNumber();
  var floatNaN = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
  };
  var floatExp = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, "")),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
  };
  var float = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
      const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
      const dot = str.indexOf(".");
      if (dot !== -1) {
        const f = str.substring(dot + 1).replace(/_/g, "");
        if (f[f.length - 1] === "0")
          node.minFractionDigits = f.length;
      }
      return node;
    },
    stringify: stringifyNumber.stringifyNumber
  };
  exports.float = float;
  exports.floatExp = floatExp;
  exports.floatNaN = floatNaN;
});

// node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
  function intResolve(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === "-" || sign === "+")
      offset += 1;
    str = str.substring(offset).replace(/_/g, "");
    if (intAsBigInt) {
      switch (radix) {
        case 2:
          str = `0b${str}`;
          break;
        case 8:
          str = `0o${str}`;
          break;
        case 16:
          str = `0x${str}`;
          break;
      }
      const n2 = BigInt(str);
      return sign === "-" ? BigInt(-1) * n2 : n2;
    }
    const n = parseInt(str, radix);
    return sign === "-" ? -1 * n : n;
  }
  function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value)) {
      const str = value.toString(radix);
      return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber.stringifyNumber(node);
  }
  var intBin = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "BIN",
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: (node) => intStringify(node, 2, "0b")
  };
  var intOct = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: (node) => intStringify(node, 8, "0")
  };
  var int = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
  };
  var intHex = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: (node) => intStringify(node, 16, "0x")
  };
  exports.int = int;
  exports.intBin = intBin;
  exports.intHex = intHex;
  exports.intOct = intOct;
});

// node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS((exports) => {
  var identity = require_identity();
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();

  class YAMLSet extends YAMLMap.YAMLMap {
    constructor(schema) {
      super(schema);
      this.tag = YAMLSet.tag;
    }
    add(key) {
      let pair;
      if (identity.isPair(key))
        pair = key;
      else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
        pair = new Pair.Pair(key.key, null);
      else
        pair = new Pair.Pair(key, null);
      const prev = YAMLMap.findPair(this.items, pair.key);
      if (!prev)
        this.items.push(pair);
    }
    get(key, keepPair) {
      const pair = YAMLMap.findPair(this.items, key);
      return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
    }
    set(key, value) {
      if (typeof value !== "boolean")
        throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
      const prev = YAMLMap.findPair(this.items, key);
      if (prev && !value) {
        this.items.splice(this.items.indexOf(prev), 1);
      } else if (!prev && value) {
        this.items.push(new Pair.Pair(key));
      }
    }
    toJSON(_, ctx) {
      return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      if (this.hasAllNullValues(true))
        return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
      else
        throw new Error("Set items must all have null values");
    }
    static from(schema, iterable, ctx) {
      const { replacer } = ctx;
      const set2 = new this(schema);
      if (iterable && Symbol.iterator in Object(iterable))
        for (let value of iterable) {
          if (typeof replacer === "function")
            value = replacer.call(iterable, value, value);
          set2.items.push(Pair.createPair(value, null, ctx));
        }
      return set2;
    }
  }
  YAMLSet.tag = "tag:yaml.org,2002:set";
  var set = {
    collection: "map",
    identify: (value) => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: "tag:yaml.org,2002:set",
    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
    resolve(map, onError) {
      if (identity.isMap(map)) {
        if (map.hasAllNullValues(true))
          return Object.assign(new YAMLSet, map);
        else
          onError("Set items must all have null values");
      } else
        onError("Expected a mapping for this tag");
      return map;
    }
  };
  exports.YAMLSet = YAMLSet;
  exports.set = set;
});

// node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  function parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
    return sign === "-" ? num(-1) * res : res;
  }
  function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === "bigint")
      num = (n) => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
      return stringifyNumber.stringifyNumber(node);
    let sign = "";
    if (value < 0) {
      sign = "-";
      value *= num(-1);
    }
    const _60 = num(60);
    const parts = [value % _60];
    if (value < 60) {
      parts.unshift(0);
    } else {
      value = (value - parts[0]) / _60;
      parts.unshift(value % _60);
      if (value >= 60) {
        value = (value - parts[0]) / _60;
        parts.unshift(value);
      }
    }
    return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
  }
  var intTime = {
    identify: (value) => typeof value === "bigint" || Number.isInteger(value),
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
  };
  var floatTime = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: (str) => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
  };
  var timestamp = {
    identify: (value) => value instanceof Date,
    default: true,
    tag: "tag:yaml.org,2002:timestamp",
    test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})" + "(?:" + "(?:t|T|[ \\t]+)" + "([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)" + "(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?" + ")?$"),
    resolve(str) {
      const match = str.match(timestamp.test);
      if (!match)
        throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
      const [, year, month, day, hour, minute, second] = match.map(Number);
      const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
      let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
      const tz = match[8];
      if (tz && tz !== "Z") {
        let d = parseSexagesimal(tz, false);
        if (Math.abs(d) < 30)
          d *= 60;
        date -= 60000 * d;
      }
      return new Date(date);
    },
    stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
  };
  exports.floatTime = floatTime;
  exports.intTime = intTime;
  exports.timestamp = timestamp;
});

// node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS((exports) => {
  var map = require_map();
  var _null = require_null();
  var seq = require_seq();
  var string = require_string();
  var binary = require_binary();
  var bool = require_bool2();
  var float = require_float2();
  var int = require_int2();
  var merge = require_merge();
  var omap = require_omap();
  var pairs = require_pairs();
  var set = require_set();
  var timestamp = require_timestamp();
  var schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.trueTag,
    bool.falseTag,
    int.intBin,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float,
    binary.binary,
    merge.merge,
    omap.omap,
    pairs.pairs,
    set.set,
    timestamp.intTime,
    timestamp.floatTime,
    timestamp.timestamp
  ];
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS((exports) => {
  var map = require_map();
  var _null = require_null();
  var seq = require_seq();
  var string = require_string();
  var bool = require_bool();
  var float = require_float();
  var int = require_int();
  var schema = require_schema();
  var schema$1 = require_schema2();
  var binary = require_binary();
  var merge = require_merge();
  var omap = require_omap();
  var pairs = require_pairs();
  var schema$2 = require_schema3();
  var set = require_set();
  var timestamp = require_timestamp();
  var schemas = new Map([
    ["core", schema.schema],
    ["failsafe", [map.map, seq.seq, string.string]],
    ["json", schema$1.schema],
    ["yaml11", schema$2.schema],
    ["yaml-1.1", schema$2.schema]
  ]);
  var tagsByName = {
    binary: binary.binary,
    bool: bool.boolTag,
    float: float.float,
    floatExp: float.floatExp,
    floatNaN: float.floatNaN,
    floatTime: timestamp.floatTime,
    int: int.int,
    intHex: int.intHex,
    intOct: int.intOct,
    intTime: timestamp.intTime,
    map: map.map,
    merge: merge.merge,
    null: _null.nullTag,
    omap: omap.omap,
    pairs: pairs.pairs,
    seq: seq.seq,
    set: set.set,
    timestamp: timestamp.timestamp
  };
  var coreKnownTags = {
    "tag:yaml.org,2002:binary": binary.binary,
    "tag:yaml.org,2002:merge": merge.merge,
    "tag:yaml.org,2002:omap": omap.omap,
    "tag:yaml.org,2002:pairs": pairs.pairs,
    "tag:yaml.org,2002:set": set.set,
    "tag:yaml.org,2002:timestamp": timestamp.timestamp
  };
  function getTags(customTags, schemaName, addMergeTag) {
    const schemaTags = schemas.get(schemaName);
    if (schemaTags && !customTags) {
      return addMergeTag && !schemaTags.includes(merge.merge) ? schemaTags.concat(merge.merge) : schemaTags.slice();
    }
    let tags = schemaTags;
    if (!tags) {
      if (Array.isArray(customTags))
        tags = [];
      else {
        const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
      }
    }
    if (Array.isArray(customTags)) {
      for (const tag of customTags)
        tags = tags.concat(tag);
    } else if (typeof customTags === "function") {
      tags = customTags(tags.slice());
    }
    if (addMergeTag)
      tags = tags.concat(merge.merge);
    return tags.reduce((tags2, tag) => {
      const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
      if (!tagObj) {
        const tagName = JSON.stringify(tag);
        const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
      }
      if (!tags2.includes(tagObj))
        tags2.push(tagObj);
      return tags2;
    }, []);
  }
  exports.coreKnownTags = coreKnownTags;
  exports.getTags = getTags;
});

// node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS((exports) => {
  var identity = require_identity();
  var map = require_map();
  var seq = require_seq();
  var string = require_string();
  var tags = require_tags();
  var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;

  class Schema {
    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
      this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
      this.name = typeof schema === "string" && schema || "core";
      this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
      this.tags = tags.getTags(customTags, this.name, merge);
      this.toStringOptions = toStringDefaults ?? null;
      Object.defineProperty(this, identity.MAP, { value: map.map });
      Object.defineProperty(this, identity.SCALAR, { value: string.string });
      Object.defineProperty(this, identity.SEQ, { value: seq.seq });
      this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
    }
    clone() {
      const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
      copy.tags = this.tags.slice();
      return copy;
    }
  }
  exports.Schema = Schema;
});

// node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS((exports) => {
  var identity = require_identity();
  var stringify = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
      const dir = doc.directives.toString(doc);
      if (dir) {
        lines.push(dir);
        hasDirectives = true;
      } else if (doc.directives.docStart)
        hasDirectives = true;
    }
    if (hasDirectives)
      lines.push("---");
    const ctx = stringify.createStringifyContext(doc, options);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
      if (lines.length !== 1)
        lines.unshift("");
      const cs = commentString(doc.commentBefore);
      lines.unshift(stringifyComment.indentComment(cs, ""));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
      if (identity.isNode(doc.contents)) {
        if (doc.contents.spaceBefore && hasDirectives)
          lines.push("");
        if (doc.contents.commentBefore) {
          const cs = commentString(doc.contents.commentBefore);
          lines.push(stringifyComment.indentComment(cs, ""));
        }
        ctx.forceBlockIndent = !!doc.comment;
        contentComment = doc.contents.comment;
      }
      const onChompKeep = contentComment ? undefined : () => chompKeep = true;
      let body = stringify.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
      if (contentComment)
        body += stringifyComment.lineComment(body, "", commentString(contentComment));
      if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
        lines[lines.length - 1] = `--- ${body}`;
      } else
        lines.push(body);
    } else {
      lines.push(stringify.stringify(doc.contents, ctx));
    }
    if (doc.directives?.docEnd) {
      if (doc.comment) {
        const cs = commentString(doc.comment);
        if (cs.includes(`
`)) {
          lines.push("...");
          lines.push(stringifyComment.indentComment(cs, ""));
        } else {
          lines.push(`... ${cs}`);
        }
      } else {
        lines.push("...");
      }
    } else {
      let dc = doc.comment;
      if (dc && chompKeep)
        dc = dc.replace(/^\n+/, "");
      if (dc) {
        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
          lines.push("");
        lines.push(stringifyComment.indentComment(commentString(dc), ""));
      }
    }
    return lines.join(`
`) + `
`;
  }
  exports.stringifyDocument = stringifyDocument;
});

// node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS((exports) => {
  var Alias = require_Alias();
  var Collection = require_Collection();
  var identity = require_identity();
  var Pair = require_Pair();
  var toJS = require_toJS();
  var Schema = require_Schema();
  var stringifyDocument = require_stringifyDocument();
  var anchors = require_anchors();
  var applyReviver = require_applyReviver();
  var createNode = require_createNode();
  var directives = require_directives();

  class Document {
    constructor(value, replacer, options) {
      this.commentBefore = null;
      this.comment = null;
      this.errors = [];
      this.warnings = [];
      Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === undefined && replacer) {
        options = replacer;
        replacer = undefined;
      }
      const opt = Object.assign({
        intAsBigInt: false,
        keepSourceTokens: false,
        logLevel: "warn",
        prettyErrors: true,
        strict: true,
        stringKeys: false,
        uniqueKeys: true,
        version: "1.2"
      }, options);
      this.options = opt;
      let { version } = opt;
      if (options?._directives) {
        this.directives = options._directives.atDocument();
        if (this.directives.yaml.explicit)
          version = this.directives.yaml.version;
      } else
        this.directives = new directives.Directives({ version });
      this.setSchema(version, options);
      this.contents = value === undefined ? null : this.createNode(value, _replacer, options);
    }
    clone() {
      const copy = Object.create(Document.prototype, {
        [identity.NODE_TYPE]: { value: identity.DOC }
      });
      copy.commentBefore = this.commentBefore;
      copy.comment = this.comment;
      copy.errors = this.errors.slice();
      copy.warnings = this.warnings.slice();
      copy.options = Object.assign({}, this.options);
      if (this.directives)
        copy.directives = this.directives.clone();
      copy.schema = this.schema.clone();
      copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    add(value) {
      if (assertCollection(this.contents))
        this.contents.add(value);
    }
    addIn(path, value) {
      if (assertCollection(this.contents))
        this.contents.addIn(path, value);
    }
    createAlias(node, name) {
      if (!node.anchor) {
        const prev = anchors.anchorNames(this);
        node.anchor = !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
      }
      return new Alias.Alias(node.anchor);
    }
    createNode(value, replacer, options) {
      let _replacer = undefined;
      if (typeof replacer === "function") {
        value = replacer.call({ "": value }, "", value);
        _replacer = replacer;
      } else if (Array.isArray(replacer)) {
        const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
        const asStr = replacer.filter(keyToStr).map(String);
        if (asStr.length > 0)
          replacer = replacer.concat(asStr);
        _replacer = replacer;
      } else if (options === undefined && replacer) {
        options = replacer;
        replacer = undefined;
      }
      const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
      const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, anchorPrefix || "a");
      const ctx = {
        aliasDuplicateObjects: aliasDuplicateObjects ?? true,
        keepUndefined: keepUndefined ?? false,
        onAnchor,
        onTagObj,
        replacer: _replacer,
        schema: this.schema,
        sourceObjects
      };
      const node = createNode.createNode(value, tag, ctx);
      if (flow && identity.isCollection(node))
        node.flow = true;
      setAnchors();
      return node;
    }
    createPair(key, value, options = {}) {
      const k = this.createNode(key, null, options);
      const v = this.createNode(value, null, options);
      return new Pair.Pair(k, v);
    }
    delete(key) {
      return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    deleteIn(path) {
      if (Collection.isEmptyPath(path)) {
        if (this.contents == null)
          return false;
        this.contents = null;
        return true;
      }
      return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
    }
    get(key, keepScalar) {
      return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : undefined;
    }
    getIn(path, keepScalar) {
      if (Collection.isEmptyPath(path))
        return !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents;
      return identity.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : undefined;
    }
    has(key) {
      return identity.isCollection(this.contents) ? this.contents.has(key) : false;
    }
    hasIn(path) {
      if (Collection.isEmptyPath(path))
        return this.contents !== undefined;
      return identity.isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    set(key, value) {
      if (this.contents == null) {
        this.contents = Collection.collectionFromPath(this.schema, [key], value);
      } else if (assertCollection(this.contents)) {
        this.contents.set(key, value);
      }
    }
    setIn(path, value) {
      if (Collection.isEmptyPath(path)) {
        this.contents = value;
      } else if (this.contents == null) {
        this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
      } else if (assertCollection(this.contents)) {
        this.contents.setIn(path, value);
      }
    }
    setSchema(version, options = {}) {
      if (typeof version === "number")
        version = String(version);
      let opt;
      switch (version) {
        case "1.1":
          if (this.directives)
            this.directives.yaml.version = "1.1";
          else
            this.directives = new directives.Directives({ version: "1.1" });
          opt = { resolveKnownTags: false, schema: "yaml-1.1" };
          break;
        case "1.2":
        case "next":
          if (this.directives)
            this.directives.yaml.version = version;
          else
            this.directives = new directives.Directives({ version });
          opt = { resolveKnownTags: true, schema: "core" };
          break;
        case null:
          if (this.directives)
            delete this.directives;
          opt = null;
          break;
        default: {
          const sv = JSON.stringify(version);
          throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
        }
      }
      if (options.schema instanceof Object)
        this.schema = options.schema;
      else if (opt)
        this.schema = new Schema.Schema(Object.assign(opt, options));
      else
        throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      const ctx = {
        anchors: new Map,
        doc: this,
        keep: !json,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
      if (typeof onAnchor === "function")
        for (const { count, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count);
      return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
    }
    toJSON(jsonArg, onAnchor) {
      return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    toString(options = {}) {
      if (this.errors.length > 0)
        throw new Error("Document with errors cannot be stringified");
      if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
        const s = JSON.stringify(options.indent);
        throw new Error(`"indent" option must be a positive integer, not ${s}`);
      }
      return stringifyDocument.stringifyDocument(this, options);
    }
  }
  function assertCollection(contents) {
    if (identity.isCollection(contents))
      return true;
    throw new Error("Expected a YAML collection as document contents");
  }
  exports.Document = Document;
});

// node_modules/yaml/dist/errors.js
var require_errors = __commonJS((exports) => {
  class YAMLError extends Error {
    constructor(name, pos, code, message) {
      super();
      this.name = name;
      this.code = code;
      this.message = message;
      this.pos = pos;
    }
  }

  class YAMLParseError extends YAMLError {
    constructor(pos, code, message) {
      super("YAMLParseError", pos, code, message);
    }
  }

  class YAMLWarning extends YAMLError {
    constructor(pos, code, message) {
      super("YAMLWarning", pos, code, message);
    }
  }
  var prettifyError = (src, lc) => (error) => {
    if (error.pos[0] === -1)
      return;
    error.linePos = error.pos.map((pos) => lc.linePos(pos));
    const { line, col } = error.linePos[0];
    error.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
    if (ci >= 60 && lineStr.length > 80) {
      const trimStart = Math.min(ci - 39, lineStr.length - 79);
      lineStr = "\u2026" + lineStr.substring(trimStart);
      ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
      lineStr = lineStr.substring(0, 79) + "\u2026";
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
      let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
      if (prev.length > 80)
        prev = prev.substring(0, 79) + `\u2026
`;
      lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
      let count = 1;
      const end = error.linePos[1];
      if (end && end.line === line && end.col > col) {
        count = Math.max(1, Math.min(end.col - col, 80 - ci));
      }
      const pointer = " ".repeat(ci) + "^".repeat(count);
      error.message += `:

${lineStr}
${pointer}
`;
    }
  };
  exports.YAMLError = YAMLError;
  exports.YAMLParseError = YAMLParseError;
  exports.YAMLWarning = YAMLWarning;
  exports.prettifyError = prettifyError;
});

// node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS((exports) => {
  function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = "";
    let commentSep = "";
    let hasNewline = false;
    let reqSpace = false;
    let tab = null;
    let anchor = null;
    let tag = null;
    let newlineAfterProp = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens) {
      if (reqSpace) {
        if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
          onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
        reqSpace = false;
      }
      if (tab) {
        if (atNewline && token.type !== "comment" && token.type !== "newline") {
          onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        }
        tab = null;
      }
      switch (token.type) {
        case "space":
          if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("\t")) {
            tab = token;
          }
          hasSpace = true;
          break;
        case "comment": {
          if (!hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = token.source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += commentSep + cb;
          commentSep = "";
          atNewline = false;
          break;
        }
        case "newline":
          if (atNewline) {
            if (comment)
              comment += token.source;
            else if (!found || indicator !== "seq-item-ind")
              spaceBefore = true;
          } else
            commentSep += token.source;
          atNewline = true;
          hasNewline = true;
          if (anchor || tag)
            newlineAfterProp = token;
          hasSpace = true;
          break;
        case "anchor":
          if (anchor)
            onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
          if (token.source.endsWith(":"))
            onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
          anchor = token;
          start ?? (start = token.offset);
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        case "tag": {
          if (tag)
            onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
          tag = token;
          start ?? (start = token.offset);
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        }
        case indicator:
          if (anchor || tag)
            onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
          if (found)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
          found = token;
          atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
          hasSpace = false;
          break;
        case "comma":
          if (flow) {
            if (comma)
              onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
            comma = token;
            atNewline = false;
            hasSpace = false;
            break;
          }
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
          atNewline = false;
          hasSpace = false;
      }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
      onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
    }
    if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
      onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
    return {
      comma,
      found,
      spaceBefore,
      comment,
      hasNewline,
      anchor,
      tag,
      newlineAfterProp,
      end,
      start: start ?? end
    };
  }
  exports.resolveProps = resolveProps;
});

// node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS((exports) => {
  function containsNewline(key) {
    if (!key)
      return null;
    switch (key.type) {
      case "alias":
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        if (key.source.includes(`
`))
          return true;
        if (key.end) {
          for (const st of key.end)
            if (st.type === "newline")
              return true;
        }
        return false;
      case "flow-collection":
        for (const it of key.items) {
          for (const st of it.start)
            if (st.type === "newline")
              return true;
          if (it.sep) {
            for (const st of it.sep)
              if (st.type === "newline")
                return true;
          }
          if (containsNewline(it.key) || containsNewline(it.value))
            return true;
        }
        return false;
      default:
        return true;
    }
  }
  exports.containsNewline = containsNewline;
});

// node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS((exports) => {
  var utilContainsNewline = require_util_contains_newline();
  function flowIndentCheck(indent, fc, onError) {
    if (fc?.type === "flow-collection") {
      const end = fc.end[0];
      if (end.indent === indent && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) {
        const msg = "Flow end indicator should be more indented than parent";
        onError(end, "BAD_INDENT", msg, true);
      }
    }
  }
  exports.flowIndentCheck = flowIndentCheck;
});

// node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS((exports) => {
  var identity = require_identity();
  function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
      return false;
    const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value;
    return items.some((pair) => isEqual(pair.key, search));
  }
  exports.mapIncludes = mapIncludes;
});

// node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS((exports) => {
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();
  var resolveProps = require_resolve_props();
  var utilContainsNewline = require_util_contains_newline();
  var utilFlowIndentCheck = require_util_flow_indent_check();
  var utilMapIncludes = require_util_map_includes();
  var startColMsg = "All mapping items must start at the same column";
  function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
    const map = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
      const { start, key, sep, value } = collItem;
      const keyProps = resolveProps.resolveProps(start, {
        indicator: "explicit-key-ind",
        next: key ?? sep?.[0],
        offset,
        onError,
        parentIndent: bm.indent,
        startOnNewline: true
      });
      const implicitKey = !keyProps.found;
      if (implicitKey) {
        if (key) {
          if (key.type === "block-seq")
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
          else if ("indent" in key && key.indent !== bm.indent)
            onError(offset, "BAD_INDENT", startColMsg);
        }
        if (!keyProps.anchor && !keyProps.tag && !sep) {
          commentEnd = keyProps.end;
          if (keyProps.comment) {
            if (map.comment)
              map.comment += `
` + keyProps.comment;
            else
              map.comment = keyProps.comment;
          }
          continue;
        }
        if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
          onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
        }
      } else if (keyProps.found?.indent !== bm.indent) {
        onError(offset, "BAD_INDENT", startColMsg);
      }
      ctx.atKey = true;
      const keyStart = keyProps.end;
      const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
      if (ctx.schema.compat)
        utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
      ctx.atKey = false;
      if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
        onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
      const valueProps = resolveProps.resolveProps(sep ?? [], {
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        parentIndent: bm.indent,
        startOnNewline: !key || key.type === "block-scalar"
      });
      offset = valueProps.end;
      if (valueProps.found) {
        if (implicitKey) {
          if (value?.type === "block-map" && !valueProps.hasNewline)
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
          if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
            onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
        }
        const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
        offset = valueNode.range[2];
        const pair = new Pair.Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map.items.push(pair);
      } else {
        if (implicitKey)
          onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
        if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += `
` + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair.Pair(keyNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map.items.push(pair);
      }
    }
    if (commentEnd && commentEnd < offset)
      onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
    map.range = [bm.offset, offset, commentEnd ?? offset];
    return map;
  }
  exports.resolveBlockMap = resolveBlockMap;
});

// node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS((exports) => {
  var YAMLSeq = require_YAMLSeq();
  var resolveProps = require_resolve_props();
  var utilFlowIndentCheck = require_util_flow_indent_check();
  function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
    const seq = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    if (ctx.atKey)
      ctx.atKey = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start, value } of bs.items) {
      const props = resolveProps.resolveProps(start, {
        indicator: "seq-item-ind",
        next: value,
        offset,
        onError,
        parentIndent: bs.indent,
        startOnNewline: true
      });
      if (!props.found) {
        if (props.anchor || props.tag || value) {
          if (value && value.type === "block-seq")
            onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
          else
            onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
        } else {
          commentEnd = props.end;
          if (props.comment)
            seq.comment = props.comment;
          continue;
        }
      }
      const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
      if (ctx.schema.compat)
        utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
      offset = node.range[2];
      seq.items.push(node);
    }
    seq.range = [bs.offset, offset, commentEnd ?? offset];
    return seq;
  }
  exports.resolveBlockSeq = resolveBlockSeq;
});

// node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS((exports) => {
  function resolveEnd(end, offset, reqSpace, onError) {
    let comment = "";
    if (end) {
      let hasSpace = false;
      let sep = "";
      for (const token of end) {
        const { source, type } = token;
        switch (type) {
          case "space":
            hasSpace = true;
            break;
          case "comment": {
            if (reqSpace && !hasSpace)
              onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += sep + cb;
            sep = "";
            break;
          }
          case "newline":
            if (comment)
              sep += source;
            hasSpace = true;
            break;
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
        }
        offset += source.length;
      }
    }
    return { comment, offset };
  }
  exports.resolveEnd = resolveEnd;
});

// node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS((exports) => {
  var identity = require_identity();
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var resolveEnd = require_resolve_end();
  var resolveProps = require_resolve_props();
  var utilContainsNewline = require_util_contains_newline();
  var utilMapIncludes = require_util_map_includes();
  var blockMsg = "Block collections are not allowed within flow collections";
  var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
  function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
    const isMap = fc.start.source === "{";
    const fcName = isMap ? "flow map" : "flow sequence";
    const NodeClass = tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
      ctx.atRoot = false;
    if (ctx.atKey)
      ctx.atKey = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0;i < fc.items.length; ++i) {
      const collItem = fc.items[i];
      const { start, key, sep, value } = collItem;
      const props = resolveProps.resolveProps(start, {
        flow: fcName,
        indicator: "explicit-key-ind",
        next: key ?? sep?.[0],
        offset,
        onError,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (!props.found) {
        if (!props.anchor && !props.tag && !sep && !value) {
          if (i === 0 && props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
          else if (i < fc.items.length - 1)
            onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
          if (props.comment) {
            if (coll.comment)
              coll.comment += `
` + props.comment;
            else
              coll.comment = props.comment;
          }
          offset = props.end;
          continue;
        }
        if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
          onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
      }
      if (i === 0) {
        if (props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
      } else {
        if (!props.comma)
          onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
        if (props.comment) {
          let prevItemComment = "";
          loop:
            for (const st of start) {
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
          if (prevItemComment) {
            let prev = coll.items[coll.items.length - 1];
            if (identity.isPair(prev))
              prev = prev.value ?? prev.key;
            if (prev.comment)
              prev.comment += `
` + prevItemComment;
            else
              prev.comment = prevItemComment;
            props.comment = props.comment.substring(prevItemComment.length + 1);
          }
        }
      }
      if (!isMap && !sep && !props.found) {
        const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
        coll.items.push(valueNode);
        offset = valueNode.range[2];
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else {
        ctx.atKey = true;
        const keyStart = props.end;
        const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
        if (isBlock(key))
          onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
        ctx.atKey = false;
        const valueProps = resolveProps.resolveProps(sep ?? [], {
          flow: fcName,
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (valueProps.found) {
          if (!isMap && !props.found && ctx.options.strict) {
            if (sep)
              for (const st of sep) {
                if (st === valueProps.found)
                  break;
                if (st.type === "newline") {
                  onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                  break;
                }
              }
            if (props.start < valueProps.found.offset - 1024)
              onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
          }
        } else if (value) {
          if ("source" in value && value.source && value.source[0] === ":")
            onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
          else
            onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
        }
        const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
        if (valueNode) {
          if (isBlock(value))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += `
` + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair.Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        if (isMap) {
          const map = coll;
          if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
            onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
          map.items.push(pair);
        } else {
          const map = new YAMLMap.YAMLMap(ctx.schema);
          map.flow = true;
          map.items.push(pair);
          const endRange = (valueNode ?? keyNode).range;
          map.range = [keyNode.range[0], endRange[1], endRange[2]];
          coll.items.push(map);
        }
        offset = valueNode ? valueNode.range[2] : valueProps.end;
      }
    }
    const expectedEnd = isMap ? "}" : "]";
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd)
      cePos = ce.offset + ce.source.length;
    else {
      const name = fcName[0].toUpperCase() + fcName.substring(1);
      const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
      onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
      if (ce && ce.source.length !== 1)
        ee.unshift(ce);
    }
    if (ee.length > 0) {
      const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
      if (end.comment) {
        if (coll.comment)
          coll.comment += `
` + end.comment;
        else
          coll.comment = end.comment;
      }
      coll.range = [fc.offset, cePos, end.offset];
    } else {
      coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
  }
  exports.resolveFlowCollection = resolveFlowCollection;
});

// node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var resolveBlockMap = require_resolve_block_map();
  var resolveBlockSeq = require_resolve_block_seq();
  var resolveFlowCollection = require_resolve_flow_collection();
  function resolveCollection(CN, ctx, token, onError, tagName, tag) {
    const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
    const Coll = coll.constructor;
    if (tagName === "!" || tagName === Coll.tagName) {
      coll.tag = Coll.tagName;
      return coll;
    }
    if (tagName)
      coll.tag = tagName;
    return coll;
  }
  function composeCollection(CN, ctx, token, props, onError) {
    const tagToken = props.tag;
    const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
    if (token.type === "block-seq") {
      const { anchor, newlineAfterProp: nl } = props;
      const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
      if (lastProp && (!nl || nl.offset < lastProp.offset)) {
        const message = "Missing newline after block sequence props";
        onError(lastProp, "MISSING_CHAR", message);
      }
    }
    const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
    if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") {
      return resolveCollection(CN, ctx, token, onError, tagName);
    }
    let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
    if (!tag) {
      const kt = ctx.schema.knownTags[tagName];
      if (kt && kt.collection === expType) {
        ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
        tag = kt;
      } else {
        if (kt) {
          onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
        } else {
          onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
        }
        return resolveCollection(CN, ctx, token, onError, tagName);
      }
    }
    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
    const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
    const node = identity.isNode(res) ? res : new Scalar.Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag?.format)
      node.format = tag.format;
    return node;
  }
  exports.composeCollection = composeCollection;
});

// node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS((exports) => {
  var Scalar = require_Scalar();
  function resolveBlockScalar(ctx, scalar, onError) {
    const start = scalar.offset;
    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
    if (!header)
      return { value: "", type: null, comment: "", range: [start, start, start] };
    const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines(scalar.source) : [];
    let chompStart = lines.length;
    for (let i = lines.length - 1;i >= 0; --i) {
      const content = lines[i][1];
      if (content === "" || content === "\r")
        chompStart = i;
      else
        break;
    }
    if (chompStart === 0) {
      const value2 = header.chomp === "+" && lines.length > 0 ? `
`.repeat(Math.max(1, lines.length - 1)) : "";
      let end2 = start + header.length;
      if (scalar.source)
        end2 += scalar.source.length;
      return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
    }
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0;i < chompStart; ++i) {
      const [indent, content] = lines[i];
      if (content === "" || content === "\r") {
        if (header.indent === 0 && indent.length > trimIndent)
          trimIndent = indent.length;
      } else {
        if (indent.length < trimIndent) {
          const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
          onError(offset + indent.length, "MISSING_CHAR", message);
        }
        if (header.indent === 0)
          trimIndent = indent.length;
        contentStart = i;
        if (trimIndent === 0 && !ctx.atRoot) {
          const message = "Block scalar values in collections must be indented";
          onError(offset, "BAD_INDENT", message);
        }
        break;
      }
      offset += indent.length + content.length + 1;
    }
    for (let i = lines.length - 1;i >= chompStart; --i) {
      if (lines[i][0].length > trimIndent)
        chompStart = i + 1;
    }
    let value = "";
    let sep = "";
    let prevMoreIndented = false;
    for (let i = 0;i < contentStart; ++i)
      value += lines[i][0].slice(trimIndent) + `
`;
    for (let i = contentStart;i < chompStart; ++i) {
      let [indent, content] = lines[i];
      offset += indent.length + content.length + 1;
      const crlf = content[content.length - 1] === "\r";
      if (crlf)
        content = content.slice(0, -1);
      if (content && indent.length < trimIndent) {
        const src = header.indent ? "explicit indentation indicator" : "first line";
        const message = `Block scalar lines must not be less indented than their ${src}`;
        onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
        indent = "";
      }
      if (type === Scalar.Scalar.BLOCK_LITERAL) {
        value += sep + indent.slice(trimIndent) + content;
        sep = `
`;
      } else if (indent.length > trimIndent || content[0] === "\t") {
        if (sep === " ")
          sep = `
`;
        else if (!prevMoreIndented && sep === `
`)
          sep = `

`;
        value += sep + indent.slice(trimIndent) + content;
        sep = `
`;
        prevMoreIndented = true;
      } else if (content === "") {
        if (sep === `
`)
          value += `
`;
        else
          sep = `
`;
      } else {
        value += sep + content;
        sep = " ";
        prevMoreIndented = false;
      }
    }
    switch (header.chomp) {
      case "-":
        break;
      case "+":
        for (let i = chompStart;i < lines.length; ++i)
          value += `
` + lines[i][0].slice(trimIndent);
        if (value[value.length - 1] !== `
`)
          value += `
`;
        break;
      default:
        value += `
`;
    }
    const end = start + header.length + scalar.source.length;
    return { value, type, comment: header.comment, range: [start, end, end] };
  }
  function parseBlockScalarHeader({ offset, props }, strict, onError) {
    if (props[0].type !== "block-scalar-header") {
      onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
      return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = "";
    let error = -1;
    for (let i = 1;i < source.length; ++i) {
      const ch = source[i];
      if (!chomp && (ch === "-" || ch === "+"))
        chomp = ch;
      else {
        const n = Number(ch);
        if (!indent && n)
          indent = n;
        else if (error === -1)
          error = offset + i;
      }
    }
    if (error !== -1)
      onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = "";
    let length = source.length;
    for (let i = 1;i < props.length; ++i) {
      const token = props[i];
      switch (token.type) {
        case "space":
          hasSpace = true;
        case "newline":
          length += token.source.length;
          break;
        case "comment":
          if (strict && !hasSpace) {
            const message = "Comments must be separated from other tokens by white space characters";
            onError(token, "MISSING_CHAR", message);
          }
          length += token.source.length;
          comment = token.source.substring(1);
          break;
        case "error":
          onError(token, "UNEXPECTED_TOKEN", token.message);
          length += token.source.length;
          break;
        default: {
          const message = `Unexpected token in block scalar header: ${token.type}`;
          onError(token, "UNEXPECTED_TOKEN", message);
          const ts = token.source;
          if (ts && typeof ts === "string")
            length += ts.length;
        }
      }
    }
    return { mode, indent, chomp, comment, length };
  }
  function splitLines(source) {
    const split = source.split(/\n( *)/);
    const first = split[0];
    const m = first.match(/^( *)/);
    const line0 = m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first];
    const lines = [line0];
    for (let i = 1;i < split.length; i += 2)
      lines.push([split[i], split[i + 1]]);
    return lines;
  }
  exports.resolveBlockScalar = resolveBlockScalar;
});

// node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var resolveEnd = require_resolve_end();
  function resolveFlowScalar(scalar, strict, onError) {
    const { offset, type, source, end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
      case "scalar":
        _type = Scalar.Scalar.PLAIN;
        value = plainValue(source, _onError);
        break;
      case "single-quoted-scalar":
        _type = Scalar.Scalar.QUOTE_SINGLE;
        value = singleQuotedValue(source, _onError);
        break;
      case "double-quoted-scalar":
        _type = Scalar.Scalar.QUOTE_DOUBLE;
        value = doubleQuotedValue(source, _onError);
        break;
      default:
        onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
        return {
          value: "",
          type: null,
          comment: "",
          range: [offset, offset + source.length, offset + source.length]
        };
    }
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
    return {
      value,
      type: _type,
      comment: re.comment,
      range: [offset, valueEnd, re.offset]
    };
  }
  function plainValue(source, onError) {
    let badChar = "";
    switch (source[0]) {
      case "\t":
        badChar = "a tab character";
        break;
      case ",":
        badChar = "flow indicator character ,";
        break;
      case "%":
        badChar = "directive indicator character %";
        break;
      case "|":
      case ">": {
        badChar = `block scalar indicator ${source[0]}`;
        break;
      }
      case "@":
      case "`": {
        badChar = `reserved character ${source[0]}`;
        break;
      }
    }
    if (badChar)
      onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
    return foldLines(source);
  }
  function singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
      onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
  }
  function foldLines(source) {
    let first, line;
    try {
      first = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy");
      line = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
    } catch {
      first = /(.*?)[ \t]*\r?\n/sy;
      line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match)
      return source;
    let res = match[1];
    let sep = " ";
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while (match = line.exec(source)) {
      if (match[1] === "") {
        if (sep === `
`)
          res += sep;
        else
          sep = `
`;
      } else {
        res += sep + match[1];
        sep = " ";
      }
      pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep + (match?.[1] ?? "");
  }
  function doubleQuotedValue(source, onError) {
    let res = "";
    for (let i = 1;i < source.length - 1; ++i) {
      const ch = source[i];
      if (ch === "\r" && source[i + 1] === `
`)
        continue;
      if (ch === `
`) {
        const { fold, offset } = foldNewline(source, i);
        res += fold;
        i = offset;
      } else if (ch === "\\") {
        let next = source[++i];
        const cc = escapeCodes[next];
        if (cc)
          res += cc;
        else if (next === `
`) {
          next = source[i + 1];
          while (next === " " || next === "\t")
            next = source[++i + 1];
        } else if (next === "\r" && source[i + 1] === `
`) {
          next = source[++i + 1];
          while (next === " " || next === "\t")
            next = source[++i + 1];
        } else if (next === "x" || next === "u" || next === "U") {
          const length = { x: 2, u: 4, U: 8 }[next];
          res += parseCharCode(source, i + 1, length, onError);
          i += length;
        } else {
          const raw = source.substr(i - 1, 2);
          onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
          res += raw;
        }
      } else if (ch === " " || ch === "\t") {
        const wsStart = i;
        let next = source[i + 1];
        while (next === " " || next === "\t")
          next = source[++i + 1];
        if (next !== `
` && !(next === "\r" && source[i + 2] === `
`))
          res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
      } else {
        res += ch;
      }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
      onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
    return res;
  }
  function foldNewline(source, offset) {
    let fold = "";
    let ch = source[offset + 1];
    while (ch === " " || ch === "\t" || ch === `
` || ch === "\r") {
      if (ch === "\r" && source[offset + 2] !== `
`)
        break;
      if (ch === `
`)
        fold += `
`;
      offset += 1;
      ch = source[offset + 1];
    }
    if (!fold)
      fold = " ";
    return { fold, offset };
  }
  var escapeCodes = {
    "0": "\x00",
    a: "\x07",
    b: "\b",
    e: "\x1B",
    f: "\f",
    n: `
`,
    r: "\r",
    t: "\t",
    v: "\v",
    N: "\x85",
    _: "\xA0",
    L: "\u2028",
    P: "\u2029",
    " ": " ",
    '"': '"',
    "/": "/",
    "\\": "\\",
    "\t": "\t"
  };
  function parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
      const raw = source.substr(offset - 2, length + 2);
      onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
      return raw;
    }
    return String.fromCodePoint(code);
  }
  exports.resolveFlowScalar = resolveFlowScalar;
});

// node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var resolveBlockScalar = require_resolve_block_scalar();
  var resolveFlowScalar = require_resolve_flow_scalar();
  function composeScalar(ctx, token, tagToken, onError) {
    const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
    let tag;
    if (ctx.options.stringKeys && ctx.atKey) {
      tag = ctx.schema[identity.SCALAR];
    } else if (tagName)
      tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
    else if (token.type === "scalar")
      tag = findScalarTagByTest(ctx, value, token, onError);
    else
      tag = ctx.schema[identity.SCALAR];
    let scalar;
    try {
      const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
      scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
      scalar = new Scalar.Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type)
      scalar.type = type;
    if (tagName)
      scalar.tag = tagName;
    if (tag.format)
      scalar.format = tag.format;
    if (comment)
      scalar.comment = comment;
    return scalar;
  }
  function findScalarTagByName(schema, value, tagName, tagToken, onError) {
    if (tagName === "!")
      return schema[identity.SCALAR];
    const matchWithTest = [];
    for (const tag of schema.tags) {
      if (!tag.collection && tag.tag === tagName) {
        if (tag.default && tag.test)
          matchWithTest.push(tag);
        else
          return tag;
      }
    }
    for (const tag of matchWithTest)
      if (tag.test?.test(value))
        return tag;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
      schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
      return kt;
    }
    onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
    return schema[identity.SCALAR];
  }
  function findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {
    const tag = schema.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value)) || schema[identity.SCALAR];
    if (schema.compat) {
      const compat = schema.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema[identity.SCALAR];
      if (tag.tag !== compat.tag) {
        const ts = directives.tagString(tag.tag);
        const cs = directives.tagString(compat.tag);
        const msg = `Value may be parsed as either ${ts} or ${cs}`;
        onError(token, "TAG_RESOLVE_FAILED", msg, true);
      }
    }
    return tag;
  }
  exports.composeScalar = composeScalar;
});

// node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS((exports) => {
  function emptyScalarPosition(offset, before, pos) {
    if (before) {
      pos ?? (pos = before.length);
      for (let i = pos - 1;i >= 0; --i) {
        let st = before[i];
        switch (st.type) {
          case "space":
          case "comment":
          case "newline":
            offset -= st.source.length;
            continue;
        }
        st = before[++i];
        while (st?.type === "space") {
          offset += st.source.length;
          st = before[++i];
        }
        break;
      }
    }
    return offset;
  }
  exports.emptyScalarPosition = emptyScalarPosition;
});

// node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS((exports) => {
  var Alias = require_Alias();
  var identity = require_identity();
  var composeCollection = require_compose_collection();
  var composeScalar = require_compose_scalar();
  var resolveEnd = require_resolve_end();
  var utilEmptyScalarPosition = require_util_empty_scalar_position();
  var CN = { composeNode, composeEmptyNode };
  function composeNode(ctx, token, props, onError) {
    const atKey = ctx.atKey;
    const { spaceBefore, comment, anchor, tag } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
      case "alias":
        node = composeAlias(ctx, token, onError);
        if (anchor || tag)
          onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
        break;
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "block-scalar":
        node = composeScalar.composeScalar(ctx, token, tag, onError);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      case "block-map":
      case "block-seq":
      case "flow-collection":
        node = composeCollection.composeCollection(CN, ctx, token, props, onError);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      default: {
        const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
        onError(token, "UNEXPECTED_TOKEN", message);
        node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
        isSrcToken = false;
      }
    }
    if (anchor && node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    if (atKey && ctx.options.stringKeys && (!identity.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
      const msg = "With stringKeys, all keys must be strings";
      onError(tag ?? token, "NON_STRING_KEY", msg);
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      if (token.type === "scalar" && token.source === "")
        node.comment = comment;
      else
        node.commentBefore = comment;
    }
    if (ctx.options.keepSourceTokens && isSrcToken)
      node.srcToken = token;
    return node;
  }
  function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
    const token = {
      type: "scalar",
      offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
      indent: -1,
      source: ""
    };
    const node = composeScalar.composeScalar(ctx, token, tag, onError);
    if (anchor) {
      node.anchor = anchor.source.substring(1);
      if (node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      node.comment = comment;
      node.range[2] = end;
    }
    return node;
  }
  function composeAlias({ options }, { offset, source, end }, onError) {
    const alias = new Alias.Alias(source.substring(1));
    if (alias.source === "")
      onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
    if (alias.source.endsWith(":"))
      onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [offset, valueEnd, re.offset];
    if (re.comment)
      alias.comment = re.comment;
    return alias;
  }
  exports.composeEmptyNode = composeEmptyNode;
  exports.composeNode = composeNode;
});

// node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS((exports) => {
  var Document = require_Document();
  var composeNode = require_compose_node();
  var resolveEnd = require_resolve_end();
  var resolveProps = require_resolve_props();
  function composeDoc(options, directives, { offset, start, value, end }, onError) {
    const opts = Object.assign({ _directives: directives }, options);
    const doc = new Document.Document(undefined, opts);
    const ctx = {
      atKey: false,
      atRoot: true,
      directives: doc.directives,
      options: doc.options,
      schema: doc.schema
    };
    const props = resolveProps.resolveProps(start, {
      indicator: "doc-start",
      next: value ?? end?.[0],
      offset,
      onError,
      parentIndent: 0,
      startOnNewline: true
    });
    if (props.found) {
      doc.directives.docStart = true;
      if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
        onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
    }
    doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
    if (re.comment)
      doc.comment = re.comment;
    doc.range = [offset, contentEnd, re.offset];
    return doc;
  }
  exports.composeDoc = composeDoc;
});

// node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS((exports) => {
  var node_process = __require("process");
  var directives = require_directives();
  var Document = require_Document();
  var errors = require_errors();
  var identity = require_identity();
  var composeDoc = require_compose_doc();
  var resolveEnd = require_resolve_end();
  function getErrorPos(src) {
    if (typeof src === "number")
      return [src, src + 1];
    if (Array.isArray(src))
      return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === "string" ? source.length : 1)];
  }
  function parsePrelude(prelude) {
    let comment = "";
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0;i < prelude.length; ++i) {
      const source = prelude[i];
      switch (source[0]) {
        case "#":
          comment += (comment === "" ? "" : afterEmptyLine ? `

` : `
`) + (source.substring(1) || " ");
          atComment = true;
          afterEmptyLine = false;
          break;
        case "%":
          if (prelude[i + 1]?.[0] !== "#")
            i += 1;
          atComment = false;
          break;
        default:
          if (!atComment)
            afterEmptyLine = true;
          atComment = false;
      }
    }
    return { comment, afterEmptyLine };
  }

  class Composer {
    constructor(options = {}) {
      this.doc = null;
      this.atDirectives = false;
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
      this.onError = (source, code, message, warning) => {
        const pos = getErrorPos(source);
        if (warning)
          this.warnings.push(new errors.YAMLWarning(pos, code, message));
        else
          this.errors.push(new errors.YAMLParseError(pos, code, message));
      };
      this.directives = new directives.Directives({ version: options.version || "1.2" });
      this.options = options;
    }
    decorate(doc, afterDoc) {
      const { comment, afterEmptyLine } = parsePrelude(this.prelude);
      if (comment) {
        const dc = doc.contents;
        if (afterDoc) {
          doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
        } else if (afterEmptyLine || doc.directives.docStart || !dc) {
          doc.commentBefore = comment;
        } else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
          let it = dc.items[0];
          if (identity.isPair(it))
            it = it.key;
          const cb = it.commentBefore;
          it.commentBefore = cb ? `${comment}
${cb}` : comment;
        } else {
          const cb = dc.commentBefore;
          dc.commentBefore = cb ? `${comment}
${cb}` : comment;
        }
      }
      if (afterDoc) {
        Array.prototype.push.apply(doc.errors, this.errors);
        Array.prototype.push.apply(doc.warnings, this.warnings);
      } else {
        doc.errors = this.errors;
        doc.warnings = this.warnings;
      }
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
    }
    streamInfo() {
      return {
        comment: parsePrelude(this.prelude).comment,
        directives: this.directives,
        errors: this.errors,
        warnings: this.warnings
      };
    }
    *compose(tokens, forceDoc = false, endOffset = -1) {
      for (const token of tokens)
        yield* this.next(token);
      yield* this.end(forceDoc, endOffset);
    }
    *next(token) {
      if (node_process.env.LOG_STREAM)
        console.dir(token, { depth: null });
      switch (token.type) {
        case "directive":
          this.directives.add(token.source, (offset, message, warning) => {
            const pos = getErrorPos(token);
            pos[0] += offset;
            this.onError(pos, "BAD_DIRECTIVE", message, warning);
          });
          this.prelude.push(token.source);
          this.atDirectives = true;
          break;
        case "document": {
          const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
          if (this.atDirectives && !doc.directives.docStart)
            this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
          this.decorate(doc, false);
          if (this.doc)
            yield this.doc;
          this.doc = doc;
          this.atDirectives = false;
          break;
        }
        case "byte-order-mark":
        case "space":
          break;
        case "comment":
        case "newline":
          this.prelude.push(token.source);
          break;
        case "error": {
          const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
          const error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
          if (this.atDirectives || !this.doc)
            this.errors.push(error);
          else
            this.doc.errors.push(error);
          break;
        }
        case "doc-end": {
          if (!this.doc) {
            const msg = "Unexpected doc-end without preceding document";
            this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
            break;
          }
          this.doc.directives.docEnd = true;
          const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
          this.decorate(this.doc, true);
          if (end.comment) {
            const dc = this.doc.comment;
            this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
          }
          this.doc.range[2] = end.offset;
          break;
        }
        default:
          this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
      }
    }
    *end(forceDoc = false, endOffset = -1) {
      if (this.doc) {
        this.decorate(this.doc, true);
        yield this.doc;
        this.doc = null;
      } else if (forceDoc) {
        const opts = Object.assign({ _directives: this.directives }, this.options);
        const doc = new Document.Document(undefined, opts);
        if (this.atDirectives)
          this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
        doc.range = [0, endOffset, endOffset];
        this.decorate(doc, false);
        yield doc;
      }
    }
  }
  exports.Composer = Composer;
});

// node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS((exports) => {
  var resolveBlockScalar = require_resolve_block_scalar();
  var resolveFlowScalar = require_resolve_flow_scalar();
  var errors = require_errors();
  var stringifyString = require_stringifyString();
  function resolveAsScalar(token, strict = true, onError) {
    if (token) {
      const _onError = (pos, code, message) => {
        const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
        if (onError)
          onError(offset, code, message);
        else
          throw new errors.YAMLParseError([offset, offset + 1], code, message);
      };
      switch (token.type) {
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
        case "block-scalar":
          return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
      }
    }
    return null;
  }
  function createScalarToken(value, context) {
    const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
    const source = stringifyString.stringifyString({ type, value }, {
      implicitKey,
      indent: indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    const end = context.end ?? [
      { type: "newline", offset: -1, indent, source: `
` }
    ];
    switch (source[0]) {
      case "|":
      case ">": {
        const he = source.indexOf(`
`);
        const head = source.substring(0, he);
        const body = source.substring(he + 1) + `
`;
        const props = [
          { type: "block-scalar-header", offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, end))
          props.push({ type: "newline", offset: -1, indent, source: `
` });
        return { type: "block-scalar", offset, indent, props, source: body };
      }
      case '"':
        return { type: "double-quoted-scalar", offset, indent, source, end };
      case "'":
        return { type: "single-quoted-scalar", offset, indent, source, end };
      default:
        return { type: "scalar", offset, indent, source, end };
    }
  }
  function setScalarValue(token, value, context = {}) {
    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
    let indent = "indent" in token ? token.indent : null;
    if (afterKey && typeof indent === "number")
      indent += 2;
    if (!type)
      switch (token.type) {
        case "single-quoted-scalar":
          type = "QUOTE_SINGLE";
          break;
        case "double-quoted-scalar":
          type = "QUOTE_DOUBLE";
          break;
        case "block-scalar": {
          const header = token.props[0];
          if (header.type !== "block-scalar-header")
            throw new Error("Invalid block scalar header");
          type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
          break;
        }
        default:
          type = "PLAIN";
      }
    const source = stringifyString.stringifyString({ type, value }, {
      implicitKey: implicitKey || indent === null,
      indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    switch (source[0]) {
      case "|":
      case ">":
        setBlockScalarValue(token, source);
        break;
      case '"':
        setFlowScalarValue(token, source, "double-quoted-scalar");
        break;
      case "'":
        setFlowScalarValue(token, source, "single-quoted-scalar");
        break;
      default:
        setFlowScalarValue(token, source, "scalar");
    }
  }
  function setBlockScalarValue(token, source) {
    const he = source.indexOf(`
`);
    const head = source.substring(0, he);
    const body = source.substring(he + 1) + `
`;
    if (token.type === "block-scalar") {
      const header = token.props[0];
      if (header.type !== "block-scalar-header")
        throw new Error("Invalid block scalar header");
      header.source = head;
      token.source = body;
    } else {
      const { offset } = token;
      const indent = "indent" in token ? token.indent : -1;
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, "end" in token ? token.end : undefined))
        props.push({ type: "newline", offset: -1, indent, source: `
` });
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type: "block-scalar", indent, props, source: body });
    }
  }
  function addEndtoBlockProps(props, end) {
    if (end)
      for (const st of end)
        switch (st.type) {
          case "space":
          case "comment":
            props.push(st);
            break;
          case "newline":
            props.push(st);
            return true;
        }
    return false;
  }
  function setFlowScalarValue(token, source, type) {
    switch (token.type) {
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        token.type = type;
        token.source = source;
        break;
      case "block-scalar": {
        const end = token.props.slice(1);
        let oa = source.length;
        if (token.props[0].type === "block-scalar-header")
          oa -= token.props[0].source.length;
        for (const tok of end)
          tok.offset += oa;
        delete token.props;
        Object.assign(token, { type, source, end });
        break;
      }
      case "block-map":
      case "block-seq": {
        const offset = token.offset + source.length;
        const nl = { type: "newline", offset, indent: token.indent, source: `
` };
        delete token.items;
        Object.assign(token, { type, source, end: [nl] });
        break;
      }
      default: {
        const indent = "indent" in token ? token.indent : -1;
        const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type, indent, source, end });
      }
    }
  }
  exports.createScalarToken = createScalarToken;
  exports.resolveAsScalar = resolveAsScalar;
  exports.setScalarValue = setScalarValue;
});

// node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS((exports) => {
  var stringify = (cst) => ("type" in cst) ? stringifyToken(cst) : stringifyItem(cst);
  function stringifyToken(token) {
    switch (token.type) {
      case "block-scalar": {
        let res = "";
        for (const tok of token.props)
          res += stringifyToken(tok);
        return res + token.source;
      }
      case "block-map":
      case "block-seq": {
        let res = "";
        for (const item of token.items)
          res += stringifyItem(item);
        return res;
      }
      case "flow-collection": {
        let res = token.start.source;
        for (const item of token.items)
          res += stringifyItem(item);
        for (const st of token.end)
          res += st.source;
        return res;
      }
      case "document": {
        let res = stringifyItem(token);
        if (token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
      default: {
        let res = token.source;
        if ("end" in token && token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
    }
  }
  function stringifyItem({ start, key, sep, value }) {
    let res = "";
    for (const st of start)
      res += st.source;
    if (key)
      res += stringifyToken(key);
    if (sep)
      for (const st of sep)
        res += st.source;
    if (value)
      res += stringifyToken(value);
    return res;
  }
  exports.stringify = stringify;
});

// node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS((exports) => {
  var BREAK = Symbol("break visit");
  var SKIP = Symbol("skip children");
  var REMOVE = Symbol("remove item");
  function visit(cst, visitor) {
    if ("type" in cst && cst.type === "document")
      cst = { start: cst.start, value: cst.value };
    _visit(Object.freeze([]), cst, visitor);
  }
  visit.BREAK = BREAK;
  visit.SKIP = SKIP;
  visit.REMOVE = REMOVE;
  visit.itemAtPath = (cst, path) => {
    let item = cst;
    for (const [field, index] of path) {
      const tok = item?.[field];
      if (tok && "items" in tok) {
        item = tok.items[index];
      } else
        return;
    }
    return item;
  };
  visit.parentCollection = (cst, path) => {
    const parent = visit.itemAtPath(cst, path.slice(0, -1));
    const field = path[path.length - 1][0];
    const coll = parent?.[field];
    if (coll && "items" in coll)
      return coll;
    throw new Error("Parent collection not found");
  };
  function _visit(path, item, visitor) {
    let ctrl = visitor(item, path);
    if (typeof ctrl === "symbol")
      return ctrl;
    for (const field of ["key", "value"]) {
      const token = item[field];
      if (token && "items" in token) {
        for (let i = 0;i < token.items.length; ++i) {
          const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            token.items.splice(i, 1);
            i -= 1;
          }
        }
        if (typeof ctrl === "function" && field === "key")
          ctrl = ctrl(item, path);
      }
    }
    return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
  }
  exports.visit = visit;
});

// node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS((exports) => {
  var cstScalar = require_cst_scalar();
  var cstStringify = require_cst_stringify();
  var cstVisit = require_cst_visit();
  var BOM = "\uFEFF";
  var DOCUMENT = "\x02";
  var FLOW_END = "\x18";
  var SCALAR = "\x1F";
  var isCollection = (token) => !!token && ("items" in token);
  var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
  function prettyToken(token) {
    switch (token) {
      case BOM:
        return "<BOM>";
      case DOCUMENT:
        return "<DOC>";
      case FLOW_END:
        return "<FLOW_END>";
      case SCALAR:
        return "<SCALAR>";
      default:
        return JSON.stringify(token);
    }
  }
  function tokenType(source) {
    switch (source) {
      case BOM:
        return "byte-order-mark";
      case DOCUMENT:
        return "doc-mode";
      case FLOW_END:
        return "flow-error-end";
      case SCALAR:
        return "scalar";
      case "---":
        return "doc-start";
      case "...":
        return "doc-end";
      case "":
      case `
`:
      case `\r
`:
        return "newline";
      case "-":
        return "seq-item-ind";
      case "?":
        return "explicit-key-ind";
      case ":":
        return "map-value-ind";
      case "{":
        return "flow-map-start";
      case "}":
        return "flow-map-end";
      case "[":
        return "flow-seq-start";
      case "]":
        return "flow-seq-end";
      case ",":
        return "comma";
    }
    switch (source[0]) {
      case " ":
      case "\t":
        return "space";
      case "#":
        return "comment";
      case "%":
        return "directive-line";
      case "*":
        return "alias";
      case "&":
        return "anchor";
      case "!":
        return "tag";
      case "'":
        return "single-quoted-scalar";
      case '"':
        return "double-quoted-scalar";
      case "|":
      case ">":
        return "block-scalar-header";
    }
    return null;
  }
  exports.createScalarToken = cstScalar.createScalarToken;
  exports.resolveAsScalar = cstScalar.resolveAsScalar;
  exports.setScalarValue = cstScalar.setScalarValue;
  exports.stringify = cstStringify.stringify;
  exports.visit = cstVisit.visit;
  exports.BOM = BOM;
  exports.DOCUMENT = DOCUMENT;
  exports.FLOW_END = FLOW_END;
  exports.SCALAR = SCALAR;
  exports.isCollection = isCollection;
  exports.isScalar = isScalar;
  exports.prettyToken = prettyToken;
  exports.tokenType = tokenType;
});

// node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS((exports) => {
  var cst = require_cst();
  function isEmpty(ch) {
    switch (ch) {
      case undefined:
      case " ":
      case `
`:
      case "\r":
      case "\t":
        return true;
      default:
        return false;
    }
  }
  var hexDigits = new Set("0123456789ABCDEFabcdef");
  var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
  var flowIndicatorChars = new Set(",[]{}");
  var invalidAnchorChars = new Set(` ,[]{}
\r	`);
  var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);

  class Lexer {
    constructor() {
      this.atEnd = false;
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      this.buffer = "";
      this.flowKey = false;
      this.flowLevel = 0;
      this.indentNext = 0;
      this.indentValue = 0;
      this.lineEndPos = null;
      this.next = null;
      this.pos = 0;
    }
    *lex(source, incomplete = false) {
      if (source) {
        if (typeof source !== "string")
          throw TypeError("source is not a string");
        this.buffer = this.buffer ? this.buffer + source : source;
        this.lineEndPos = null;
      }
      this.atEnd = !incomplete;
      let next = this.next ?? "stream";
      while (next && (incomplete || this.hasChars(1)))
        next = yield* this.parseNext(next);
    }
    atLineEnd() {
      let i = this.pos;
      let ch = this.buffer[i];
      while (ch === " " || ch === "\t")
        ch = this.buffer[++i];
      if (!ch || ch === "#" || ch === `
`)
        return true;
      if (ch === "\r")
        return this.buffer[i + 1] === `
`;
      return false;
    }
    charAt(n) {
      return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
      let ch = this.buffer[offset];
      if (this.indentNext > 0) {
        let indent = 0;
        while (ch === " ")
          ch = this.buffer[++indent + offset];
        if (ch === "\r") {
          const next = this.buffer[indent + offset + 1];
          if (next === `
` || !next && !this.atEnd)
            return offset + indent + 1;
        }
        return ch === `
` || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
      }
      if (ch === "-" || ch === ".") {
        const dt = this.buffer.substr(offset, 3);
        if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
          return -1;
      }
      return offset;
    }
    getLine() {
      let end = this.lineEndPos;
      if (typeof end !== "number" || end !== -1 && end < this.pos) {
        end = this.buffer.indexOf(`
`, this.pos);
        this.lineEndPos = end;
      }
      if (end === -1)
        return this.atEnd ? this.buffer.substring(this.pos) : null;
      if (this.buffer[end - 1] === "\r")
        end -= 1;
      return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
      return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
      this.buffer = this.buffer.substring(this.pos);
      this.pos = 0;
      this.lineEndPos = null;
      this.next = state;
      return null;
    }
    peek(n) {
      return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
      switch (next) {
        case "stream":
          return yield* this.parseStream();
        case "line-start":
          return yield* this.parseLineStart();
        case "block-start":
          return yield* this.parseBlockStart();
        case "doc":
          return yield* this.parseDocument();
        case "flow":
          return yield* this.parseFlowCollection();
        case "quoted-scalar":
          return yield* this.parseQuotedScalar();
        case "block-scalar":
          return yield* this.parseBlockScalar();
        case "plain-scalar":
          return yield* this.parsePlainScalar();
      }
    }
    *parseStream() {
      let line = this.getLine();
      if (line === null)
        return this.setNext("stream");
      if (line[0] === cst.BOM) {
        yield* this.pushCount(1);
        line = line.substring(1);
      }
      if (line[0] === "%") {
        let dirEnd = line.length;
        let cs = line.indexOf("#");
        while (cs !== -1) {
          const ch = line[cs - 1];
          if (ch === " " || ch === "\t") {
            dirEnd = cs - 1;
            break;
          } else {
            cs = line.indexOf("#", cs + 1);
          }
        }
        while (true) {
          const ch = line[dirEnd - 1];
          if (ch === " " || ch === "\t")
            dirEnd -= 1;
          else
            break;
        }
        const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
        yield* this.pushCount(line.length - n);
        this.pushNewline();
        return "stream";
      }
      if (this.atLineEnd()) {
        const sp = yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - sp);
        yield* this.pushNewline();
        return "stream";
      }
      yield cst.DOCUMENT;
      return yield* this.parseLineStart();
    }
    *parseLineStart() {
      const ch = this.charAt(0);
      if (!ch && !this.atEnd)
        return this.setNext("line-start");
      if (ch === "-" || ch === ".") {
        if (!this.atEnd && !this.hasChars(4))
          return this.setNext("line-start");
        const s = this.peek(3);
        if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
          yield* this.pushCount(3);
          this.indentValue = 0;
          this.indentNext = 0;
          return s === "---" ? "doc" : "stream";
        }
      }
      this.indentValue = yield* this.pushSpaces(false);
      if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
        this.indentNext = this.indentValue;
      return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
      const [ch0, ch1] = this.peek(2);
      if (!ch1 && !this.atEnd)
        return this.setNext("block-start");
      if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
        const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
        this.indentNext = this.indentValue + 1;
        this.indentValue += n;
        return yield* this.parseBlockStart();
      }
      return "doc";
    }
    *parseDocument() {
      yield* this.pushSpaces(true);
      const line = this.getLine();
      if (line === null)
        return this.setNext("doc");
      let n = yield* this.pushIndicators();
      switch (line[n]) {
        case "#":
          yield* this.pushCount(line.length - n);
        case undefined:
          yield* this.pushNewline();
          return yield* this.parseLineStart();
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel = 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          return "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "doc";
        case '"':
        case "'":
          return yield* this.parseQuotedScalar();
        case "|":
        case ">":
          n += yield* this.parseBlockScalarHeader();
          n += yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - n);
          yield* this.pushNewline();
          return yield* this.parseBlockScalar();
        default:
          return yield* this.parsePlainScalar();
      }
    }
    *parseFlowCollection() {
      let nl, sp;
      let indent = -1;
      do {
        nl = yield* this.pushNewline();
        if (nl > 0) {
          sp = yield* this.pushSpaces(false);
          this.indentValue = indent = sp;
        } else {
          sp = 0;
        }
        sp += yield* this.pushSpaces(true);
      } while (nl + sp > 0);
      const line = this.getLine();
      if (line === null)
        return this.setNext("flow");
      if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
        const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
        if (!atFlowEndMarker) {
          this.flowLevel = 0;
          yield cst.FLOW_END;
          return yield* this.parseLineStart();
        }
      }
      let n = 0;
      while (line[n] === ",") {
        n += yield* this.pushCount(1);
        n += yield* this.pushSpaces(true);
        this.flowKey = false;
      }
      n += yield* this.pushIndicators();
      switch (line[n]) {
        case undefined:
          return "flow";
        case "#":
          yield* this.pushCount(line.length - n);
          return "flow";
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel += 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          this.flowKey = true;
          this.flowLevel -= 1;
          return this.flowLevel ? "flow" : "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "flow";
        case '"':
        case "'":
          this.flowKey = true;
          return yield* this.parseQuotedScalar();
        case ":": {
          const next = this.charAt(1);
          if (this.flowKey || isEmpty(next) || next === ",") {
            this.flowKey = false;
            yield* this.pushCount(1);
            yield* this.pushSpaces(true);
            return "flow";
          }
        }
        default:
          this.flowKey = false;
          return yield* this.parsePlainScalar();
      }
    }
    *parseQuotedScalar() {
      const quote = this.charAt(0);
      let end = this.buffer.indexOf(quote, this.pos + 1);
      if (quote === "'") {
        while (end !== -1 && this.buffer[end + 1] === "'")
          end = this.buffer.indexOf("'", end + 2);
      } else {
        while (end !== -1) {
          let n = 0;
          while (this.buffer[end - 1 - n] === "\\")
            n += 1;
          if (n % 2 === 0)
            break;
          end = this.buffer.indexOf('"', end + 1);
        }
      }
      const qb = this.buffer.substring(0, end);
      let nl = qb.indexOf(`
`, this.pos);
      if (nl !== -1) {
        while (nl !== -1) {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = qb.indexOf(`
`, cs);
        }
        if (nl !== -1) {
          end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
        }
      }
      if (end === -1) {
        if (!this.atEnd)
          return this.setNext("quoted-scalar");
        end = this.buffer.length;
      }
      yield* this.pushToIndex(end + 1, false);
      return this.flowLevel ? "flow" : "doc";
    }
    *parseBlockScalarHeader() {
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      let i = this.pos;
      while (true) {
        const ch = this.buffer[++i];
        if (ch === "+")
          this.blockScalarKeep = true;
        else if (ch > "0" && ch <= "9")
          this.blockScalarIndent = Number(ch) - 1;
        else if (ch !== "-")
          break;
      }
      return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
    }
    *parseBlockScalar() {
      let nl = this.pos - 1;
      let indent = 0;
      let ch;
      loop:
        for (let i2 = this.pos;ch = this.buffer[i2]; ++i2) {
          switch (ch) {
            case " ":
              indent += 1;
              break;
            case `
`:
              nl = i2;
              indent = 0;
              break;
            case "\r": {
              const next = this.buffer[i2 + 1];
              if (!next && !this.atEnd)
                return this.setNext("block-scalar");
              if (next === `
`)
                break;
            }
            default:
              break loop;
          }
        }
      if (!ch && !this.atEnd)
        return this.setNext("block-scalar");
      if (indent >= this.indentNext) {
        if (this.blockScalarIndent === -1)
          this.indentNext = indent;
        else {
          this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
        }
        do {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = this.buffer.indexOf(`
`, cs);
        } while (nl !== -1);
        if (nl === -1) {
          if (!this.atEnd)
            return this.setNext("block-scalar");
          nl = this.buffer.length;
        }
      }
      let i = nl + 1;
      ch = this.buffer[i];
      while (ch === " ")
        ch = this.buffer[++i];
      if (ch === "\t") {
        while (ch === "\t" || ch === " " || ch === "\r" || ch === `
`)
          ch = this.buffer[++i];
        nl = i - 1;
      } else if (!this.blockScalarKeep) {
        do {
          let i2 = nl - 1;
          let ch2 = this.buffer[i2];
          if (ch2 === "\r")
            ch2 = this.buffer[--i2];
          const lastChar = i2;
          while (ch2 === " ")
            ch2 = this.buffer[--i2];
          if (ch2 === `
` && i2 >= this.pos && i2 + 1 + indent > lastChar)
            nl = i2;
          else
            break;
        } while (true);
      }
      yield cst.SCALAR;
      yield* this.pushToIndex(nl + 1, true);
      return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
      const inFlow = this.flowLevel > 0;
      let end = this.pos - 1;
      let i = this.pos - 1;
      let ch;
      while (ch = this.buffer[++i]) {
        if (ch === ":") {
          const next = this.buffer[i + 1];
          if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
            break;
          end = i;
        } else if (isEmpty(ch)) {
          let next = this.buffer[i + 1];
          if (ch === "\r") {
            if (next === `
`) {
              i += 1;
              ch = `
`;
              next = this.buffer[i + 1];
            } else
              end = i;
          }
          if (next === "#" || inFlow && flowIndicatorChars.has(next))
            break;
          if (ch === `
`) {
            const cs = this.continueScalar(i + 1);
            if (cs === -1)
              break;
            i = Math.max(i, cs - 2);
          }
        } else {
          if (inFlow && flowIndicatorChars.has(ch))
            break;
          end = i;
        }
      }
      if (!ch && !this.atEnd)
        return this.setNext("plain-scalar");
      yield cst.SCALAR;
      yield* this.pushToIndex(end + 1, true);
      return inFlow ? "flow" : "doc";
    }
    *pushCount(n) {
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos += n;
        return n;
      }
      return 0;
    }
    *pushToIndex(i, allowEmpty) {
      const s = this.buffer.slice(this.pos, i);
      if (s) {
        yield s;
        this.pos += s.length;
        return s.length;
      } else if (allowEmpty)
        yield "";
      return 0;
    }
    *pushIndicators() {
      switch (this.charAt(0)) {
        case "!":
          return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "&":
          return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "-":
        case "?":
        case ":": {
          const inFlow = this.flowLevel > 0;
          const ch1 = this.charAt(1);
          if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
            if (!inFlow)
              this.indentNext = this.indentValue + 1;
            else if (this.flowKey)
              this.flowKey = false;
            return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          }
        }
      }
      return 0;
    }
    *pushTag() {
      if (this.charAt(1) === "<") {
        let i = this.pos + 2;
        let ch = this.buffer[i];
        while (!isEmpty(ch) && ch !== ">")
          ch = this.buffer[++i];
        return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
      } else {
        let i = this.pos + 1;
        let ch = this.buffer[i];
        while (ch) {
          if (tagChars.has(ch))
            ch = this.buffer[++i];
          else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
            ch = this.buffer[i += 3];
          } else
            break;
        }
        return yield* this.pushToIndex(i, false);
      }
    }
    *pushNewline() {
      const ch = this.buffer[this.pos];
      if (ch === `
`)
        return yield* this.pushCount(1);
      else if (ch === "\r" && this.charAt(1) === `
`)
        return yield* this.pushCount(2);
      else
        return 0;
    }
    *pushSpaces(allowTabs) {
      let i = this.pos - 1;
      let ch;
      do {
        ch = this.buffer[++i];
      } while (ch === " " || allowTabs && ch === "\t");
      const n = i - this.pos;
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos = i;
      }
      return n;
    }
    *pushUntil(test) {
      let i = this.pos;
      let ch = this.buffer[i];
      while (!test(ch))
        ch = this.buffer[++i];
      return yield* this.pushToIndex(i, false);
    }
  }
  exports.Lexer = Lexer;
});

// node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS((exports) => {
  class LineCounter {
    constructor() {
      this.lineStarts = [];
      this.addNewLine = (offset) => this.lineStarts.push(offset);
      this.linePos = (offset) => {
        let low = 0;
        let high = this.lineStarts.length;
        while (low < high) {
          const mid = low + high >> 1;
          if (this.lineStarts[mid] < offset)
            low = mid + 1;
          else
            high = mid;
        }
        if (this.lineStarts[low] === offset)
          return { line: low + 1, col: 1 };
        if (low === 0)
          return { line: 0, col: offset };
        const start = this.lineStarts[low - 1];
        return { line: low, col: offset - start + 1 };
      };
    }
  }
  exports.LineCounter = LineCounter;
});

// node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS((exports) => {
  var node_process = __require("process");
  var cst = require_cst();
  var lexer = require_lexer();
  function includesToken(list, type) {
    for (let i = 0;i < list.length; ++i)
      if (list[i].type === type)
        return true;
    return false;
  }
  function findNonEmptyIndex(list) {
    for (let i = 0;i < list.length; ++i) {
      switch (list[i].type) {
        case "space":
        case "comment":
        case "newline":
          break;
        default:
          return i;
      }
    }
    return -1;
  }
  function isFlowToken(token) {
    switch (token?.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "flow-collection":
        return true;
      default:
        return false;
    }
  }
  function getPrevProps(parent) {
    switch (parent.type) {
      case "document":
        return parent.start;
      case "block-map": {
        const it = parent.items[parent.items.length - 1];
        return it.sep ?? it.start;
      }
      case "block-seq":
        return parent.items[parent.items.length - 1].start;
      default:
        return [];
    }
  }
  function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
      return [];
    let i = prev.length;
    loop:
      while (--i >= 0) {
        switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
      }
    while (prev[++i]?.type === "space") {}
    return prev.splice(i, prev.length);
  }
  function fixFlowSeqItems(fc) {
    if (fc.start.type === "flow-seq-start") {
      for (const it of fc.items) {
        if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
          if (it.key)
            it.value = it.key;
          delete it.key;
          if (isFlowToken(it.value)) {
            if (it.value.end)
              Array.prototype.push.apply(it.value.end, it.sep);
            else
              it.value.end = it.sep;
          } else
            Array.prototype.push.apply(it.start, it.sep);
          delete it.sep;
        }
      }
    }
  }

  class Parser {
    constructor(onNewLine) {
      this.atNewLine = true;
      this.atScalar = false;
      this.indent = 0;
      this.offset = 0;
      this.onKeyLine = false;
      this.stack = [];
      this.source = "";
      this.type = "";
      this.lexer = new lexer.Lexer;
      this.onNewLine = onNewLine;
    }
    *parse(source, incomplete = false) {
      if (this.onNewLine && this.offset === 0)
        this.onNewLine(0);
      for (const lexeme of this.lexer.lex(source, incomplete))
        yield* this.next(lexeme);
      if (!incomplete)
        yield* this.end();
    }
    *next(source) {
      this.source = source;
      if (node_process.env.LOG_TOKENS)
        console.log("|", cst.prettyToken(source));
      if (this.atScalar) {
        this.atScalar = false;
        yield* this.step();
        this.offset += source.length;
        return;
      }
      const type = cst.tokenType(source);
      if (!type) {
        const message = `Not a YAML token: ${source}`;
        yield* this.pop({ type: "error", offset: this.offset, message, source });
        this.offset += source.length;
      } else if (type === "scalar") {
        this.atNewLine = false;
        this.atScalar = true;
        this.type = "scalar";
      } else {
        this.type = type;
        yield* this.step();
        switch (type) {
          case "newline":
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine)
              this.onNewLine(this.offset + source.length);
            break;
          case "space":
            if (this.atNewLine && source[0] === " ")
              this.indent += source.length;
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            if (this.atNewLine)
              this.indent += source.length;
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = false;
        }
        this.offset += source.length;
      }
    }
    *end() {
      while (this.stack.length > 0)
        yield* this.pop();
    }
    get sourceToken() {
      const st = {
        type: this.type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
      return st;
    }
    *step() {
      const top = this.peek(1);
      if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
        while (this.stack.length > 0)
          yield* this.pop();
        this.stack.push({
          type: "doc-end",
          offset: this.offset,
          source: this.source
        });
        return;
      }
      if (!top)
        return yield* this.stream();
      switch (top.type) {
        case "document":
          return yield* this.document(top);
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return yield* this.scalar(top);
        case "block-scalar":
          return yield* this.blockScalar(top);
        case "block-map":
          return yield* this.blockMap(top);
        case "block-seq":
          return yield* this.blockSequence(top);
        case "flow-collection":
          return yield* this.flowCollection(top);
        case "doc-end":
          return yield* this.documentEnd(top);
      }
      yield* this.pop();
    }
    peek(n) {
      return this.stack[this.stack.length - n];
    }
    *pop(error) {
      const token = error ?? this.stack.pop();
      if (!token) {
        const message = "Tried to pop an empty stack";
        yield { type: "error", offset: this.offset, source: "", message };
      } else if (this.stack.length === 0) {
        yield token;
      } else {
        const top = this.peek(1);
        if (token.type === "block-scalar") {
          token.indent = "indent" in top ? top.indent : 0;
        } else if (token.type === "flow-collection" && top.type === "document") {
          token.indent = 0;
        }
        if (token.type === "flow-collection")
          fixFlowSeqItems(token);
        switch (top.type) {
          case "document":
            top.value = token;
            break;
          case "block-scalar":
            top.props.push(token);
            break;
          case "block-map": {
            const it = top.items[top.items.length - 1];
            if (it.value) {
              top.items.push({ start: [], key: token, sep: [] });
              this.onKeyLine = true;
              return;
            } else if (it.sep) {
              it.value = token;
            } else {
              Object.assign(it, { key: token, sep: [] });
              this.onKeyLine = !it.explicitKey;
              return;
            }
            break;
          }
          case "block-seq": {
            const it = top.items[top.items.length - 1];
            if (it.value)
              top.items.push({ start: [], value: token });
            else
              it.value = token;
            break;
          }
          case "flow-collection": {
            const it = top.items[top.items.length - 1];
            if (!it || it.value)
              top.items.push({ start: [], key: token, sep: [] });
            else if (it.sep)
              it.value = token;
            else
              Object.assign(it, { key: token, sep: [] });
            return;
          }
          default:
            yield* this.pop();
            yield* this.pop(token);
        }
        if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
          const last = token.items[token.items.length - 1];
          if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
            if (top.type === "document")
              top.end = last.start;
            else
              top.items.push({ start: last.start });
            token.items.splice(-1, 1);
          }
        }
      }
    }
    *stream() {
      switch (this.type) {
        case "directive-line":
          yield { type: "directive", offset: this.offset, source: this.source };
          return;
        case "byte-order-mark":
        case "space":
        case "comment":
        case "newline":
          yield this.sourceToken;
          return;
        case "doc-mode":
        case "doc-start": {
          const doc = {
            type: "document",
            offset: this.offset,
            start: []
          };
          if (this.type === "doc-start")
            doc.start.push(this.sourceToken);
          this.stack.push(doc);
          return;
        }
      }
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML stream`,
        source: this.source
      };
    }
    *document(doc) {
      if (doc.value)
        return yield* this.lineEnd(doc);
      switch (this.type) {
        case "doc-start": {
          if (findNonEmptyIndex(doc.start) !== -1) {
            yield* this.pop();
            yield* this.step();
          } else
            doc.start.push(this.sourceToken);
          return;
        }
        case "anchor":
        case "tag":
        case "space":
        case "comment":
        case "newline":
          doc.start.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(doc);
      if (bv)
        this.stack.push(bv);
      else {
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML document`,
          source: this.source
        };
      }
    }
    *scalar(scalar) {
      if (this.type === "map-value-ind") {
        const prev = getPrevProps(this.peek(2));
        const start = getFirstKeyStartProps(prev);
        let sep;
        if (scalar.end) {
          sep = scalar.end;
          sep.push(this.sourceToken);
          delete scalar.end;
        } else
          sep = [this.sourceToken];
        const map = {
          type: "block-map",
          offset: scalar.offset,
          indent: scalar.indent,
          items: [{ start, key: scalar, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map;
      } else
        yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
      switch (this.type) {
        case "space":
        case "comment":
        case "newline":
          scalar.props.push(this.sourceToken);
          return;
        case "scalar":
          scalar.source = this.source;
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine) {
            let nl = this.source.indexOf(`
`) + 1;
            while (nl !== 0) {
              this.onNewLine(this.offset + nl);
              nl = this.source.indexOf(`
`, nl) + 1;
            }
          }
          yield* this.pop();
          break;
        default:
          yield* this.pop();
          yield* this.step();
      }
    }
    *blockMap(map) {
      const it = map.items[map.items.length - 1];
      switch (this.type) {
        case "newline":
          this.onKeyLine = false;
          if (it.value) {
            const end = "end" in it.value ? it.value.end : undefined;
            const last = Array.isArray(end) ? end[end.length - 1] : undefined;
            if (last?.type === "comment")
              end?.push(this.sourceToken);
            else
              map.items.push({ start: [this.sourceToken] });
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "space":
        case "comment":
          if (it.value) {
            map.items.push({ start: [this.sourceToken] });
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            if (this.atIndentedComment(it.start, map.indent)) {
              const prev = map.items[map.items.length - 2];
              const end = prev?.value?.end;
              if (Array.isArray(end)) {
                Array.prototype.push.apply(end, it.start);
                end.push(this.sourceToken);
                map.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
      }
      if (this.indent >= map.indent) {
        const atMapIndent = !this.onKeyLine && this.indent === map.indent;
        const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
        let start = [];
        if (atNextItem && it.sep && !it.value) {
          const nl = [];
          for (let i = 0;i < it.sep.length; ++i) {
            const st = it.sep[i];
            switch (st.type) {
              case "newline":
                nl.push(i);
                break;
              case "space":
                break;
              case "comment":
                if (st.indent > map.indent)
                  nl.length = 0;
                break;
              default:
                nl.length = 0;
            }
          }
          if (nl.length >= 2)
            start = it.sep.splice(nl[1]);
        }
        switch (this.type) {
          case "anchor":
          case "tag":
            if (atNextItem || it.value) {
              start.push(this.sourceToken);
              map.items.push({ start });
              this.onKeyLine = true;
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "explicit-key-ind":
            if (!it.sep && !it.explicitKey) {
              it.start.push(this.sourceToken);
              it.explicitKey = true;
            } else if (atNextItem || it.value) {
              start.push(this.sourceToken);
              map.items.push({ start, explicitKey: true });
            } else {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [this.sourceToken], explicitKey: true }]
              });
            }
            this.onKeyLine = true;
            return;
          case "map-value-ind":
            if (it.explicitKey) {
              if (!it.sep) {
                if (includesToken(it.start, "newline")) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else {
                  const start2 = getFirstKeyStartProps(it.start);
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                  });
                }
              } else if (it.value) {
                map.items.push({ start: [], key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start, key: null, sep: [this.sourceToken] }]
                });
              } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                const start2 = getFirstKeyStartProps(it.start);
                const key = it.key;
                const sep = it.sep;
                sep.push(this.sourceToken);
                delete it.key;
                delete it.sep;
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key, sep }]
                });
              } else if (start.length > 0) {
                it.sep = it.sep.concat(start, this.sourceToken);
              } else {
                it.sep.push(this.sourceToken);
              }
            } else {
              if (!it.sep) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else if (it.value || atNextItem) {
                map.items.push({ start, key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [], key: null, sep: [this.sourceToken] }]
                });
              } else {
                it.sep.push(this.sourceToken);
              }
            }
            this.onKeyLine = true;
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs = this.flowScalar(this.type);
            if (atNextItem || it.value) {
              map.items.push({ start, key: fs, sep: [] });
              this.onKeyLine = true;
            } else if (it.sep) {
              this.stack.push(fs);
            } else {
              Object.assign(it, { key: fs, sep: [] });
              this.onKeyLine = true;
            }
            return;
          }
          default: {
            const bv = this.startBlockValue(map);
            if (bv) {
              if (bv.type === "block-seq") {
                if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                  yield* this.pop({
                    type: "error",
                    offset: this.offset,
                    message: "Unexpected block-seq-ind on same line with key",
                    source: this.source
                  });
                  return;
                }
              } else if (atMapIndent) {
                map.items.push({ start });
              }
              this.stack.push(bv);
              return;
            }
          }
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *blockSequence(seq) {
      const it = seq.items[seq.items.length - 1];
      switch (this.type) {
        case "newline":
          if (it.value) {
            const end = "end" in it.value ? it.value.end : undefined;
            const last = Array.isArray(end) ? end[end.length - 1] : undefined;
            if (last?.type === "comment")
              end?.push(this.sourceToken);
            else
              seq.items.push({ start: [this.sourceToken] });
          } else
            it.start.push(this.sourceToken);
          return;
        case "space":
        case "comment":
          if (it.value)
            seq.items.push({ start: [this.sourceToken] });
          else {
            if (this.atIndentedComment(it.start, seq.indent)) {
              const prev = seq.items[seq.items.length - 2];
              const end = prev?.value?.end;
              if (Array.isArray(end)) {
                Array.prototype.push.apply(end, it.start);
                end.push(this.sourceToken);
                seq.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
        case "anchor":
        case "tag":
          if (it.value || this.indent <= seq.indent)
            break;
          it.start.push(this.sourceToken);
          return;
        case "seq-item-ind":
          if (this.indent !== seq.indent)
            break;
          if (it.value || includesToken(it.start, "seq-item-ind"))
            seq.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
      }
      if (this.indent > seq.indent) {
        const bv = this.startBlockValue(seq);
        if (bv) {
          this.stack.push(bv);
          return;
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *flowCollection(fc) {
      const it = fc.items[fc.items.length - 1];
      if (this.type === "flow-error-end") {
        let top;
        do {
          yield* this.pop();
          top = this.peek(1);
        } while (top && top.type === "flow-collection");
      } else if (fc.end.length === 0) {
        switch (this.type) {
          case "comma":
          case "explicit-key-ind":
            if (!it || it.sep)
              fc.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
          case "map-value-ind":
            if (!it || it.value)
              fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            return;
          case "space":
          case "comment":
          case "newline":
          case "anchor":
          case "tag":
            if (!it || it.value)
              fc.items.push({ start: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              it.start.push(this.sourceToken);
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs = this.flowScalar(this.type);
            if (!it || it.value)
              fc.items.push({ start: [], key: fs, sep: [] });
            else if (it.sep)
              this.stack.push(fs);
            else
              Object.assign(it, { key: fs, sep: [] });
            return;
          }
          case "flow-map-end":
          case "flow-seq-end":
            fc.end.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(fc);
        if (bv)
          this.stack.push(bv);
        else {
          yield* this.pop();
          yield* this.step();
        }
      } else {
        const parent = this.peek(2);
        if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
          yield* this.pop();
          yield* this.step();
        } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          fixFlowSeqItems(fc);
          const sep = fc.end.splice(1, fc.end.length);
          sep.push(this.sourceToken);
          const map = {
            type: "block-map",
            offset: fc.offset,
            indent: fc.indent,
            items: [{ start, key: fc, sep }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map;
        } else {
          yield* this.lineEnd(fc);
        }
      }
    }
    flowScalar(type) {
      if (this.onNewLine) {
        let nl = this.source.indexOf(`
`) + 1;
        while (nl !== 0) {
          this.onNewLine(this.offset + nl);
          nl = this.source.indexOf(`
`, nl) + 1;
        }
      }
      return {
        type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
    }
    startBlockValue(parent) {
      switch (this.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return this.flowScalar(this.type);
        case "block-scalar-header":
          return {
            type: "block-scalar",
            offset: this.offset,
            indent: this.indent,
            props: [this.sourceToken],
            source: ""
          };
        case "flow-map-start":
        case "flow-seq-start":
          return {
            type: "flow-collection",
            offset: this.offset,
            indent: this.indent,
            start: this.sourceToken,
            items: [],
            end: []
          };
        case "seq-item-ind":
          return {
            type: "block-seq",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken] }]
          };
        case "explicit-key-ind": {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          start.push(this.sourceToken);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start, explicitKey: true }]
          };
        }
        case "map-value-ind": {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start, key: null, sep: [this.sourceToken] }]
          };
        }
      }
      return null;
    }
    atIndentedComment(start, indent) {
      if (this.type !== "comment")
        return false;
      if (this.indent <= indent)
        return false;
      return start.every((st) => st.type === "newline" || st.type === "space");
    }
    *documentEnd(docEnd) {
      if (this.type !== "doc-mode") {
        if (docEnd.end)
          docEnd.end.push(this.sourceToken);
        else
          docEnd.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
      }
    }
    *lineEnd(token) {
      switch (this.type) {
        case "comma":
        case "doc-start":
        case "doc-end":
        case "flow-seq-end":
        case "flow-map-end":
        case "map-value-ind":
          yield* this.pop();
          yield* this.step();
          break;
        case "newline":
          this.onKeyLine = false;
        case "space":
        case "comment":
        default:
          if (token.end)
            token.end.push(this.sourceToken);
          else
            token.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
      }
    }
  }
  exports.Parser = Parser;
});

// node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS((exports) => {
  var composer = require_composer();
  var Document = require_Document();
  var errors = require_errors();
  var log = require_log();
  var identity = require_identity();
  var lineCounter = require_line_counter();
  var parser = require_parser();
  function parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter || null;
    return { lineCounter: lineCounter$1, prettyErrors };
  }
  function parseAllDocuments(source, options = {}) {
    const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
    const composer$1 = new composer.Composer(options);
    const docs = Array.from(composer$1.compose(parser$1.parse(source)));
    if (prettyErrors && lineCounter2)
      for (const doc of docs) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
      }
    if (docs.length > 0)
      return docs;
    return Object.assign([], { empty: true }, composer$1.streamInfo());
  }
  function parseDocument(source, options = {}) {
    const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
    const composer$1 = new composer.Composer(options);
    let doc = null;
    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
      if (!doc)
        doc = _doc;
      else if (doc.options.logLevel !== "silent") {
        doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
        break;
      }
    }
    if (prettyErrors && lineCounter2) {
      doc.errors.forEach(errors.prettifyError(source, lineCounter2));
      doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
    }
    return doc;
  }
  function parse(src, reviver, options) {
    let _reviver = undefined;
    if (typeof reviver === "function") {
      _reviver = reviver;
    } else if (options === undefined && reviver && typeof reviver === "object") {
      options = reviver;
    }
    const doc = parseDocument(src, options);
    if (!doc)
      return null;
    doc.warnings.forEach((warning) => log.warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
      if (doc.options.logLevel !== "silent")
        throw doc.errors[0];
      else
        doc.errors = [];
    }
    return doc.toJS(Object.assign({ reviver: _reviver }, options));
  }
  function stringify(value, replacer, options) {
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === undefined && replacer) {
      options = replacer;
    }
    if (typeof options === "string")
      options = options.length;
    if (typeof options === "number") {
      const indent = Math.round(options);
      options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };
    }
    if (value === undefined) {
      const { keepUndefined } = options ?? replacer ?? {};
      if (!keepUndefined)
        return;
    }
    if (identity.isDocument(value) && !_replacer)
      return value.toString(options);
    return new Document.Document(value, _replacer, options).toString(options);
  }
  exports.parse = parse;
  exports.parseAllDocuments = parseAllDocuments;
  exports.parseDocument = parseDocument;
  exports.stringify = stringify;
});

// node_modules/yaml/dist/index.js
var composer, Document, Schema, errors, Alias, identity, Pair, Scalar, YAMLMap, YAMLSeq, cst, lexer, lineCounter, parser, publicApi, visit, $Composer, $Document, $Schema, $YAMLError, $YAMLParseError, $YAMLWarning, $Alias, $isAlias, $isCollection, $isDocument, $isMap, $isNode, $isPair, $isScalar, $isSeq, $Pair, $Scalar, $YAMLMap, $YAMLSeq, $Lexer, $LineCounter, $Parser, $parse, $parseAllDocuments, $parseDocument, $stringify, $visit, $visitAsync;
var init_dist = __esm(() => {
  composer = require_composer();
  Document = require_Document();
  Schema = require_Schema();
  errors = require_errors();
  Alias = require_Alias();
  identity = require_identity();
  Pair = require_Pair();
  Scalar = require_Scalar();
  YAMLMap = require_YAMLMap();
  YAMLSeq = require_YAMLSeq();
  cst = require_cst();
  lexer = require_lexer();
  lineCounter = require_line_counter();
  parser = require_parser();
  publicApi = require_public_api();
  visit = require_visit();
  $Composer = composer.Composer;
  $Document = Document.Document;
  $Schema = Schema.Schema;
  $YAMLError = errors.YAMLError;
  $YAMLParseError = errors.YAMLParseError;
  $YAMLWarning = errors.YAMLWarning;
  $Alias = Alias.Alias;
  $isAlias = identity.isAlias;
  $isCollection = identity.isCollection;
  $isDocument = identity.isDocument;
  $isMap = identity.isMap;
  $isNode = identity.isNode;
  $isPair = identity.isPair;
  $isScalar = identity.isScalar;
  $isSeq = identity.isSeq;
  $Pair = Pair.Pair;
  $Scalar = Scalar.Scalar;
  $YAMLMap = YAMLMap.YAMLMap;
  $YAMLSeq = YAMLSeq.YAMLSeq;
  $Lexer = lexer.Lexer;
  $LineCounter = lineCounter.LineCounter;
  $Parser = parser.Parser;
  $parse = publicApi.parse;
  $parseAllDocuments = publicApi.parseAllDocuments;
  $parseDocument = publicApi.parseDocument;
  $stringify = publicApi.stringify;
  $visit = visit.visit;
  $visitAsync = visit.visitAsync;
});

// src/yaml/validation-engine.ts
var exports_validation_engine = {};
__export(exports_validation_engine, {
  ValidationEngine: () => ValidationEngine
});

class ValidationEngine {
  validate(agent) {
    switch (agent.format) {
      case "base":
        return this.validateBase(agent.frontmatter);
      case "claude-code":
        return this.validateClaudeCode(agent.frontmatter);
      case "opencode":
        return this.validateOpenCode(agent.frontmatter);
      default:
        return {
          valid: false,
          errors: [
            {
              message: `Unknown agent format: ${agent.format}`,
              severity: "error"
            }
          ],
          warnings: []
        };
    }
  }
  validateBase(agent) {
    const errors2 = [];
    const warnings = [];
    this.validateRequiredField(agent.name, "name", "Name is required and cannot be empty", errors2);
    this.validateRequiredField(agent.description, "description", "Description is required and cannot be empty", errors2);
    if (agent.name && !/^[a-z0-9-_]+$/.test(agent.name)) {
      warnings.push({
        field: "name",
        message: "Name should use lowercase letters, numbers, hyphens, and underscores only"
      });
    }
    this.validateDescriptionLength(agent.description, warnings);
    this.validateMode(agent.mode, errors2);
    this.validateTemperature(agent.temperature, 0, 2, errors2);
    this.validateModel(agent.model, warnings);
    this.validateToolsObject(agent.tools, errors2, warnings);
    return {
      valid: errors2.length === 0,
      errors: errors2,
      warnings
    };
  }
  validateClaudeCode(agent) {
    const errors2 = [];
    const warnings = [];
    const agentKeys = Object.keys(agent);
    const invalidFields = agentKeys.filter((key) => !CLAUDE_CODE_AGENT_FIELDS.includes(key));
    if (invalidFields.length > 0) {
      errors2.push({
        message: `Invalid fields for Claude Code v2.x.x: ${invalidFields.join(", ")}. Only allowed: ${CLAUDE_CODE_AGENT_FIELDS.join(", ")}`,
        severity: "error"
      });
    }
    this.validateRequiredField(agent.name, "name", "Name is required and cannot be empty", errors2);
    this.validateRequiredField(agent.description, "description", "Description is required and cannot be empty", errors2);
    if (agent.name && !/^[a-z0-9-_]+$/.test(agent.name)) {
      warnings.push({
        field: "name",
        message: "Name should use lowercase letters, numbers, hyphens, and underscores only"
      });
    }
    this.validateDescriptionLength(agent.description, warnings);
    if (agent.model) {
      if (!CLAUDE_CODE_MODELS.includes(agent.model)) {
        errors2.push({
          field: "model",
          message: `Invalid model '${agent.model}'. Must be one of: ${CLAUDE_CODE_MODELS.join(", ")}`,
          severity: "error"
        });
      }
    }
    if (agent.tools !== undefined) {
      if (typeof agent.tools !== "string") {
        errors2.push({
          field: "tools",
          message: "Tools must be a comma-separated string for Claude Code format",
          severity: "error"
        });
      } else if (agent.tools.trim() === "") {
        warnings.push({
          field: "tools",
          message: "No tools specified, agent may have limited functionality"
        });
      }
    }
    return {
      valid: errors2.length === 0,
      errors: errors2,
      warnings
    };
  }
  validateOpenCode(agent) {
    const errors2 = [];
    const warnings = [];
    const validFields = [...OPENCODE_AGENT_REQUIRED, ...OPENCODE_AGENT_OPTIONAL];
    const agentKeys = Object.keys(agent);
    const invalidFields = agentKeys.filter((key) => !validFields.includes(key));
    if (invalidFields.length > 0) {
      warnings.push({
        message: `Non-standard fields for OpenCode: ${invalidFields.join(", ")}. May cause compatibility issues.`
      });
    }
    this.validateRequiredField(agent.name, "name", "Name is required for OpenCode format", errors2);
    this.validateRequiredField(agent.description, "description", "Description is required and cannot be empty", errors2);
    this.validateRequiredField(agent.mode, "mode", "Mode is required and must be one of: primary, subagent, all", errors2);
    if (agent.name && !/^[a-z0-9-_]+$/.test(agent.name)) {
      warnings.push({
        field: "name",
        message: "Name should use lowercase letters, numbers, hyphens, and underscores only"
      });
    }
    this.validateDescriptionLength(agent.description, warnings);
    if (agent.mode && !OPENCODE_MODES.includes(agent.mode)) {
      errors2.push({
        field: "mode",
        message: `Invalid mode '${agent.mode}'. Must be one of: ${OPENCODE_MODES.join(", ")}`,
        severity: "error"
      });
    }
    if (agent.model) {
      if (typeof agent.model !== "string") {
        errors2.push({
          field: "model",
          message: "Model must be a string",
          severity: "error"
        });
      } else if (!agent.model.includes("/") && !agent.model.includes("-")) {
        warnings.push({
          field: "model",
          message: "Model should use provider/model format (e.g., anthropic/claude-sonnet-4)"
        });
      }
    }
    if (agent.temperature !== undefined) {
      if (typeof agent.temperature !== "number") {
        errors2.push({
          field: "temperature",
          message: "Temperature must be a number",
          severity: "error"
        });
      } else if (agent.temperature < 0 || agent.temperature > 2) {
        errors2.push({
          field: "temperature",
          message: "Temperature must be between 0 and 2",
          severity: "error"
        });
      }
    }
    if (agent.tools !== undefined) {
      this.validateToolsObject(agent.tools, errors2, warnings);
    }
    if (agent.permission !== undefined) {
      this.validateOpenCodePermissions(agent.permission, errors2);
    }
    if (!agent.tools && !agent.permission) {
      warnings.push({
        message: "Neither tools nor permission specified, agent may have limited functionality"
      });
    }
    if (agent.tags !== undefined) {
      this.validateTagsArray(agent.tags, errors2);
    }
    if (agent.category && typeof agent.category !== "string") {
      errors2.push({
        field: "category",
        message: "Category must be a string",
        severity: "error"
      });
    }
    return {
      valid: errors2.length === 0,
      errors: errors2,
      warnings
    };
  }
  validateBatch(agents) {
    const results = agents.map((agent) => ({
      ...this.validate(agent),
      agent
    }));
    const summary = {
      valid: results.filter((r) => r.valid).length,
      errors: results.reduce((sum, r) => sum + r.errors.length, 0),
      warnings: results.reduce((sum, r) => sum + r.warnings.length, 0)
    };
    return { results, summary };
  }
  validateRequiredField(value, field, message, errors2) {
    if (!value || typeof value === "string" && value.trim() === "") {
      errors2.push({
        field,
        message,
        severity: "error"
      });
    }
  }
  validateDescriptionLength(description, warnings) {
    if (!description)
      return;
    if (description.length < 10) {
      warnings.push({
        field: "description",
        message: "Description is very short, consider adding more detail"
      });
    }
    if (description.length > 500) {
      warnings.push({
        field: "description",
        message: "Description is very long, consider making it more concise"
      });
    }
  }
  validateMode(mode, errors2) {
    if (mode && !["subagent", "primary", "all"].includes(mode)) {
      errors2.push({
        field: "mode",
        message: "Mode must be one of: subagent, primary, all",
        severity: "error"
      });
    }
  }
  validateTemperature(temperature, min, max, errors2) {
    if (temperature !== undefined) {
      if (typeof temperature !== "number") {
        errors2.push({
          field: "temperature",
          message: "Temperature must be a number",
          severity: "error"
        });
      } else if (temperature < min || temperature > max) {
        errors2.push({
          field: "temperature",
          message: `Temperature must be between ${min} and ${max}`,
          severity: "error"
        });
      }
    }
  }
  validateModel(model, warnings) {
    if (model) {
      if (typeof model !== "string") {
        warnings.push({
          field: "model",
          message: "Model should be a string"
        });
      } else if (!model.includes("/") && !model.includes("-")) {
        warnings.push({
          field: "model",
          message: "Model format seems unusual, expected provider/model or provider-model format"
        });
      }
    }
  }
  validateToolsObject(tools, errors2, warnings) {
    if (!tools)
      return;
    if (typeof tools !== "object" || Array.isArray(tools)) {
      errors2.push({
        field: "tools",
        message: "Tools must be an object with tool names as keys and boolean values",
        severity: "error"
      });
      return;
    }
    for (const [toolName, toolValue] of Object.entries(tools)) {
      if (typeof toolValue !== "boolean") {
        errors2.push({
          field: `tools.${toolName}`,
          message: `Tool '${toolName}' must have a boolean value`,
          severity: "error"
        });
      }
    }
    const enabledTools = Object.entries(tools).filter(([_, enabled]) => enabled === true).map(([name, _]) => name);
    if (enabledTools.length === 0) {
      warnings.push({
        field: "tools",
        message: "No tools are enabled, agent may have limited functionality"
      });
    }
    this.validateToolBalance(tools, warnings);
  }
  validateToolBalance(tools, warnings) {
    const hasRead = tools.read === true;
    const hasWrite = tools.write === true || tools.edit === true;
    if (hasWrite && !hasRead) {
      warnings.push({
        field: "tools",
        message: "Agent can write/edit but not read files, which may cause issues"
      });
    }
  }
  validateOpenCodePermissions(permission, errors2) {
    if (!permission)
      return;
    if (typeof permission !== "object" || Array.isArray(permission)) {
      errors2.push({
        field: "permission",
        message: "Permission must be an object with action names as keys and permission values",
        severity: "error"
      });
      return;
    }
    for (const [action, permValue] of Object.entries(permission)) {
      if (!OPENCODE_PERMISSION_VALUES.includes(permValue)) {
        errors2.push({
          field: `permission.${action}`,
          message: `Permission for '${action}' must be one of: ${OPENCODE_PERMISSION_VALUES.join(", ")}`,
          severity: "error"
        });
      }
    }
    const missingPermissions = OPENCODE_PERMISSIONS.filter((perm) => !(perm in permission));
    if (missingPermissions.length > 0) {
      errors2.push({
        field: "permission",
        message: `Missing required OpenCode permissions: ${missingPermissions.join(", ")}`,
        severity: "error"
      });
    }
  }
  validateTagsArray(tags, errors2) {
    if (!tags)
      return;
    if (!Array.isArray(tags)) {
      errors2.push({
        field: "tags",
        message: "Tags must be an array",
        severity: "error"
      });
      return;
    }
    for (let i = 0;i < tags.length; i++) {
      if (typeof tags[i] !== "string") {
        errors2.push({
          field: `tags[${i}]`,
          message: "All tags must be strings",
          severity: "error"
        });
      }
    }
  }
}
var CLAUDE_CODE_AGENT_FIELDS, CLAUDE_CODE_MODELS, OPENCODE_AGENT_REQUIRED, OPENCODE_AGENT_OPTIONAL, OPENCODE_MODES, OPENCODE_PERMISSIONS, OPENCODE_PERMISSION_VALUES;
var init_validation_engine = __esm(() => {
  CLAUDE_CODE_AGENT_FIELDS = ["name", "description", "tools", "model"];
  CLAUDE_CODE_MODELS = ["inherit", "sonnet", "opus", "haiku"];
  OPENCODE_AGENT_REQUIRED = ["name", "description", "mode"];
  OPENCODE_AGENT_OPTIONAL = [
    "model",
    "temperature",
    "tools",
    "permission",
    "tags",
    "category",
    "allowed_directories"
  ];
  OPENCODE_MODES = ["primary", "subagent", "all"];
  OPENCODE_PERMISSIONS = ["edit", "bash", "webfetch"];
  OPENCODE_PERMISSION_VALUES = ["allow", "ask", "deny"];
});

// src/yaml/array-parser.ts
class ArrayParser {
  parseInlineArray(arrayString) {
    const result = {
      success: true,
      items: [],
      errors: []
    };
    if (!arrayString || typeof arrayString !== "string") {
      result.errors.push("Invalid array string provided");
      result.success = false;
      return result;
    }
    const content = arrayString.trim();
    if (!content.startsWith("[") || !content.endsWith("]")) {
      result.errors.push("Array must be enclosed in brackets [ ]");
      result.success = false;
      return result;
    }
    const innerContent = content.slice(1, -1).trim();
    if (innerContent === "") {
      return result;
    }
    try {
      const parsedItems = this.parseCsvLine(innerContent);
      result.items = parsedItems;
    } catch (error) {
      result.errors.push(`Failed to parse array: ${error}`);
      result.success = false;
    }
    return result;
  }
  parseYamlList(lines) {
    const result = {
      success: true,
      items: [],
      errors: []
    };
    for (let i = 0;i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line)
        continue;
      let item;
      if (line.startsWith("- ")) {
        item = line.slice(2);
      } else if (line.startsWith("-")) {
        item = line.slice(1).trim();
      } else {
        result.errors.push(`Line ${i + 1}: Invalid YAML list syntax. Expected '- item'`);
        result.success = false;
        continue;
      }
      if (item.startsWith('"') && item.endsWith('"') || item.startsWith("'") && item.endsWith("'")) {
        item = item.slice(1, -1);
        item = item.replace(/\\"/g, '"').replace(/\\'/g, "'");
      }
      result.items.push(item);
    }
    return result;
  }
  serializeInlineArray(items) {
    if (!items || items.length === 0) {
      return "[]";
    }
    const serializedItems = items.map((item) => {
      if (item.includes(",") || item.includes(" ") || this.needsQuoting(item)) {
        const escaped = item.replace(/\\/g, "\\\\").replace(/"/g, "\\\"");
        return `"${escaped}"`;
      }
      return item;
    });
    return `[${serializedItems.join(", ")}]`;
  }
  serializeYamlList(items) {
    if (!items || items.length === 0) {
      return "";
    }
    return items.map((item) => {
      if (this.needsQuoting(item) || item.includes(" ")) {
        const escaped = item.replace(/\\/g, "\\\\").replace(/"/g, "\\\"");
        return `- "${escaped}"`;
      } else {
        return `- ${item}`;
      }
    }).join(`
`) + `
`;
  }
  parseCsvLine(line) {
    const result = [];
    let current = "";
    let inQuotes = false;
    let quoteChar = "";
    let i = 0;
    while (i < line.length) {
      const char = line[i];
      const nextChar = line[i + 1];
      if (!inQuotes) {
        if (char === '"' || char === "'") {
          inQuotes = true;
          quoteChar = char;
        } else if (char === ",") {
          result.push(current.trim());
          current = "";
        } else {
          current += char;
        }
      } else {
        if (char === "\\" && nextChar === quoteChar) {
          current += quoteChar;
          i++;
        } else if (char === quoteChar) {
          if (nextChar === quoteChar) {
            current += char;
            i++;
          } else {
            inQuotes = false;
            quoteChar = "";
          }
        } else {
          current += char;
        }
      }
      i++;
    }
    if (current.trim()) {
      result.push(current.trim());
    }
    if (inQuotes) {
      throw new Error("Unclosed quote in array");
    }
    return result;
  }
  needsQuoting(str) {
    return str.includes(":") || str.includes("{") || str.includes("}") || str.includes("[") || str.includes("]") || str.includes(",") || str.includes("&") || str.includes("*") || str.includes("#") || str.includes("?") || str.includes("|") || str.includes("-") || str.includes("<") || str.includes(">") || str.includes("=") || str.includes("!") || str.includes("%") || str.includes("@") || str.includes("`") || str.includes("\\") || str.includes(`
`) || str.includes("\t") || str.startsWith(" ") || str.endsWith(" ") || str === "" || /^\d/.test(str) || str.toLowerCase() === "yes" || str.toLowerCase() === "no" || str.toLowerCase() === "true" || str.toLowerCase() === "false" || str.toLowerCase() === "null" || str.toLowerCase() === "undefined";
  }
}

// src/yaml/yaml-processor.ts
var exports_yaml_processor = {};
__export(exports_yaml_processor, {
  YamlProcessor: () => YamlProcessor
});
import { mkdir } from "fs/promises";

class YamlProcessor {
  validationEngine;
  arrayParser;
  constructor() {
    this.validationEngine = new ValidationEngine;
    this.arrayParser = new ArrayParser;
  }
  parse(content) {
    try {
      const frontmatterMatch = content.match(/^---\s*\n(.*?)\n---\s*\n(.*)$/s);
      if (!frontmatterMatch) {
        const altMatch = content.match(/^---\s*\n---\s*\n(.*)$/s);
        if (altMatch) {
          return {
            success: true,
            data: {
              frontmatter: {},
              body: (altMatch[1] || "").trim(),
              rawContent: content
            }
          };
        }
        return {
          success: false,
          error: {
            message: "No frontmatter found in content",
            line: 1,
            column: 1
          }
        };
      }
      const frontmatterText = frontmatterMatch[1];
      let body = frontmatterMatch[2] || "";
      let frontmatter;
      if (frontmatterText.trim() === "") {
        frontmatter = {};
      } else {
        frontmatter = $parse(frontmatterText) || {};
      }
      let secondFrontmatterMatch = null;
      const codeBlockPattern = /```[\s\S]*?```/g;
      const bodyWithoutCodeBlocks = body.replace(codeBlockPattern, "[CODE_BLOCK]");
      secondFrontmatterMatch = bodyWithoutCodeBlocks.match(/^---[\s]*\n([\s\S]*?)\n---[\s]*(\n[\s\S]*)?$/);
      if (!secondFrontmatterMatch) {
        const possibleMatch = bodyWithoutCodeBlocks.match(/^[\s]*([\s\S]*?)\n---[\s]*(\n[\s\S]*)?$/);
        if (possibleMatch && possibleMatch[1] && /^[a-zA-Z_][a-zA-Z0-9_]*\s*:/m.test(possibleMatch[1])) {
          secondFrontmatterMatch = possibleMatch;
        }
      }
      if (secondFrontmatterMatch) {
        const secondFrontmatterText = secondFrontmatterMatch[1];
        const secondBody = secondFrontmatterMatch[2] || "";
        let secondFrontmatter;
        if (secondFrontmatterText.trim() === "") {
          secondFrontmatter = {};
        } else {
          secondFrontmatter = $parse(secondFrontmatterText) || {};
        }
        frontmatter = { ...frontmatter, ...secondFrontmatter };
        body = secondBody;
      }
      return {
        success: true,
        data: {
          frontmatter,
          body: body.trim(),
          rawContent: content
        }
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        error: {
          message: `YAML parsing failed: ${errorMessage}`,
          line: 1,
          column: 1
        }
      };
    }
  }
  serialize(entity) {
    try {
      const cleanFrontmatter = this.cleanFrontmatter(entity.frontmatter);
      const yamlOptions = {
        indent: 2,
        lineWidth: 0,
        collectionStyle: "block",
        defaultFlowStyle: null,
        defaultStringType: "PLAIN",
        skipInvalid: false
      };
      const yamlContent = `---
${$stringify(cleanFrontmatter, yamlOptions)}---
${entity.content}`;
      return {
        success: true,
        data: yamlContent
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        error: {
          message: `YAML serialization failed: ${errorMessage}`,
          line: 1,
          column: 1
        }
      };
    }
  }
  detectFormat(frontmatter) {
    if (frontmatter.model && frontmatter.temperature !== undefined) {
      return "opencode";
    }
    if (frontmatter.tools && typeof frontmatter.tools === "string") {
      return "claude-code";
    }
    return "base";
  }
  validate(agent) {
    return this.validationEngine.validate(agent);
  }
  async processWithErrorHandling(operation, context) {
    try {
      const data = await operation();
      return { success: true, data };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        error: {
          message: context ? `${context} failed: ${errorMessage}` : errorMessage,
          line: 1,
          column: 1
        }
      };
    }
  }
  cleanFrontmatter(frontmatter) {
    const cleaned = {};
    for (const [key, value] of Object.entries(frontmatter)) {
      if (value !== null && value !== undefined) {
        if (typeof value === "object" && !Array.isArray(value)) {
          cleaned[key] = this.cleanFrontmatter(value);
        } else {
          cleaned[key] = value;
        }
      }
    }
    return cleaned;
  }
  async ensureDirectory(dirPath) {
    try {
      await mkdir(dirPath, { recursive: true });
      return { success: true, data: undefined };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return {
        success: false,
        error: {
          message: `Failed to create directory ${dirPath}: ${errorMessage}`,
          line: 1,
          column: 1
        }
      };
    }
  }
}
var init_yaml_processor = __esm(() => {
  init_dist();
  init_validation_engine();
});

// src/conversion/agent-parser.ts
var exports_agent_parser = {};
__export(exports_agent_parser, {
  serializeSkill: () => serializeSkill,
  serializeCommand: () => serializeCommand,
  serializeAgent: () => serializeAgent,
  parseSkillFile: () => parseSkillFile,
  parseCommandFile: () => parseCommandFile,
  parseAgentsFromDirectory: () => parseAgentsFromDirectory,
  parseAgentFile: () => parseAgentFile,
  normalizePermissionFormat: () => normalizePermissionFormat
});
import { basename } from "path";
function detectFormatFromContent(content) {
  const processor = new YamlProcessor;
  const result = processor.parse(content);
  if (!result.success) {
    return "base";
  }
  const frontmatter = result.data.frontmatter;
  if (frontmatter.description && frontmatter.mode) {
    return "opencode";
  }
  if (frontmatter.name && frontmatter.tags && Array.isArray(frontmatter.tags) && frontmatter.category) {
    return "opencode";
  }
  if (frontmatter.role && !frontmatter.mode) {
    return "claude-code";
  }
  return "base";
}
function flattenNestedPermission(permission) {
  if (typeof permission === "string") {
    return permission;
  }
  if (typeof permission === "object" && permission !== null) {
    if ("*" in permission) {
      return permission["*"];
    }
    const values = Object.values(permission);
    if (values.includes("allow")) {
      return "allow";
    }
    if (values.includes("ask")) {
      return "ask";
    }
    return "deny";
  }
  return "deny";
}
function normalizePermissionFormat(frontmatter) {
  if (frontmatter.tools && typeof frontmatter.tools === "object" && frontmatter.permission && typeof frontmatter.permission === "object") {
    const permissions = {
      read: flattenNestedPermission(frontmatter.permission.read || booleanToPermissionString(frontmatter.tools.read || false)),
      write: flattenNestedPermission(frontmatter.permission.write || booleanToPermissionString(frontmatter.tools.write || false)),
      edit: flattenNestedPermission(frontmatter.permission.edit || booleanToPermissionString(frontmatter.tools.edit || false)),
      bash: flattenNestedPermission(frontmatter.permission.bash || booleanToPermissionString(frontmatter.tools.bash || false)),
      webfetch: flattenNestedPermission(frontmatter.permission.webfetch || booleanToPermissionString(frontmatter.tools.webfetch !== false))
    };
    const {
      _edit,
      _bash,
      _patch,
      _read,
      _grep,
      _glob,
      _list,
      _webfetch,
      _write,
      _tools,
      ...cleanFrontmatter
    } = frontmatter;
    return {
      ...cleanFrontmatter,
      permission: permissions
    };
  }
  if (frontmatter.tools && typeof frontmatter.tools === "object") {
    const permissions = {
      read: booleanToPermissionString(frontmatter.tools.read || false),
      write: booleanToPermissionString(frontmatter.tools.write || false),
      edit: booleanToPermissionString(frontmatter.tools.edit || false),
      bash: booleanToPermissionString(frontmatter.tools.bash || false),
      webfetch: booleanToPermissionString(frontmatter.tools.webfetch !== false)
    };
    const {
      _edit,
      _bash,
      _patch,
      _read,
      _grep,
      _glob,
      _list,
      _webfetch,
      _write,
      ...cleanFrontmatter
    } = frontmatter;
    return {
      ...cleanFrontmatter,
      permission: permissions
    };
  }
  if (frontmatter.permission && typeof frontmatter.permission === "object") {
    const flattenedPermissions = {};
    for (const [key, value] of Object.entries(frontmatter.permission)) {
      flattenedPermissions[key] = flattenNestedPermission(value);
    }
    const {
      _edit,
      _bash,
      _patch,
      _read,
      _grep,
      _glob,
      _list,
      _webfetch,
      _write,
      ...cleanFrontmatter
    } = frontmatter;
    return {
      ...cleanFrontmatter,
      permission: flattenedPermissions
    };
  }
  return frontmatter;
}
function booleanToPermissionString(value) {
  return value ? "allow" : "deny";
}
function parseFrontmatter(content) {
  const processor = new YamlProcessor;
  const result = processor.parse(content);
  if (!result.success) {
    throw new Error(result.error.message);
  }
  return {
    frontmatter: result.data.frontmatter,
    body: result.data.body
  };
}
async function parseAgentFile(filePath, format) {
  const parseCache = globalPerformanceMonitor.getParseCache();
  const cacheKey = `${filePath}:${format}`;
  const cached = await parseCache.get(cacheKey);
  if (cached) {
    if ("frontmatter" in cached) {
      return cached;
    } else {
      throw new Error(cached.message);
    }
  }
  const parseStart = performance.now();
  const content = await globalFileReader.readFile(filePath);
  try {
    const { frontmatter, body } = parseFrontmatter(content);
    if (!frontmatter.description) {
      throw new Error("Agent must have a description field");
    }
    if (!frontmatter.name) {
      frontmatter.name = basename(filePath, ".md");
    }
    const normalizedFrontmatter = format === "opencode" ? normalizePermissionFormat(frontmatter) : frontmatter;
    const _isCommand = normalizedFrontmatter.mode === "command";
    const entity = {
      name: basename(filePath, ".md"),
      format,
      frontmatter: normalizedFrontmatter,
      content: body,
      filePath
    };
    await parseCache.set(cacheKey, entity);
    const parseTime = performance.now() - parseStart;
    globalPerformanceMonitor.updateMetrics({ agentParseTime: parseTime });
    return entity;
  } catch (error) {
    try {
      const fallbackResult = parseWithFallback(content);
      if (fallbackResult.success) {
        const frontmatter = fallbackResult.data.frontmatter;
        if (!frontmatter.description) {
          throw new Error("Agent must have a description field");
        }
        const _isCommand = frontmatter.mode === "command";
        const entity = {
          name: frontmatter.name || basename(filePath, ".md"),
          format,
          frontmatter,
          content: fallbackResult.data.body,
          filePath
        };
        return entity;
      }
    } catch {
      const parseError2 = {
        message: `Failed to parse agent file ${filePath}: ${error.message}`,
        filePath
      };
      await parseCache.setError(filePath, parseError2);
      throw new Error(parseError2.message);
    }
    const parseError = {
      message: `Failed to parse agent file ${filePath}: ${error.message}`,
      filePath
    };
    await parseCache.setError(filePath, parseError);
    throw new Error(parseError.message);
  }
}
function parseWithFallback(content) {
  try {
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
    if (!frontmatterMatch) {
      return { success: false };
    }
    const frontmatterText = frontmatterMatch[1];
    const body = frontmatterMatch[2] || "";
    const frontmatter = {};
    const lines = frontmatterText.split(`
`);
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith("#"))
        continue;
      const colonIndex = trimmed.indexOf(":");
      if (colonIndex > 0) {
        const key = trimmed.slice(0, colonIndex).trim();
        const value = trimmed.slice(colonIndex + 1).trim();
        if (key && value) {
          try {
            frontmatter[key] = JSON.parse(value);
          } catch {
            frontmatter[key] = value;
          }
        }
      }
    }
    return { success: true, data: { frontmatter, body } };
  } catch {
    return { success: false };
  }
}
async function parseAgentsFromDirectory(directory, format) {
  const { readdir: readdir2 } = await import("fs/promises");
  const { join: join3 } = await import("path");
  const { existsSync: existsSync4 } = await import("fs");
  const agents = [];
  const errors2 = [];
  if (!existsSync4(directory)) {
    return { agents, errors: errors2 };
  }
  try {
    const files = await readdir2(directory);
    for (const item of files) {
      const itemPath = join3(directory, item);
      const stat2 = await import("fs/promises").then((fs) => fs.stat(itemPath));
      if (stat2.isDirectory()) {
        try {
          const subdirAgents = await parseAgentsFromDirectory(itemPath, format);
          agents.push(...subdirAgents.agents);
          errors2.push(...subdirAgents.errors);
        } catch (error) {
          errors2.push({
            message: `Failed to parse subdirectory ${item}: ${error.message}`,
            filePath: itemPath
          });
        }
      } else if (item.endsWith(".md") && !item.startsWith("README")) {
        try {
          let actualFormat = format;
          if (format === "auto") {
            const content2 = await globalFileReader.readFile(itemPath);
            actualFormat = detectFormatFromContent(content2);
          }
          const content = await globalFileReader.readFile(itemPath);
          const { frontmatter } = parseFrontmatter(content);
          const isLikelyCommand = itemPath.includes("/command/") || frontmatter.inputs || frontmatter.outputs || frontmatter.cache_strategy || frontmatter.success_signals || frontmatter.failure_modes || frontmatter.command_schema_version || frontmatter.mode === "command";
          let entity;
          if (isLikelyCommand && (actualFormat === "base" || actualFormat === "opencode")) {
            entity = await parseCommandFile(itemPath, actualFormat);
          } else {
            entity = await parseAgentFile(itemPath, actualFormat);
          }
          agents.push(entity);
        } catch (error) {
          errors2.push({
            message: error.message,
            filePath: itemPath
          });
        }
      }
    }
  } catch (error) {
    errors2.push({
      message: `Failed to read directory ${directory}: ${error.message}`,
      filePath: directory
    });
  }
  return { agents, errors: errors2 };
}
function serializeAgent(agent) {
  const processor = new YamlProcessor;
  const result = processor.serialize(agent);
  if (!result.success) {
    throw new Error(result.error.message);
  }
  return result.data;
}
async function parseCommandFile(filePath, format) {
  const parseStart = performance.now();
  const content = await globalFileReader.readFile(filePath);
  try {
    const { frontmatter, body } = parseFrontmatter(content);
    if (!frontmatter.description) {
      throw new Error("Command must have a description field");
    }
    if (!frontmatter.name) {
      frontmatter.name = basename(filePath, ".md");
    }
    if (!frontmatter.mode) {
      frontmatter.mode = "command";
    }
    const command = {
      name: basename(filePath, ".md"),
      format,
      frontmatter,
      content: body,
      filePath
    };
    const parseTime = performance.now() - parseStart;
    globalPerformanceMonitor.updateMetrics({ agentParseTime: parseTime });
    return command;
  } catch (error) {
    try {
      const fallbackResult = parseWithFallback(content);
      if (fallbackResult.success) {
        const frontmatter = fallbackResult.data.frontmatter;
        if (!frontmatter.description) {
          throw new Error("Command must have a description field");
        }
        if (!frontmatter.mode) {
          frontmatter.mode = "command";
        }
        const command = {
          name: frontmatter.name || basename(filePath, ".md"),
          format,
          frontmatter,
          content: fallbackResult.data.body,
          filePath
        };
        return command;
      }
    } catch {
      throw new Error(`Failed to parse command file ${filePath}: ${error.message}`);
    }
    throw new Error(`Failed to parse command file ${filePath}: ${error.message}`);
  }
}
function serializeCommand(command) {
  const processor = new YamlProcessor;
  const result = processor.serialize(command);
  if (!result.success) {
    throw new Error(result.error.message);
  }
  return result.data;
}
async function parseSkillFile(filePath, format = "base") {
  const content = await globalFileReader.readFile(filePath);
  try {
    const processor = new YamlProcessor;
    const result = processor.parse(content);
    if (!result.success) {
      throw new Error(result.error.message);
    }
    const frontmatter = result.data.frontmatter;
    if (!frontmatter.name) {
      throw new Error("Skill must have a name field");
    }
    if (!frontmatter.description) {
      throw new Error("Skill must have a description field");
    }
    if (frontmatter.noReply === undefined) {
      throw new Error("Skill must have a noReply field");
    }
    if (frontmatter.noReply !== true) {
      throw new Error("Skill noReply field must be true for message insertion persistence");
    }
    const entity = {
      name: frontmatter.name,
      format,
      frontmatter,
      content: result.data.body,
      filePath
    };
    return entity;
  } catch (error) {
    try {
      const fallbackResult = parseWithFallback(content);
      if (fallbackResult.success) {
        const frontmatter = fallbackResult.data.frontmatter;
        if (!frontmatter.name) {
          throw new Error("Skill must have a name field");
        }
        if (!frontmatter.description) {
          throw new Error("Skill must have a description field");
        }
        if (frontmatter.noReply !== true) {
          throw new Error("Skill noReply field must be true");
        }
        const entity = {
          name: frontmatter.name,
          format,
          frontmatter,
          content: fallbackResult.data.body,
          filePath
        };
        return entity;
      }
    } catch {
      throw new Error(`Failed to parse skill file ${filePath}: ${error.message}`);
    }
    throw new Error(`Failed to parse skill file ${filePath}: ${error.message}`);
  }
}
function serializeSkill(skill) {
  const processor = new YamlProcessor;
  const result = processor.serialize(skill);
  if (!result.success) {
    throw new Error(result.error.message);
  }
  return result.data;
}
var init_agent_parser = __esm(() => {
  init_performance();
  init_yaml_processor();
});

// src/conversion/format-converter.ts
var exports_format_converter = {};
__export(exports_format_converter, {
  FormatConverter: () => FormatConverter
});

class FormatConverter {
  internalFields = [
    "output_format",
    "requires_structured_output",
    "validation_rules",
    "primary_objective",
    "anti_objectives",
    "intended_followups"
  ];
  filterInternalFields(frontmatter) {
    const filtered = { ...frontmatter };
    const removedFields = [];
    for (const field of this.internalFields) {
      if (field in filtered) {
        delete filtered[field];
        removedFields.push(field);
      }
    }
    return filtered;
  }
  baseToClaudeCode(agent) {
    if (agent.format !== "base") {
      throw new Error(`Expected base format, got ${agent.format}`);
    }
    const filteredFrontmatter = this.filterInternalFields(agent.frontmatter);
    const baseAgent = filteredFrontmatter;
    let toolsString;
    if (baseAgent.tools && typeof baseAgent.tools === "object") {
      const enabledTools = Object.entries(baseAgent.tools).filter(([, enabled]) => enabled === true).map(([tool]) => tool);
      toolsString = enabledTools.length > 0 ? enabledTools.join(", ") : undefined;
    } else if (baseAgent.permission && typeof baseAgent.permission === "object") {
      const permissions = baseAgent.permission;
      const allowedTools = Object.entries(permissions).filter(([, value]) => value === "allow").map(([tool]) => tool);
      toolsString = allowedTools.length > 0 ? allowedTools.join(", ") : undefined;
    }
    let model = "inherit";
    if (baseAgent.model) {
      const convertedModel = this.convertModelForClaudeCode(baseAgent.model);
      if (convertedModel) {
        model = convertedModel;
      }
    }
    const claudeCodeFrontmatter = {
      name: baseAgent.name,
      description: baseAgent.description,
      ...toolsString && { tools: toolsString },
      model
    };
    return {
      ...agent,
      format: "claude-code",
      frontmatter: claudeCodeFrontmatter
    };
  }
  baseToOpenCode(agent) {
    if (agent.format !== "base") {
      throw new Error(`Expected base format, got ${agent.format}`);
    }
    const filteredFrontmatter = this.filterInternalFields(agent.frontmatter);
    const baseAgent = filteredFrontmatter;
    const openCodeFrontmatter = {
      name: baseAgent.name || agent.name,
      description: baseAgent.description,
      mode: baseAgent.mode || "subagent",
      model: baseAgent.model,
      temperature: baseAgent.temperature,
      permission: this.extractPermissions(baseAgent),
      ...baseAgent.category && { category: baseAgent.category },
      ...baseAgent.tags && { tags: baseAgent.tags },
      ...baseAgent.allowed_directories && { allowed_directories: baseAgent.allowed_directories }
    };
    if (openCodeFrontmatter.model) {
      openCodeFrontmatter.model = this.convertModelForOpenCode(openCodeFrontmatter.model);
    }
    if (openCodeFrontmatter.permission) {
      const validation = this.validatePermissions(openCodeFrontmatter.permission);
      if (!validation.valid) {
        throw new Error(`Invalid permissions for agent ${baseAgent.name}: ${validation.errors.join(", ")}`);
      }
    } else {
      openCodeFrontmatter.permission = {
        edit: "deny",
        bash: "deny",
        webfetch: "allow",
        read: "allow",
        write: "deny"
      };
    }
    return {
      ...agent,
      format: "opencode",
      frontmatter: openCodeFrontmatter
    };
  }
  claudeCodeToBase(agent) {
    if (agent.format !== "claude-code") {
      throw new Error(`Expected claude-code format, got ${agent.format}`);
    }
    const claudeAgent = agent.frontmatter;
    const tools = claudeAgent.tools ? claudeAgent.tools.split(",").reduce((acc, tool) => {
      acc[tool.trim()] = true;
      return acc;
    }, {}) : undefined;
    const baseFrontmatter = {
      ...claudeAgent,
      tools
    };
    return {
      ...agent,
      format: "base",
      frontmatter: baseFrontmatter
    };
  }
  claudeCodeToOpenCode(agent) {
    if (agent.format !== "claude-code") {
      throw new Error(`Expected claude-code format, got ${agent.format}`);
    }
    const baseAgent = this.claudeCodeToBase(agent);
    const baseFrontmatter = baseAgent.frontmatter;
    const openCodeFrontmatter = {
      name: baseFrontmatter.name,
      description: baseFrontmatter.description,
      mode: "subagent",
      model: baseFrontmatter.model,
      temperature: baseFrontmatter.temperature,
      tools: baseFrontmatter.tools
    };
    if (openCodeFrontmatter.model) {
      openCodeFrontmatter.model = this.convertModelForOpenCode(openCodeFrontmatter.model);
    }
    return {
      ...agent,
      format: "opencode",
      frontmatter: openCodeFrontmatter
    };
  }
  openCodeToBase(agent) {
    if (agent.format !== "opencode") {
      throw new Error(`Expected opencode format, got ${agent.format}`);
    }
    const frontmatter = agent.frontmatter;
    const baseFrontmatter = {
      name: frontmatter.name || agent.name,
      description: frontmatter.description,
      mode: frontmatter.mode || "subagent",
      model: frontmatter.model,
      temperature: frontmatter.temperature,
      tools: frontmatter.permission ? this.convertPermissionsToTools(frontmatter.permission) : frontmatter.tools,
      ...frontmatter.category && { category: frontmatter.category },
      ...frontmatter.tags && { tags: frontmatter.tags },
      ...frontmatter.allowed_directories && {
        allowed_directories: frontmatter.allowed_directories
      }
    };
    return {
      ...agent,
      format: "base",
      frontmatter: baseFrontmatter
    };
  }
  openCodeToClaudeCode(agent) {
    if (agent.format !== "opencode") {
      throw new Error(`Expected opencode format, got ${agent.format}`);
    }
    const baseAgent = this.openCodeToBase(agent);
    return this.baseToClaudeCode(baseAgent);
  }
  convert(agent, targetFormat) {
    if (agent.format === targetFormat) {
      return agent;
    }
    const isCommand = agent.frontmatter.mode === "command";
    switch (agent.format) {
      case "base":
        switch (targetFormat) {
          case "cursor":
            if (isCommand) {
              const convertedCmd = this.baseCommandToOpenCode(agent);
              return { ...convertedCmd, format: "claude-code" };
            }
            return this.baseToClaudeCode(agent);
          case "claude-code":
            if (isCommand) {
              const convertedCmd = this.baseCommandToOpenCode(agent);
              return { ...convertedCmd, format: "claude-code" };
            }
            return this.baseToClaudeCode(agent);
          case "opencode":
            return isCommand ? this.baseCommandToOpenCode(agent) : this.baseToOpenCode(agent);
        }
        break;
      case "claude-code":
        switch (targetFormat) {
          case "base":
            return this.claudeCodeToBase(agent);
          case "opencode":
            return this.claudeCodeToOpenCode(agent);
        }
        break;
      case "cursor":
        switch (targetFormat) {
          case "base":
            return this.claudeCodeToBase(agent);
          case "opencode":
            return this.claudeCodeToOpenCode(agent);
          case "claude-code":
            return this.baseToClaudeCode(agent);
          case "cursor":
            return agent;
        }
        break;
      case "opencode":
        switch (targetFormat) {
          case "base":
            return this.openCodeToBase(agent);
          case "cursor":
            return this.baseToClaudeCode(agent);
          case "claude-code":
            return this.baseToClaudeCode(this.openCodeToBase(agent));
        }
        break;
    }
    throw new Error(`Unsupported conversion from ${agent.format} to ${targetFormat}`);
  }
  convertAll(_sourceDir, _targetFormat, _outputDir) {}
  convertBatch(agents, targetFormat) {
    return agents.map((agent) => this.convert(agent, targetFormat));
  }
  testRoundTrip(agent) {
    const errors2 = [];
    try {
      const converted = this.convert(agent, "base");
      const roundTrip = this.convert(converted, agent.format);
      if (agent.frontmatter.name !== roundTrip.frontmatter.name) {
        errors2.push("Name field changed during round-trip conversion");
      }
      if (agent.frontmatter.description !== roundTrip.frontmatter.description) {
        errors2.push("Description field changed during round-trip conversion");
      }
      return {
        success: errors2.length === 0,
        errors: errors2
      };
    } catch (error) {
      return {
        success: false,
        errors: [error.message]
      };
    }
  }
  extractPermissions(baseAgent) {
    const basePermission = baseAgent.permission;
    if (basePermission && typeof basePermission === "object") {
      const extracted = {};
      for (const [key, value] of Object.entries(basePermission)) {
        extracted[key] = this.flattenNestedPermission(value);
      }
      if (Object.keys(extracted).length > 0) {
        if (!extracted.webfetch) {
          extracted.webfetch = "allow";
        }
        return extracted;
      }
    }
    if (baseAgent.permissions?.opencode) {
      return this.convertBaseOpenCodePermissions(baseAgent.permissions.opencode);
    }
    if (baseAgent.tools) {
      return this.convertToolsToPermissions(baseAgent.tools);
    }
    return;
  }
  flattenNestedPermission(permission) {
    if (typeof permission === "string") {
      return permission;
    }
    if (typeof permission === "object" && permission !== null) {
      if ("*" in permission) {
        return permission["*"];
      }
      const values = Object.values(permission);
      if (values.includes("allow")) {
        return "allow";
      }
      if (values.includes("ask")) {
        return "ask";
      }
      return "deny";
    }
    return "deny";
  }
  convertBaseOpenCodePermissions(basePermissions) {
    const permissions = {};
    if (basePermissions.tools && Array.isArray(basePermissions.tools)) {
      for (const tool of basePermissions.tools) {
        permissions[tool] = "allow";
      }
    }
    return permissions;
  }
  convertToolsToPermissions(tools) {
    const permissions = {
      edit: this.booleanToPermissionString(tools.edit || false),
      bash: this.booleanToPermissionString(tools.bash || false),
      webfetch: this.booleanToPermissionString(tools.webfetch !== false)
    };
    for (const [tool, enabled] of Object.entries(tools)) {
      if (!["edit", "bash", "webfetch"].includes(tool)) {
        permissions[tool] = this.booleanToPermissionString(enabled);
      }
    }
    return permissions;
  }
  booleanToPermissionString(value) {
    return value ? "allow" : "deny";
  }
  convertPermissionsToTools(permissions) {
    const tools = {};
    for (const [tool, permission] of Object.entries(permissions)) {
      tools[tool] = permission === "allow";
    }
    return tools;
  }
  convertModelForClaudeCode(model) {
    const modelMap = {
      "claude-sonnet": "sonnet",
      "claude-opus": "opus",
      "claude-haiku": "haiku",
      "anthropic/claude-sonnet-4": "sonnet",
      "anthropic/claude-opus-4": "opus",
      "anthropic/claude-haiku-4": "haiku",
      inherit: "inherit",
      sonnet: "sonnet",
      opus: "opus",
      haiku: "haiku",
      "opencode/grok-code": "inherit",
      "opencode/code-supernova": "inherit",
      "opencode/grok-code-fast-1": "inherit",
      "opencode/gpt-5": "inherit",
      "github-copilot/gpt-5": "inherit"
    };
    if (["inherit", "sonnet", "opus", "haiku"].includes(model)) {
      return model;
    }
    const mapped = modelMap[model.toLowerCase()];
    if (mapped) {
      return mapped;
    }
    console.warn(`Unknown model '${model}', defaulting to 'inherit' for Claude Code`);
    return "inherit";
  }
  convertModelForOpenCode(model) {
    const modelMap = {
      sonnet: "opencode/grok-code",
      opus: "opencode/code-supernova",
      haiku: "opencode/grok-code",
      inherit: "opencode/grok-code",
      "anthropic/claude-sonnet-4": "opencode/grok-code",
      "anthropic/claude-opus-4": "opencode/code-supernova",
      "anthropic/claude-haiku-4": "opencode/grok-code",
      "gpt-5": "github-copilot/gpt-5"
    };
    if (model.startsWith("opencode/")) {
      const validModels = [
        "opencode/grok-code",
        "opencode/code-supernova",
        "opencode/grok-code-fast-1"
      ];
      if (model === "opencode/gpt-5") {
        console.warn(`Model '${model}' is not available in opencode provider, using github-copilot provider instead`);
        return "github-copilot/gpt-5";
      }
      if (validModels.includes(model)) {
        return model;
      }
      console.warn(`Unknown OpenCode model '${model}', defaulting to 'opencode/grok-code'`);
      return "opencode/grok-code";
    }
    const mapped = modelMap[model.toLowerCase()];
    if (mapped) {
      return mapped;
    }
    console.warn(`Unknown model '${model}', defaulting to 'opencode/grok-code' for OpenCode`);
    return "opencode/grok-code";
  }
  baseCommandToOpenCode(command) {
    if (command.format !== "base") {
      throw new Error(`Expected base format, got ${command.format}`);
    }
    const baseCommand = command.frontmatter;
    const openCodeFrontmatter = {
      name: baseCommand.name,
      description: baseCommand.description,
      mode: "command",
      version: baseCommand.version || "1.0.0",
      inputs: baseCommand.inputs,
      outputs: baseCommand.outputs,
      cache_strategy: baseCommand.cache_strategy || {
        type: "content_based",
        ttl: 600,
        max_size: 100
      },
      success_signals: baseCommand.success_signals || ["Command completed successfully"],
      failure_modes: baseCommand.failure_modes || ["Command execution failed"],
      ...baseCommand.usage && { usage: baseCommand.usage },
      ...baseCommand.examples && { examples: baseCommand.examples },
      ...baseCommand.constraints && { constraints: baseCommand.constraints },
      ...baseCommand.intended_followups && { intended_followups: baseCommand.intended_followups }
    };
    let commandBody = command.content || "";
    if (!commandBody.includes("$ARGUMENTS")) {
      if (!commandBody.trim()) {
        commandBody = `# Command execution

$ARGUMENTS `;
      } else {
        commandBody += `

$ARGUMENTS `;
      }
    }
    commandBody = this.addSecurityAndErrorHandling(commandBody);
    return {
      ...command,
      format: "opencode",
      frontmatter: openCodeFrontmatter,
      content: commandBody
    };
  }
  addSecurityAndErrorHandling(commandBody) {
    let enhancedBody = commandBody;
    if (!enhancedBody.includes("set -e") && !enhancedBody.includes("set -euo pipefail")) {
      enhancedBody = `set -euo pipefail

` + enhancedBody;
    }
    const dangerousPatterns = [
      {
        pattern: /\brm\s+-rf\s+\$ARGUMENTS\b/g,
        replacement: 'echo "Error: Dangerous rm -rf with $ARGUMENTS not allowed"'
      },
      {
        pattern: /\bsudo\s+/g,
        replacement: 'echo "Error: sudo commands not allowed in automated execution"'
      },
      {
        pattern: /\bchmod\s+777\b/g,
        replacement: 'echo "Error: chmod 777 not allowed for security reasons"'
      }
    ];
    for (const { pattern, replacement } of dangerousPatterns) {
      enhancedBody = enhancedBody.replace(pattern, replacement);
    }
    enhancedBody = enhancedBody.replace(/!`([^`]*)`/g, (match, command) => {
      if (!command.includes("||") && !command.includes("&&")) {
        return "!`" + command + ' || echo "Shell command failed: ' + command + '"`';
      }
      return match;
    });
    enhancedBody = this.enhanceTemplateSubstitution(enhancedBody);
    enhancedBody = this.addRecommendedPatterns(enhancedBody);
    return enhancedBody;
  }
  enhanceTemplateSubstitution(commandBody) {
    let enhancedBody = commandBody;
    enhancedBody = enhancedBody.replace(/!`([^`]*)`/g, (match, command) => {
      if (!command.includes("||") && !command.includes("&&") && !command.includes("2>/dev/null")) {
        return "!`" + command + ' 2>/dev/null || echo "Command failed: ' + command + '"`';
      }
      return match;
    });
    enhancedBody = enhancedBody.replace(/@([a-zA-Z0-9_\-./]+)/g, (match, filePath) => {
      if (filePath.includes("..") || filePath.startsWith("/")) {
        return "# Invalid file path: " + filePath;
      }
      return match;
    });
    enhancedBody = enhancedBody.replace(/\$\{([^}]+)\}/g, (match, varName) => {
      const safeVars = ["HOME", "PWD", "USER", "PATH", "DATE", "TIME"];
      if (safeVars.includes(varName.toUpperCase())) {
        return match;
      }
      return "# Unsafe environment variable: " + varName;
    });
    enhancedBody = this.addDateTimePatterns(enhancedBody);
    return enhancedBody;
  }
  addDateTimePatterns(commandBody) {
    let enhancedBody = commandBody;
    if (enhancedBody.includes("DATE") || enhancedBody.includes("TIME")) {
      if (!enhancedBody.includes("date") && !enhancedBody.includes("$(date")) {
        enhancedBody = enhancedBody.replace(/\bDATE\b/g, '$(date -u +"%Y-%m-%d")');
        enhancedBody = enhancedBody.replace(/\bTIME\b/g, '$(date -u +"%Y-%m-%dT%H:%M:%SZ")');
      }
    }
    if (enhancedBody.includes("log") || enhancedBody.includes("LOG")) {
      if (!enhancedBody.includes("TIMESTAMP")) {
        enhancedBody = enhancedBody.replace(/\bTIMESTAMP\b/g, '$(date -u +"%Y-%m-%dT%H:%M:%S.%3NZ")');
      }
    }
    return enhancedBody;
  }
  addRecommendedPatterns(commandBody) {
    let enhancedBody = commandBody;
    if (!enhancedBody.includes("!`") && !enhancedBody.includes("shell command")) {
      enhancedBody += `

## Example Usage

!\`echo "Processing arguments: $ARGUMENTS"\`
`;
    }
    if (!enhancedBody.includes("@") && !enhancedBody.includes("file reference")) {
      enhancedBody += `
## File References

Use @filename to reference files in arguments
`;
    }
    if (!enhancedBody.includes("error") && !enhancedBody.includes("try")) {
      enhancedBody += `
## Error Handling

Arguments are validated before processing
`;
    }
    return enhancedBody;
  }
  validatePermissions(permissions) {
    const errors2 = [];
    if (!permissions || typeof permissions !== "object") {
      errors2.push("Permission must be an object");
      return { valid: false, errors: errors2 };
    }
    for (const [action, value] of Object.entries(permissions)) {
      if (typeof value === "object" && value !== null) {
        for (const [subAction, subValue] of Object.entries(value)) {
          if (!["allow", "ask", "deny"].includes(subValue)) {
            errors2.push(`Nested permission for '${action}.${subAction}' must be 'allow', 'ask', or 'deny', got '${subValue}'`);
          }
        }
      } else if (!["allow", "ask", "deny"].includes(value)) {
        errors2.push(`Permission for '${action}' must be 'allow', 'ask', or 'deny', got '${value}'`);
      }
    }
    return { valid: errors2.length === 0, errors: errors2 };
  }
}

// src/conversion/command-converter.ts
var exports_command_converter = {};
__export(exports_command_converter, {
  CommandConverter: () => CommandConverter
});
import { readFile as readFile2 } from "fs/promises";

class CommandConverter {
  processor;
  constructor() {
    this.processor = new YamlProcessor;
  }
  convertToClaudeCode(commandContent, filePath) {
    const parseResult = this.processor.parse(commandContent);
    if (!parseResult.success) {
      throw new Error(`Failed to parse command: ${parseResult.error.message}`);
    }
    const parsedYaml = parseResult.data;
    const frontmatter = parsedYaml.frontmatter;
    const convertedFrontmatter = this.convertOpenCodeToClaudeCode(frontmatter);
    const transformedBody = this.transformBodyVariables(parsedYaml.body, "claude-code", frontmatter.inputs);
    const entity = {
      name: convertedFrontmatter.name || "unknown",
      format: "claude-code",
      frontmatter: convertedFrontmatter,
      content: transformedBody,
      filePath
    };
    const yamlResult = this.processor.serialize(entity);
    if (!yamlResult.success) {
      throw new Error(`Failed to serialize converted command: ${yamlResult.error.message}`);
    }
    return yamlResult.data;
  }
  convertToOpenCode(commandContent, filePath) {
    const parseResult = this.processor.parse(commandContent);
    if (!parseResult.success) {
      throw new Error(`Failed to parse command: ${parseResult.error.message}`);
    }
    const parsedYaml = parseResult.data;
    const frontmatter = parsedYaml.frontmatter;
    const isAlreadyOpenCode = frontmatter.mode === "command" && frontmatter.inputs;
    const convertedFrontmatter = isAlreadyOpenCode ? this.ensureOpenCodeDefaults(frontmatter) : this.convertClaudeCodeToOpenCode(frontmatter);
    const transformedBody = this.transformBodyVariables(parsedYaml.body, "opencode", convertedFrontmatter.inputs);
    const entity = {
      name: convertedFrontmatter.name || "unknown",
      format: "opencode",
      frontmatter: convertedFrontmatter,
      content: transformedBody,
      filePath
    };
    const yamlResult = this.processor.serialize(entity);
    if (!yamlResult.success) {
      throw new Error(`Failed to serialize converted command: ${yamlResult.error.message}`);
    }
    return yamlResult.data;
  }
  ensureOpenCodeDefaults(frontmatter) {
    const converted = {
      ...frontmatter,
      mode: "command",
      model: frontmatter.model || "opencode/grok-code",
      version: frontmatter.version || "2.1.0-optimized",
      last_updated: frontmatter.last_updated || new Date().toISOString().split("T")[0],
      command_schema_version: frontmatter.command_schema_version || "1.0"
    };
    if (frontmatter.inputs) {
      converted.inputs = frontmatter.inputs;
    }
    if (!converted.outputs) {
      converted.outputs = [
        {
          name: "result",
          type: "string",
          description: "Command execution result"
        }
      ];
    }
    if (!converted.cache_strategy) {
      converted.cache_strategy = {
        type: "content_based",
        ttl: 3600,
        scope: "command"
      };
    }
    if (!converted.success_signals) {
      converted.success_signals = [
        "Command completed successfully",
        "Task executed without errors"
      ];
    }
    if (!converted.failure_modes) {
      converted.failure_modes = [
        "Command execution failed",
        "Invalid parameters provided",
        "System error occurred"
      ];
    }
    delete converted.temperature;
    delete converted.category;
    delete converted.params;
    return converted;
  }
  convertOpenCodeToClaudeCode(frontmatter) {
    const converted = {
      name: frontmatter.name,
      description: frontmatter.description,
      temperature: 0.1,
      category: this.inferCategoryFromName(frontmatter.name)
    };
    if (frontmatter.inputs && frontmatter.inputs.length > 0) {
      converted.params = {
        required: frontmatter.inputs.filter((input) => input.required).map((input) => ({
          name: input.name,
          description: input.description || input.name,
          type: input.type
        })),
        optional: frontmatter.inputs.filter((input) => !input.required).map((input) => ({
          name: input.name,
          description: input.description || input.name,
          type: input.type
        }))
      };
    }
    delete converted.mode;
    delete converted.model;
    delete converted.inputs;
    delete converted.outputs;
    delete converted.cache_strategy;
    delete converted.success_signals;
    delete converted.failure_modes;
    delete converted.command_schema_version;
    delete converted.last_updated;
    return converted;
  }
  convertClaudeCodeToOpenCode(frontmatter) {
    const converted = {
      name: frontmatter.name,
      description: frontmatter.description,
      mode: "command",
      model: "opencode/grok-code",
      version: "2.1.0-optimized",
      last_updated: new Date().toISOString().split("T")[0],
      command_schema_version: "1.0"
    };
    if (frontmatter.params) {
      converted.inputs = [
        ...(frontmatter.params.required || []).map((param) => ({
          name: param.name,
          type: param.type || "string",
          required: true,
          description: param.description
        })),
        ...(frontmatter.params.optional || []).map((param) => ({
          name: param.name,
          type: param.type || "string",
          required: false,
          description: param.description
        }))
      ];
    }
    converted.outputs = [
      {
        name: "result",
        type: "string",
        description: "Command execution result"
      }
    ];
    converted.cache_strategy = {
      type: "content_based",
      ttl: 3600,
      scope: "command"
    };
    converted.success_signals = ["Command completed successfully", "Task executed without errors"];
    converted.failure_modes = [
      "Command execution failed",
      "Invalid parameters provided",
      "System error occurred"
    ];
    delete converted.params;
    delete converted.category;
    delete converted.temperature;
    return converted;
  }
  convertModelToClaudeCode(model) {
    if (!model)
      return "claude-3-5-sonnet-20241022";
    const modelMap = {
      "opencode/grok-code": "claude-3-5-sonnet-20241022",
      "opencode/code-supernova": "claude-3-5-sonnet-20241022",
      "opencode/grok-code-fast-1": "claude-3-5-sonnet-20241022"
    };
    return modelMap[model] || "claude-3-5-sonnet-20241022";
  }
  convertModelToOpenCode(model) {
    if (!model)
      return;
    const modelMap = {
      "claude-3-5-sonnet-20241022": "opencode/grok-code",
      "claude-3-5-sonnet": "opencode/grok-code"
    };
    return modelMap[model] || undefined;
  }
  inferCategoryFromName(name) {
    const nameLower = name.toLowerCase();
    if (nameLower.includes("docker"))
      return "docker";
    if (nameLower.includes("database") || nameLower.includes("db"))
      return "database";
    if (nameLower.includes("security") || nameLower.includes("audit"))
      return "security";
    if (nameLower.includes("monitor"))
      return "monitoring";
    if (nameLower.includes("git") || nameLower.includes("commit"))
      return "git";
    if (nameLower.includes("test"))
      return "testing";
    if (nameLower.includes("build") || nameLower.includes("compile"))
      return "build";
    if (nameLower.includes("deploy"))
      return "deploy";
    if (nameLower.includes("analyze") || nameLower.includes("review"))
      return "analysis";
    if (nameLower.includes("generate") || nameLower.includes("create"))
      return "generation";
    if (nameLower.includes("convert") || nameLower.includes("transform"))
      return "conversion";
    if (nameLower.includes("document"))
      return "documentation";
    return "utility";
  }
  transformBodyVariables(body, targetFormat, inputs) {
    if (targetFormat === "opencode") {
      let transformed = body;
      const variablePattern = /\{\{(\w+)\}\}/g;
      const matches = body.match(variablePattern);
      if (matches && matches.length > 1) {
        transformed = `<!-- Note: OpenCode only supports $ARGUMENTS placeholder. Multiple parameters from Claude/Cursor may not work as expected. -->

` + transformed;
      }
      transformed = transformed.replace(variablePattern, "$ARGUMENTS");
      return transformed;
    } else {
      let primaryParam = "arguments";
      if (inputs && inputs.length > 0) {
        const requiredInputs = inputs.filter((i) => i.required);
        const firstInput = requiredInputs.length > 0 ? requiredInputs[0] : inputs[0];
        primaryParam = firstInput.name;
      }
      return body.replace(/\$ARGUMENTS/g, `{{${primaryParam}}}`);
    }
  }
  async convertFile(filePath, targetFormat) {
    const content = await readFile2(filePath, "utf-8");
    if (filePath.includes("document.md")) {
      console.error(`[DEBUG] Reading document.md: ${filePath}`);
      console.error(`[DEBUG] First 100 chars: ${content.substring(0, 100)}`);
      console.error(`[DEBUG] Starts with ---?: ${content.startsWith("---")}`);
    }
    if (targetFormat === "claude-code") {
      return this.convertToClaudeCode(content, filePath);
    } else {
      return this.convertToOpenCode(content, filePath);
    }
  }
}
var init_command_converter = __esm(() => {
  init_yaml_processor();
});

// src/cli/index.ts
import { parseArgs } from "util";

// src/cli/status.ts
import { readdir } from "fs/promises";
import { join as join2 } from "path";
import { existsSync as existsSync3 } from "fs";

// src/cli/error-handler.ts
import { existsSync } from "fs";

class CLIErrorHandler {
  static displayError(context) {
    console.error(`
\u274C ${context.command} Error`);
    console.error(`\u250C\u2500 ${context.phase}`);
    console.error(`\u251C\u2500 Type: ${context.errorType}`);
    console.error(`\u251C\u2500 Expected: ${context.expected}`);
    console.error(`\u251C\u2500 Found: ${context.found}`);
    console.error(`\u2514\u2500 Action: ${context.mitigation}`);
    if (context.suggestions && context.suggestions.length > 0) {
      console.error(`
\uD83D\uDCA1 Suggestions:`);
      context.suggestions.forEach((suggestion, index) => {
        console.error(`   ${index + 1}. ${suggestion}`);
      });
    }
    if (context.requiresUserInput) {
      console.error(`
\u26A0\uFE0F  This error requires user input to resolve.`);
    }
    console.error("");
  }
  static displayValidationResult(result, context) {
    if (result.valid) {
      console.log(`\u2705 ${context} validation passed`);
      return;
    }
    if (result.errors.length > 0) {
      console.error(`
\u274C ${context} Validation Errors:`);
      result.errors.forEach((error, index) => {
        console.error(`   ${index + 1}. ${error}`);
      });
    }
    if (result.warnings.length > 0) {
      console.error(`
\u26A0\uFE0F  ${context} Warnings:`);
      result.warnings.forEach((warning, index) => {
        console.error(`   ${index + 1}. ${warning}`);
      });
    }
    if (result.suggestions.length > 0) {
      console.error(`
\uD83D\uDCA1 Suggestions:`);
      result.suggestions.forEach((suggestion, index) => {
        console.error(`   ${index + 1}. ${suggestion}`);
      });
    }
  }
  static createErrorContext(command, phase, errorType, expected, found, mitigation, options = {}) {
    return {
      command,
      phase,
      errorType,
      expected,
      found,
      mitigation,
      requiresUserInput: options.requiresUserInput ?? false,
      suggestions: options.suggestions
    };
  }
  static validatePath(path, pathType) {
    const result = {
      valid: true,
      errors: [],
      warnings: [],
      suggestions: []
    };
    if (!existsSync(path)) {
      result.valid = false;
      result.errors.push(`${pathType} does not exist: ${path}`);
      result.suggestions.push(`Create the ${pathType} or check the path`);
      result.suggestions.push("Use --help for usage information");
      return result;
    }
    return result;
  }
  static validateArguments(args, requiredCount, commandName) {
    const result = {
      valid: true,
      errors: [],
      warnings: [],
      suggestions: []
    };
    if (args.length < requiredCount) {
      result.valid = false;
      result.errors.push(`Insufficient arguments for ${commandName}`);
      result.errors.push(`Expected ${requiredCount} arguments, got ${args.length}`);
      result.suggestions.push(`Use 'codeflow ${commandName} --help' for usage information`);
      return result;
    }
    return result;
  }
  static handleCommonError(error, command) {
    const errorMessage = error.message || error.toString();
    if (error.code === "ENOENT") {
      const context2 = this.createErrorContext(command, "file_system", "file_not_found", "Valid file or directory path", errorMessage, "Check that the file or directory exists and the path is correct", {
        requiresUserInput: true,
        suggestions: [
          "Verify the path is spelled correctly",
          "Check file/directory permissions",
          "Use absolute paths if relative paths fail"
        ]
      });
      this.displayError(context2);
      return;
    }
    if (error.code === "EACCES") {
      const context2 = this.createErrorContext(command, "permissions", "access_denied", "Read/write access to target path", errorMessage, "Check file and directory permissions", {
        requiresUserInput: true,
        suggestions: [
          "Run with appropriate permissions (sudo if needed)",
          "Check if the file is locked by another process",
          "Verify user has write access to the directory"
        ]
      });
      this.displayError(context2);
      return;
    }
    if (error.code === "ERR_PARSE_ARGS_UNKNOWN_OPTION") {
      const context2 = this.createErrorContext(command, "argument_parsing", "unknown_option", "Valid command line options", errorMessage, "Check the option name and try again", {
        requiresUserInput: true,
        suggestions: [
          `Run 'codeflow ${command} --help' for available options`,
          "Check for typos in option names",
          "Use --force or -f to override safety checks"
        ]
      });
      this.displayError(context2);
      return;
    }
    const context = this.createErrorContext(command, "execution", "unexpected_error", "Successful command execution", errorMessage, "Check the error details and try again", {
      requiresUserInput: false,
      suggestions: [
        "Check the command syntax",
        "Verify all required arguments are provided",
        "Try running with --verbose for more details"
      ]
    });
    this.displayError(context);
  }
  static displaySuccess(message, nextSteps) {
    console.log(`
\u2705 ${message}`);
    if (nextSteps && nextSteps.length > 0) {
      console.log(`
\uD83D\uDCCB Next Steps:`);
      nextSteps.forEach((step, index) => {
        console.log(`   ${index + 1}. ${step}`);
      });
    }
  }
  static displayProgress(message, current, total) {
    const progress = total ? ` (${current}/${total})` : "";
    console.log(`\u23F3 ${message}${progress}`);
  }
  static displayWarning(message, suggestions) {
    console.warn(`\u26A0\uFE0F  ${message}`);
    if (suggestions && suggestions.length > 0) {
      console.warn("\uD83D\uDCA1 Suggestions:");
      suggestions.forEach((suggestion, index) => {
        console.warn(`   ${index + 1}. ${suggestion}`);
      });
    }
  }
}
var error_handler_default = CLIErrorHandler;

// src/utils/path-resolver.ts
import { fileURLToPath } from "url";
import { dirname, join, resolve } from "path";
import { existsSync as existsSync2 } from "fs";
var __filename = "/Users/johnferguson/Github/codeflow/src/utils/path-resolver.ts";
function getCodeflowRoot() {
  if (process.env.CODEFLOW_ROOT) {
    return resolve(process.env.CODEFLOW_ROOT);
  }
  let currentModulePath;
  try {
    currentModulePath = fileURLToPath(import.meta.url);
    console.error(`[DEBUG] import.meta.url: ${import.meta.url}`);
    console.error(`[DEBUG] currentModulePath: ${currentModulePath}`);
  } catch (error) {
    console.error(`[DEBUG] import.meta.url failed: ${error}`);
    if (typeof __filename !== "undefined") {
      currentModulePath = __filename;
      console.error(`[DEBUG] Using __filename: ${currentModulePath}`);
    } else {
      const cwd2 = process.cwd();
      console.error(`[DEBUG] Using cwd: ${cwd2}`);
      if (existsSync2(join(cwd2, "package.json")) && existsSync2(join(cwd2, "base-agents"))) {
        return cwd2;
      }
      currentModulePath = join(cwd2, "src", "utils", "path-resolver.ts");
    }
  }
  const currentDir = dirname(currentModulePath);
  const root = join(currentDir, "../..");
  console.error(`[DEBUG] currentDir: ${currentDir}`);
  console.error(`[DEBUG] calculated root: ${root}`);
  const resolvedRoot = resolve(root);
  console.error(`[DEBUG] resolvedRoot: ${resolvedRoot}`);
  if (existsSync2(join(resolvedRoot, "base-agents")) && existsSync2(join(resolvedRoot, "command"))) {
    console.error(`[DEBUG] Validation passed, returning: ${resolvedRoot}`);
    return resolvedRoot;
  }
  const cwd = process.cwd();
  if (existsSync2(join(cwd, "base-agents")) && existsSync2(join(cwd, "command"))) {
    console.error(`[DEBUG] Using cwd as fallback: ${cwd}`);
    return cwd;
  }
  console.error(`[DEBUG] Returning calculated root as last resort: ${resolvedRoot}`);
  return resolvedRoot;
}

// src/cli/status.ts
async function status(projectPath) {
  const resolvedPath = projectPath || process.cwd();
  const pathValidation = error_handler_default.validatePath(resolvedPath, "directory");
  if (!pathValidation.valid) {
    error_handler_default.displayValidationResult(pathValidation, "project directory");
    return;
  }
  const codeflowDir = getCodeflowRoot();
  const targetBase = join2(resolvedPath, ".opencode");
  error_handler_default.displayProgress(`Checking status for: ${resolvedPath}`);
  error_handler_default.displayProgress(`Checking: commands, agents`);
  try {
    let upToDateCount = 0;
    let outdatedCount = 0;
    let missingCount = 0;
    const sourceCommandDir = join2(codeflowDir, "command");
    if (existsSync3(sourceCommandDir)) {
      const sourceFiles = await readdir(sourceCommandDir);
      const mdFiles = sourceFiles.filter((f) => f.endsWith(".md"));
      for (const file of mdFiles) {
        const possibleLocations = [
          join2(targetBase, "command"),
          join2(resolvedPath, ".claude", "commands"),
          join2(resolvedPath, ".cursor", "mcp.json")
        ];
        const foundInProject = possibleLocations.some((location) => {
          if (location.includes("mcp.json")) {
            return existsSync3(location);
          }
          return existsSync3(join2(location, file));
        });
        if (!foundInProject) {
          console.log(`\u274C command/${file} (missing in project)`);
          missingCount++;
        } else {
          console.log(`\u2705 command/${file}`);
          upToDateCount++;
        }
      }
    }
    const sourceAgentDir = join2(codeflowDir, "codeflow-agents");
    const targetAgentDir = join2(targetBase, "agent");
    if (existsSync3(sourceAgentDir)) {
      const sourceFiles = await readdir(sourceAgentDir);
      const mdFiles = sourceFiles.filter((f) => f.endsWith(".md"));
      for (const file of mdFiles) {
        const targetFile = join2(targetAgentDir, file);
        if (!existsSync3(targetFile)) {
          console.log(`\u274C agent/${file} (missing in project)`);
          missingCount++;
        } else {
          console.log(`\u2705 agent/${file}`);
          upToDateCount++;
        }
      }
    }
    console.log(`
\uD83D\uDCCB Summary:`);
    console.log(`  \u2705 Up-to-date: ${upToDateCount}`);
    console.log(`  \u274C Missing: ${missingCount}`);
    const totalIssues = outdatedCount + missingCount;
    if (totalIssues === 0) {
      error_handler_default.displaySuccess("All files are up-to-date!", [
        "Your project is fully synchronized with codeflow",
        "No action needed"
      ]);
    } else {
      error_handler_default.displayWarning(`${totalIssues} file${totalIssues === 1 ? "" : "s"} need${totalIssues === 1 ? "s" : ""} attention`, [
        "Run 'codeflow sync' to update the project",
        "Run 'codeflow pull' to install missing files"
      ]);
    }
  } catch (error) {
    error_handler_default.handleCommonError(error, "status");
  }
}

// src/cli/setup.ts
init_agent_parser();
init_command_converter();
import { join as join3, dirname as dirname2 } from "path";
import { existsSync as existsSync4 } from "fs";
import { readdir as readdir2, mkdir as mkdir2, copyFile, writeFile, readFile as readFile3 } from "fs/promises";
import { fileURLToPath as fileURLToPath2 } from "url";
function getPackageRoot() {
  try {
    const __filename2 = fileURLToPath2(import.meta.url);
    const __dirname2 = dirname2(__filename2);
    return dirname2(dirname2(__dirname2));
  } catch {
    return process.cwd();
  }
}
function getTargetFormat(setupDir) {
  if (setupDir.includes(".cursor")) {
    return "cursor";
  }
  if (setupDir.includes(".claude")) {
    return "claude-code";
  }
  if (setupDir.includes(".opencode")) {
    return "opencode";
  }
  return null;
}
function getCommandSourceDirs(_sourcePath, targetDir, packageRoot) {
  const sourceDirs = [];
  sourceDirs.push(join3(packageRoot, "command"));
  if (targetDir.includes(".claude")) {
    sourceDirs.push(join3(packageRoot, "claude-agents"));
  } else if (targetDir.includes(".opencode")) {
    sourceDirs.push(join3(packageRoot, "opencode-agents"));
  }
  return sourceDirs;
}
async function copyCommands(converter, sourcePath, targetPath, setupDirs, packageRoot) {
  let fileCount = 0;
  for (const setupDir of setupDirs) {
    const targetDir = join3(targetPath, setupDir);
    if (!existsSync4(targetDir)) {
      await mkdir2(targetDir, { recursive: true });
      console.log(`  \u2713 Created directory: ${setupDir}`);
    }
    if (setupDir.includes("command")) {
      console.log(`\uD83D\uDCCB Copying commands to ${setupDir}...`);
      const sourceDirs = getCommandSourceDirs(sourcePath, setupDir, packageRoot);
      console.log(`Source dirs: ${sourceDirs.join(", ")}`);
      let commandsCopied = 0;
      for (const sourceDir of sourceDirs) {
        if (existsSync4(sourceDir)) {
          try {
            const files = await readdir2(sourceDir, { withFileTypes: true });
            console.log(`Found ${files.length} files in ${sourceDir}`);
            for (const file of files) {
              if (file.isFile() && file.name.endsWith(".md")) {
                try {
                  const sourceFile = join3(sourceDir, file.name);
                  const targetFile = join3(targetDir, file.name);
                  if (targetDir.includes(".opencode")) {
                    try {
                      if (converter instanceof CommandConverter) {
                        const content = await readFile3(sourceFile, "utf-8");
                        const convertedContent = converter.convertToOpenCode(content, sourceFile);
                        await writeFile(targetFile, convertedContent);
                      } else {
                        const command = await parseCommandFile(sourceFile, "base");
                        const convertedCommand = converter.baseCommandToOpenCode(command);
                        const serialized = serializeCommand(convertedCommand);
                        await writeFile(targetFile, serialized);
                      }
                    } catch (error) {
                      console.error(`\u274C Failed to convert command ${file.name}: ${error.message}`);
                      continue;
                    }
                  } else if (targetDir.includes(".claude")) {
                    try {
                      if (converter instanceof CommandConverter) {
                        const content = await readFile3(sourceFile, "utf-8");
                        const convertedContent = converter.convertToClaudeCode(content, sourceFile);
                        await writeFile(targetFile, convertedContent);
                      } else {
                        await copyFile(sourceFile, targetFile);
                      }
                    } catch (error) {
                      console.error(`\u274C Failed to convert command ${file.name}: ${error.message}`);
                      continue;
                    }
                  } else {
                    await copyFile(sourceFile, targetFile);
                  }
                  commandsCopied++;
                } catch (error) {
                  console.error(`\u274C Failed to copy command ${file.name}: ${error.message}`);
                }
              }
            }
          } catch (error) {
            console.error(`\u274C Failed to read source directory ${sourceDir}: ${error.message}`);
          }
        }
      }
      if (commandsCopied > 0) {
        console.log(`\u2705 Copied ${commandsCopied} commands`);
      } else {
        console.log(`\u26A0\uFE0F  No command files found for ${setupDir}`);
        console.log(`   Searched: ${sourceDirs.join(", ")}`);
      }
      fileCount += commandsCopied;
    } else if (setupDir.includes("agents") || setupDir.includes("/agent")) {
      console.log(`\uD83E\uDD16 Converting agents to ${setupDir}...`);
      const targetFormat = getTargetFormat(setupDir);
      if (targetFormat) {
        const agentsConverted = await copyAgentsWithConversion(sourcePath, targetDir, targetFormat);
        console.log(`\u2705 Converted ${agentsConverted} agents`);
        fileCount += agentsConverted;
      } else {
        console.error(`\u274C Could not determine target format for ${setupDir}`);
      }
    } else if (setupDir.includes("skills")) {
      console.log(`\u23ED\uFE0F  Skipping skills directory ${setupDir} (handled separately)`);
    } else {
      console.error(`\u274C Unknown directory type: ${setupDir}`);
    }
  }
  return fileCount;
}
async function copySkills(sourcePath, targetPath, setupDirs, packageRoot) {
  let fileCount = 0;
  for (const setupDir of setupDirs) {
    if (setupDir.includes("skills")) {
      const targetDir = join3(targetPath, setupDir);
      if (!existsSync4(targetDir)) {
        await mkdir2(targetDir, { recursive: true });
        console.log(`  \u2713 Created directory: ${setupDir}`);
      }
      console.log(`\uD83D\uDCE6 Copying skills to ${setupDir}...`);
      const sourceDirs = [
        join3(packageRoot, "base-skills"),
        join3(sourcePath, "base-skills"),
        join3(process.cwd(), "base-skills")
      ];
      let skillsCopied = 0;
      for (const sourceDir of sourceDirs) {
        if (existsSync4(sourceDir)) {
          try {
            const files = await readdir2(sourceDir, { withFileTypes: true });
            console.log(`Found ${files.length} items in ${sourceDir}`);
            for (const file of files) {
              if (file.isFile() && file.name.endsWith(".md")) {
                try {
                  const sourceFile = join3(sourceDir, file.name);
                  const targetFile = join3(targetDir, file.name);
                  await copyFile(sourceFile, targetFile);
                  skillsCopied++;
                } catch (error) {
                  console.error(`\u274C Failed to copy skill ${file.name}: ${error.message}`);
                }
              } else if (file.isDirectory()) {
                const sourceCategoryDir = join3(sourceDir, file.name);
                const targetCategoryDir = join3(targetDir, file.name);
                if (!existsSync4(targetCategoryDir)) {
                  await mkdir2(targetCategoryDir, { recursive: true });
                }
                try {
                  const categoryFiles = await readdir2(sourceCategoryDir, { withFileTypes: true });
                  for (const categoryFile of categoryFiles) {
                    if (categoryFile.isFile() && categoryFile.name.endsWith(".md")) {
                      try {
                        const sourceSkillFile = join3(sourceCategoryDir, categoryFile.name);
                        const targetSkillFile = join3(targetCategoryDir, categoryFile.name);
                        await copyFile(sourceSkillFile, targetSkillFile);
                        skillsCopied++;
                      } catch (error) {
                        console.error(`\u274C Failed to copy skill ${categoryFile.name}: ${error.message}`);
                      }
                    }
                  }
                } catch (error) {
                  console.error(`\u274C Failed to read category directory ${sourceCategoryDir}: ${error.message}`);
                }
              }
            }
            break;
          } catch (error) {
            console.error(`\u274C Failed to read source directory ${sourceDir}: ${error.message}`);
          }
        }
      }
      if (skillsCopied > 0) {
        console.log(`\u2705 Copied ${skillsCopied} skills`);
      } else {
        console.log(`\u26A0\uFE0F  No skill files found for ${setupDir}`);
        console.log(`   Searched: ${sourceDirs.join(", ")}`);
      }
      fileCount += skillsCopied;
    }
  }
  return fileCount;
}
async function setup(inputPath, options) {
  const projectTypes = [];
  if (options && options.type) {
    if (options.type === "claude-code" || options.type === "opencode" || options.type === "cursor") {
      projectTypes.push(options.type);
    } else if (options.type === "all") {
      projectTypes.push("claude-code", "opencode", "cursor");
    } else {
      console.error(`\u274C Unknown project type: ${options.type}`);
      console.error(`Valid types: claude-code, opencode, cursor, all`);
      process.exit(1);
    }
  } else {
    projectTypes.push("claude-code", "opencode", "cursor");
  }
  const setupDirs = projectTypes.flatMap((type) => {
    const dirs = [];
    switch (type) {
      case "claude-code":
        dirs.push(".claude/commands", ".claude/agents", ".claude/skills");
        break;
      case "opencode":
        dirs.push(".opencode/command", ".opencode/agent", ".opencode/skills");
        break;
      case "cursor":
        dirs.push(".cursor/commands", ".cursor/agents", ".cursor/skills");
        break;
      default:
        dirs.push("./command");
    }
    return dirs;
  });
  let packageRoot = getPackageRoot();
  if (process.env.CODEFLOW_ROOT && existsSync4(join3(process.env.CODEFLOW_ROOT, "base-agents"))) {
    packageRoot = process.env.CODEFLOW_ROOT;
  } else if (!existsSync4(join3(packageRoot, "base-agents")) || !existsSync4(join3(packageRoot, "command"))) {
    const cwd = process.cwd();
    if (existsSync4(join3(cwd, "base-agents")) && existsSync4(join3(cwd, "command"))) {
      packageRoot = cwd;
    } else {
      let searchDir = cwd;
      while (searchDir !== "/") {
        if (existsSync4(join3(searchDir, "base-agents")) && existsSync4(join3(searchDir, "command"))) {
          packageRoot = searchDir;
          break;
        }
        searchDir = dirname2(searchDir);
      }
    }
  } else if (!existsSync4(join3(packageRoot, "base-agents")) || !existsSync4(join3(packageRoot, "command"))) {
    const cwd = process.cwd();
    if (existsSync4(join3(cwd, "base-agents")) && existsSync4(join3(cwd, "command"))) {
      packageRoot = cwd;
    } else {
      let searchDir = cwd;
      while (searchDir !== "/") {
        if (existsSync4(join3(searchDir, "base-agents")) && existsSync4(join3(searchDir, "command"))) {
          packageRoot = searchDir;
          break;
        }
        searchDir = dirname2(searchDir);
      }
    }
  }
  const sourcePath = join3(packageRoot, "command");
  const targetPath = inputPath;
  try {
    console.log(`\uD83D\uDD27 Package root: ${packageRoot}`);
    console.log(`\uD83D\uDE80 Setting up Codeflow for ${projectTypes.join(" and ")}...`);
    console.log(`\uD83D\uDCC1 Source: ${sourcePath}`);
    console.log(`\uD83D\uDCC1 Target: ${targetPath}`);
    const commandConverter = new CommandConverter;
    const commandCount = await copyCommands(commandConverter, sourcePath, targetPath, setupDirs, packageRoot);
    const skillsSetupDirs = setupDirs.filter((dir) => dir.includes("skills"));
    const skillsPath = join3(getPackageRoot(), "base-skills");
    const skillCount = await copySkills(skillsPath, targetPath, skillsSetupDirs, packageRoot);
    const fileCount = commandCount + skillCount;
    const readmePath = join3(targetPath, "README.md");
    const isMainProject = targetPath === process.cwd() && existsSync4(join3(targetPath, "package.json"));
    if (!isMainProject) {
      const typeDescription = projectTypes.length > 1 ? "multi-platform" : projectTypes[0];
      let readmeContent = "";
      if (existsSync4(readmePath)) {
        readmeContent = await readFile3(readmePath, "utf-8");
        if (readmeContent.includes("Generated by Codeflow CLI")) {} else {
          readmeContent += `

`;
        }
      } else {
        readmeContent = `# ${typeDescription.charAt(0).toUpperCase() + typeDescription.slice(1)} Project

`;
      }
      readmeContent += `## Codeflow Workflow

`;
      readmeContent += `### Available Commands

`;
      readmeContent += "- `/research` - Comprehensive codebase and documentation analysis\n";
      readmeContent += "- `/plan` - Create detailed implementation plans\n";
      readmeContent += "- `/execute` - Implement plans with verification\n";
      readmeContent += "- `/test` - Generate comprehensive test suites\n";
      readmeContent += "- `/document` - Create user guides and API documentation\n";
      readmeContent += "- `/commit` - Create structured git commits\n";
      readmeContent += "- `/review` - Validate implementations against plans\n";
      readmeContent += "- `/project-docs` - Generate complete project documentation\n\n";
      if (projectTypes.includes("claude-code")) {
        readmeContent += `### Claude Code Integration

` + "Commands are located in `.claude/commands/`.\n" + "Agents are located in `.claude/agents/`.\n" + "Skills are located in `.claude/skills/`.\n\n";
      }
      if (projectTypes.includes("opencode")) {
        readmeContent += `### OpenCode Integration

` + "Commands are located in `.opencode/command/`.\n" + "Agents are located in `.opencode/agent/`.\n" + "Skills are located in `.opencode/skills/`.\n";
      }
      if (projectTypes.includes("cursor")) {
        readmeContent += `### Cursor Integration

` + "Commands are located in `.cursor/commands/`.\n" + "Agents are located in `.cursor/agents/`.\n" + "Skills are located in `.cursor/skills/`.\n";
      }
      readmeContent += `
Generated by Codeflow CLI
`;
      await writeFile(readmePath, readmeContent);
      console.log(`  \u2713 Created/updated README.md with ${typeDescription} usage instructions`);
    } else {
      console.log(`  \u2713 Skipped README.md update (main project)`);
    }
    console.log(`
\u2705 Successfully set up ${projectTypes.length > 1 ? "multi-platform" : projectTypes[0]} project!`);
    console.log(`\uD83D\uDCC1 Installed ${fileCount} files`);
  } catch (error) {
    console.error(`\u274C Setup failed: ${error.message}`);
    throw error;
  }
}
function getAgentSourceDirs(_sourcePath, _targetFormat) {
  const sourceDirs = [];
  const packageRoot = getPackageRoot();
  const baseAgentsDir = join3(packageRoot, "base-agents");
  if (existsSync4(baseAgentsDir)) {
    sourceDirs.push(baseAgentsDir);
  }
  return sourceDirs;
}
async function copyAgentsWithConversion(sourcePath, targetPath, targetFormat) {
  const converter = new FormatConverter;
  const sourceDirs = getAgentSourceDirs(sourcePath, targetFormat);
  let agentsConverted = 0;
  for (const sourceDir of sourceDirs) {
    if (existsSync4(sourceDir)) {
      try {
        const { agents, errors: errors2 } = await parseAgentsFromDirectory(sourceDir, "base");
        console.log(`Found ${agents.length} agents in ${sourceDir}`);
        if (errors2.length > 0) {
          console.error(`Parse errors in ${sourceDir}:`, errors2);
        }
        for (const item of agents) {
          if ("mode" in item.frontmatter && item.frontmatter.mode === "command") {
            continue;
          }
          const agent = item;
          try {
            const convertedAgent = converter.convert(agent, targetFormat);
            const serialized = serializeAgent(convertedAgent);
            const targetFile = join3(targetPath, `${agent.name}.md`);
            await writeFile(targetFile, serialized);
            agentsConverted++;
          } catch (error) {
            console.error(`\u274C Failed to convert agent ${agent.name}: ${error.message}`);
          }
        }
      } catch (error) {
        console.error(`\u274C Failed to parse agents from ${sourceDir}: ${error.message}`);
      }
    }
  }
  return agentsConverted;
}

// src/cli/convert.ts
init_agent_parser();
import { join as join5 } from "path";
import { existsSync as existsSync5 } from "fs";
import { mkdir as mkdir3, writeFile as writeFile3 } from "fs/promises";

// src/security/opencode-permissions.ts
import { join as join4 } from "path";
import { readFile as readFile4, readdir as readdir3, writeFile as writeFile2 } from "fs/promises";

// src/security/validation.ts
var MAX_FILE_SIZE = 10 * 1024 * 1024;
class SecurityAuditLogger {
  logs = [];
  maxLogs = 1000;
  log(entry) {
    const auditEntry = {
      ...entry,
      timestamp: new Date().toISOString()
    };
    this.logs.unshift(auditEntry);
    if (this.logs.length > this.maxLogs) {
      this.logs.splice(this.maxLogs);
    }
  }
  getRecentLogs(limit = 100) {
    return this.logs.slice(0, limit);
  }
  getFailures(limit = 50) {
    return this.logs.filter((log) => log.result === "failure").slice(0, limit);
  }
  clear() {
    this.logs = [];
  }
}
var securityAuditLogger = new SecurityAuditLogger;
async function setFilePermissions(filePath, mode) {
  const { chmod } = await import("fs/promises");
  await chmod(filePath, mode);
}
async function setDirectoryPermissions(dirPath, mode) {
  const { chmod } = await import("fs/promises");
  await chmod(dirPath, mode);
}

// src/security/opencode-permissions.ts
init_agent_parser();
init_yaml_processor();
var DEFAULT_OPENCODE_PERMISSIONS = {
  osPermissions: {
    directories: 493,
    agentFiles: 420,
    commandFiles: 493
  },
  runtimePermissions: {
    primary: {
      edit: "allow",
      bash: "allow",
      webfetch: "allow"
    },
    subagent: {
      edit: "ask",
      bash: "ask",
      webfetch: "allow"
    }
  },
  defaultAllowedDirectories: [
    process.cwd(),
    join4(process.cwd(), "src"),
    join4(process.cwd(), "tests"),
    join4(process.cwd(), "docs"),
    join4(process.cwd(), "thoughts"),
    join4(process.cwd(), "packages", "*", "src"),
    join4(process.cwd(), "packages", "*", "tests")
  ]
};
async function applyOpenCodePermissionsToDirectory(dirPath, config) {
  await setDirectoryPermissions(dirPath, config.osPermissions.directories);
  const entries = await readdir3(dirPath, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = join4(dirPath, entry.name);
    if (entry.isDirectory()) {
      await setDirectoryPermissions(fullPath, config.osPermissions.directories);
    } else if (entry.name.endsWith(".md")) {
      const isCommand = entry.name.includes("command") || fullPath.includes("/command/");
      const fileMode = isCommand ? config.osPermissions.commandFiles : config.osPermissions.agentFiles;
      await setFilePermissions(fullPath, fileMode);
      if (!isCommand) {
        await updateOpenCodeAgentPermissions(fullPath, config);
      }
    }
  }
}
async function updateOpenCodeAgentPermissions(agentPath, config) {
  const content = await readFile4(agentPath, "utf-8");
  const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
  if (frontmatterMatch) {
    const { frontmatter } = parseFrontmatterFromContent(content);
    const normalizedFrontmatter = normalizePermissionFormat(frontmatter);
    const agentType = normalizedFrontmatter.mode === "primary" ? "primary" : "subagent";
    if (!normalizedFrontmatter.allowed_directories) {
      normalizedFrontmatter.allowed_directories = config.defaultAllowedDirectories;
    }
    if (!normalizedFrontmatter.permission) {
      const runtimePerms = config.runtimePermissions[agentType];
      normalizedFrontmatter.permission = {
        edit: runtimePerms.edit,
        bash: runtimePerms.bash,
        webfetch: runtimePerms.webfetch
      };
    }
    const updatedContent = serializeFrontmatter(content, normalizedFrontmatter);
    await writeFile2(agentPath, updatedContent);
  }
}
function parseFrontmatterFromContent(content) {
  const processor = new YamlProcessor;
  const result = processor.parse(content);
  if (!result.success) {
    throw new Error(result.error.message);
  }
  return {
    frontmatter: result.data.frontmatter,
    body: result.data.body
  };
}
function serializeFrontmatter(originalContent, frontmatter) {
  const processor = new YamlProcessor;
  const bodyMatch = originalContent.match(/\n---\n([\s\S]*)$/);
  const body = bodyMatch ? bodyMatch[1].trim() : "";
  const mockAgent = {
    name: frontmatter.name || "temp-agent",
    format: "opencode",
    frontmatter,
    content: body,
    filePath: "/tmp/temp.md"
  };
  const result = processor.serialize(mockAgent);
  if (!result.success) {
    throw new Error(result.error.message);
  }
  return result.data;
}

// src/cli/convert.ts
var AGENT_CATEGORIES = {
  development: [
    "analytics_engineer",
    "api_builder",
    "api_builder_enhanced",
    "code_reviewer",
    "codebase_analyzer",
    "codebase_locator",
    "codebase_pattern_finder",
    "database_expert",
    "development_migrations_specialist",
    "full_stack_developer",
    "performance_engineer",
    "system_architect"
  ],
  generalist: [
    "agent_architect",
    "smart_subagent_orchestrator",
    "research_analyzer",
    "research_locator",
    "web_search_researcher"
  ],
  "ai-innovation": ["ai_integration_expert"],
  operations: [
    "deployment_wizard",
    "devops_operations_specialist",
    "infrastructure_builder",
    "monitoring_expert",
    "operations_incident_commander"
  ],
  "quality-testing": ["security_scanner", "quality_testing_performance_tester"],
  "business-analytics": ["growth_engineer", "programmatic_seo_engineer"],
  "design-ux": ["accessibility_pro", "ux_optimizer"],
  "product-strategy": ["content_localization_coordinator"]
};
function findAgentCategory(agentName) {
  for (const [category, agents] of Object.entries(AGENT_CATEGORIES)) {
    if (agents.includes(agentName)) {
      return category;
    }
  }
  return "generalist";
}
async function convert(source, target, format) {
  const validation = error_handler_default.validateArguments([source, target], 2, "convert");
  if (!validation.valid) {
    error_handler_default.displayValidationResult(validation, "convert");
    return;
  }
  const sourceValidation = error_handler_default.validatePath(source, "directory");
  if (!sourceValidation.valid) {
    error_handler_default.displayValidationResult(sourceValidation, "source directory");
    return;
  }
  error_handler_default.displayProgress(`Converting agents from ${source} to ${target}`);
  error_handler_default.displayProgress(`Target format: ${format}`);
  try {
    const { agents, errors: parseErrors } = await parseAgentsFromDirectory(source, "base");
    if (parseErrors.length > 0) {
      error_handler_default.displayWarning(`Failed to parse some agents from ${source}`, [
        "Check agent file formats and syntax",
        "Run with --verbose for detailed error information"
      ]);
    }
    if (agents.length === 0) {
      error_handler_default.displayWarning("No agents found to convert", [
        "Check that the source directory contains valid agent files",
        "Verify file extensions (.md, .yaml, .json)"
      ]);
      return;
    }
    error_handler_default.displayProgress(`Found ${agents.length} agents to convert`);
    const converter = new FormatConverter;
    const agentOnly = agents.filter((item) => ("mode" in item.frontmatter) && item.frontmatter.mode !== "command");
    const convertedAgents = converter.convertBatch(agentOnly, format);
    error_handler_default.displayProgress(`Converted ${convertedAgents.length} agents to ${format} format`);
    if (!existsSync5(target)) {
      await mkdir3(target, { recursive: true });
      error_handler_default.displayProgress(`Created target directory: ${target}`);
    }
    let writeCount = 0;
    let writeErrors = 0;
    for (const agent of convertedAgents) {
      try {
        const filename = `${agent.frontmatter.name}.md`;
        let filePath;
        if (format === "claude-code") {
          const category = findAgentCategory(agent.frontmatter.name);
          const categoryPath = join5(target, category);
          await mkdir3(categoryPath, { recursive: true });
          filePath = join5(categoryPath, filename);
        } else {
          filePath = join5(target, filename);
        }
        const serialized = serializeAgent(agent);
        await writeFile3(filePath, serialized);
        writeCount++;
      } catch (error) {
        writeErrors++;
        error_handler_default.displayError(error_handler_default.createErrorContext("convert", "file_write", "write_error", "Successful file write operation", `${agent.frontmatter.name}: ${error.message}`, "Check file permissions and disk space", {
          requiresUserInput: true,
          suggestions: [
            "Verify write permissions for target directory",
            "Check available disk space",
            "Ensure target directory exists"
          ]
        }));
      }
    }
    if (format === "opencode" && writeCount > 0) {
      try {
        error_handler_default.displayProgress(`Applying OpenCode permissions to ${target}`);
        await applyOpenCodePermissionsToDirectory(target, DEFAULT_OPENCODE_PERMISSIONS);
        error_handler_default.displaySuccess("Applied OpenCode permissions");
      } catch (error) {
        error_handler_default.displayWarning(`Failed to apply OpenCode permissions: ${error.message}`, [
          "Check file system permissions",
          "Verify OpenCode security configuration",
          "Files were converted but permissions may not be optimal"
        ]);
      }
    }
    error_handler_default.displaySuccess(`Successfully converted ${writeCount} agents`, writeErrors > 0 ? [`${writeErrors} agents failed to write - check error details above`] : undefined);
    if (writeErrors > 0) {
      error_handler_default.displayWarning(`${writeErrors} agents failed to write`, [
        "Check the error details above for specific failures",
        "Verify target directory permissions and disk space"
      ]);
    }
    console.log(`
\uD83D\uDCCB Conversion Summary:`);
    console.log(`  Source: ${source}`);
    console.log(`  Target: ${target} (${format})`);
    console.log(`  Agents: ${agents.length} found, ${convertedAgents.length} converted`);
    if (format === "opencode") {
      console.log(`  Permissions: OpenCode runtime permissions applied`);
    }
  } catch (error) {
    error_handler_default.handleCommonError(error, "convert");
  }
}

// src/cli/sync.ts
init_agent_parser();
import { existsSync as existsSync10 } from "fs";
import { readdir as readdir7, copyFile as copyFile3, mkdir as mkdir6, writeFile as writeFile6 } from "fs/promises";
import { join as join9 } from "path";

// src/sync/canonical-syncer.ts
import { readFile as readFile5, readdir as readdir4 } from "fs/promises";
import { existsSync as existsSync7 } from "fs";
import { mkdir as mkdir4, copyFile as copyFile2, stat as stat2 } from "fs/promises";
import path, { basename as basename2 } from "path";
import os from "os";

// src/utils/manifest-discovery.ts
import { join as join6, dirname as dirname3 } from "path";
import { existsSync as existsSync6, copyFileSync, statSync } from "fs";
async function findAgentManifest(options = {}) {
  const {
    cwd = process.cwd(),
    allowLegacy = true,
    maxDepth = 10
  } = options;
  let currentDir = cwd;
  let level = 0;
  while (level <= maxDepth) {
    const manifestPath = join6(currentDir, "AGENT_MANIFEST.json");
    if (existsSync6(manifestPath)) {
      return {
        path: manifestPath,
        isLegacy: false,
        level
      };
    }
    if (allowLegacy) {
      const legacyPath = join6(currentDir, ".codeflow", "AGENT_MANIFEST.json");
      if (existsSync6(legacyPath)) {
        return {
          path: legacyPath,
          isLegacy: true,
          level
        };
      }
    }
    const parentDir = dirname3(currentDir);
    if (parentDir === currentDir) {
      break;
    }
    currentDir = parentDir;
    level++;
  }
  throw new Error(`AGENT_MANIFEST.json not found in current directory or any parent directories.
` + `
Possible solutions:
` + `1. Run this command from the codeflow repository root
` + `2. Copy AGENT_MANIFEST.json to your project directory
` + `3. Run "codeflow setup" to initialize the project properly
` + `
For more help, see: https://github.com/your-repo/codeflow#troubleshooting`);
}

// src/sync/canonical-syncer.ts
class CanonicalSyncer {
  syncHealth = {
    lastSyncTime: new Date(0),
    totalAgents: 0,
    syncedAgents: 0,
    failedAgents: 0,
    averageSyncTime: 0,
    errorRate: 0
  };
  async loadManifest() {
    try {
      const discovery = await findAgentManifest();
      return JSON.parse(await readFile5(discovery.path, "utf-8"));
    } catch (error) {
      throw new Error(`AGENT_MANIFEST.json not found. ${error.message}`);
    }
  }
  async syncFromCanonical(options) {
    const syncStartTime = performance.now();
    const manifest = await this.loadManifest();
    const result = { synced: [], skipped: [], errors: [] };
    const tempFiles = [];
    this.syncHealth.totalAgents = manifest.canonical_agents?.length || 0;
    try {
      const validAgents = await this.validateAllAgents(manifest.canonical_agents || [], options, result);
      if (result.errors.length > 0 && !options.force) {
        throw new Error(`${result.errors.length} agents failed validation. Use --force to override.`);
      }
      for (const agent of validAgents) {
        const tempFilesForAgent = await this.convertAndWriteToTemp(agent, options);
        tempFiles.push(...tempFilesForAgent);
      }
      if (options.target === "global" || options.target === "all" || options.target === "project") {
        const commandTempFiles = await this.syncCommands(options);
        tempFiles.push(...commandTempFiles);
      }
      await this.commitSync(tempFiles, result);
      const syncEndTime = performance.now();
      const syncDuration = syncEndTime - syncStartTime;
      this.updateSyncHealth(result, syncDuration);
    } catch (error) {
      this.syncHealth.failedAgents += 1;
      this.syncHealth.lastError = error.message;
      this.syncHealth.errorRate = this.calculateErrorRate();
      await this.rollbackSync(tempFiles);
      throw error;
    }
    return result;
  }
  async validateAllAgents(agents, options, result) {
    const validAgents = [];
    for (const agent of agents) {
      const sourceFile = agent.sources[options.sourceFormat];
      try {
        if (!sourceFile || !existsSync7(sourceFile)) {
          result.errors.push({
            agent: agent.name,
            type: "filesystem" /* FILE_SYSTEM */,
            message: `Source file not found: ${sourceFile}`,
            filePath: sourceFile,
            suggestion: "Check that the agent file exists in the source directory"
          });
          continue;
        }
        const { parseAgentFile: parseAgentFile2 } = await Promise.resolve().then(() => (init_agent_parser(), exports_agent_parser));
        const sourceAgent = await parseAgentFile2(sourceFile, options.sourceFormat);
        const { ValidationEngine: ValidationEngine2 } = await Promise.resolve().then(() => (init_validation_engine(), exports_validation_engine));
        const validator = new ValidationEngine2;
        const validationResult = validator.validate(sourceAgent);
        if (!validationResult.valid) {
          const errorMessages = validationResult.errors.map((e) => e.message).join("; ");
          result.errors.push({
            agent: agent.name,
            type: "validation" /* VALIDATION */,
            message: `Validation failed: ${errorMessages}`,
            filePath: sourceFile,
            suggestion: "Fix the validation errors in the agent file before syncing"
          });
          continue;
        }
        validAgents.push({ agent, sourceFile, sourceAgent });
      } catch (error) {
        result.errors.push({
          agent: agent.name,
          type: "parsing" /* PARSING */,
          message: `Failed to parse/validate agent: ${error.message}`,
          filePath: sourceFile,
          suggestion: "Check the YAML syntax and required fields in the agent file"
        });
      }
    }
    return validAgents;
  }
  async convertAndWriteToTemp(agentData, options) {
    const { agent, sourceFile } = agentData;
    const targetPaths = this.getTargetPaths(agent.name, options.target);
    const tempFiles = [];
    for (const targetPath of targetPaths) {
      const tempPath = `${targetPath}.tmp`;
      await this.syncFile(sourceFile, tempPath, options.sourceFormat, this.detectTargetFormat(targetPath), agent.name);
      tempFiles.push(tempPath);
    }
    return tempFiles;
  }
  async commitSync(tempFiles, result) {
    for (const tempFile of tempFiles) {
      const finalPath = tempFile.replace(".tmp", "");
      await copyFile2(tempFile, finalPath);
      await import("fs/promises").then((fs) => fs.unlink(tempFile));
      result.synced.push({
        from: tempFile.replace(".tmp", ""),
        to: finalPath,
        agent: basename2(finalPath, ".md")
      });
    }
  }
  async rollbackSync(tempFiles) {
    for (const tempFile of tempFiles) {
      try {
        await import("fs/promises").then((fs) => fs.unlink(tempFile));
      } catch {}
    }
  }
  updateSyncHealth(result, duration) {
    this.syncHealth.lastSyncTime = new Date;
    this.syncHealth.syncedAgents = result.synced.length;
    this.syncHealth.failedAgents = result.errors.length;
    const alpha = 0.1;
    this.syncHealth.averageSyncTime = this.syncHealth.averageSyncTime === 0 ? duration : this.syncHealth.averageSyncTime * (1 - alpha) + duration * alpha;
    this.syncHealth.errorRate = this.calculateErrorRate();
    this.syncHealth.lastError = undefined;
  }
  calculateErrorRate() {
    if (this.syncHealth.totalAgents === 0)
      return 0;
    return this.syncHealth.failedAgents / this.syncHealth.totalAgents;
  }
  getSyncHealth() {
    return { ...this.syncHealth };
  }
  getSyncHealthSummary() {
    const health = this.syncHealth;
    const errorRatePercent = (health.errorRate * 100).toFixed(1);
    let status2;
    let message;
    if (health.errorRate > 0.5) {
      status2 = "critical";
      message = `Critical: ${errorRatePercent}% sync failure rate`;
    } else if (health.errorRate > 0.2) {
      status2 = "warning";
      message = `Warning: ${errorRatePercent}% sync failure rate`;
    } else {
      status2 = "healthy";
      message = `Healthy: ${errorRatePercent}% sync failure rate`;
    }
    if (health.lastError) {
      message += ` - Last error: ${health.lastError}`;
    }
    return {
      status: status2,
      message,
      metrics: {
        lastSyncTime: health.lastSyncTime,
        totalAgents: health.totalAgents,
        syncedAgents: health.syncedAgents,
        failedAgents: health.failedAgents,
        averageSyncTime: Math.round(health.averageSyncTime),
        errorRate: health.errorRate
      }
    };
  }
  getTargetPaths(agentName, target) {
    const paths = [];
    if (target === "project" || target === "all") {
      paths.push(path.join(process.cwd(), ".claude", "agents", `${agentName}.md`));
      paths.push(path.join(process.cwd(), ".opencode", "agent", `${agentName}.md`));
    }
    if (target === "global" || target === "all") {
      const homeDir = os.homedir();
      paths.push(path.join(homeDir, ".claude", "agents", `${agentName}.md`));
      paths.push(path.join(homeDir, ".config", "opencode", "agent", `${agentName}.md`));
    }
    return paths;
  }
  async syncFile(sourcePath, targetPath, sourceFormat, targetFormat, agentName) {
    const targetDir = path.dirname(targetPath);
    await mkdir4(targetDir, { recursive: true });
    if (sourceFormat === targetFormat) {
      await copyFile2(sourcePath, targetPath);
    } else {
      const { FormatConverter: FormatConverter2 } = await Promise.resolve().then(() => exports_format_converter);
      const { parseAgentFile: parseAgentFile2 } = await Promise.resolve().then(() => (init_agent_parser(), exports_agent_parser));
      const sourceAgent = await parseAgentFile2(sourcePath, sourceFormat);
      const converter = new FormatConverter2;
      const convertedAgent = converter.convert(sourceAgent, targetFormat);
      const { YamlProcessor: YamlProcessor2 } = await Promise.resolve().then(() => (init_yaml_processor(), exports_yaml_processor));
      const processor = new YamlProcessor2;
      const yamlResult = processor.serialize(convertedAgent);
      if (!yamlResult.success) {
        throw new Error(`YAML serialization failed for ${agentName}: ${yamlResult.error.message}`);
      }
      const content = yamlResult.data;
      await Bun.write(targetPath, content);
    }
  }
  async shouldSyncFile(sourcePath, targetPath, force) {
    if (force)
      return true;
    try {
      const [sourceStats, targetStats] = await Promise.all([stat2(sourcePath), stat2(targetPath)]);
      return sourceStats.mtime > targetStats.mtime || Math.abs(sourceStats.size - targetStats.size) > 100;
    } catch {
      return true;
    }
  }
  detectTargetFormat(targetPath) {
    if (targetPath.includes(".claude/"))
      return "claude-code";
    if (targetPath.includes(".opencode/") || targetPath.includes(".config/opencode/"))
      return "opencode";
    return "base";
  }
  async syncCommands(options) {
    const tempFiles = [];
    const codeflowRoot = path.join(process.cwd());
    const sourceCommandDir = path.join(codeflowRoot, "command");
    if (!existsSync7(sourceCommandDir)) {
      return tempFiles;
    }
    const { CommandConverter: CommandConverter2 } = await Promise.resolve().then(() => (init_command_converter(), exports_command_converter));
    const converter = new CommandConverter2;
    try {
      const files = await readdir4(sourceCommandDir);
      const mdFiles = files.filter((f) => f.endsWith(".md"));
      for (const file of mdFiles) {
        const sourceFile = path.join(sourceCommandDir, file);
        const targetPaths = [];
        if (options.target === "global" || options.target === "all") {
          targetPaths.push({
            path: path.join(os.homedir(), ".claude", "commands", file),
            format: "claude-code"
          }, {
            path: path.join(os.homedir(), ".config", "opencode", "command", file),
            format: "opencode"
          });
        }
        if (options.target === "project" || options.target === "all") {
          const projectPath = options.projectPath || process.cwd();
          targetPaths.push({
            path: path.join(projectPath, ".claude", "commands", file),
            format: "claude-code"
          }, {
            path: path.join(projectPath, ".opencode", "command", file),
            format: "opencode"
          });
        }
        for (const target of targetPaths) {
          const tempPath = `${target.path}.tmp`;
          try {
            const targetDir = path.dirname(target.path);
            await mkdir4(targetDir, { recursive: true });
            const convertedContent = await converter.convertFile(sourceFile, target.format);
            await Bun.write(tempPath, convertedContent);
            tempFiles.push(tempPath);
          } catch (error) {
            console.error(`Failed to sync command ${file}: ${error.message}`);
          }
        }
      }
    } catch (error) {
      console.error(`Failed to sync commands: ${error.message}`);
    }
    return tempFiles;
  }
  async syncToProject(sourceFormat = "base", force = false) {
    return this.syncFromCanonical({
      target: "project",
      sourceFormat,
      dryRun: false,
      force
    });
  }
  async syncToGlobal(sourceFormat = "base", force = false) {
    return this.syncFromCanonical({
      target: "global",
      sourceFormat,
      dryRun: false,
      force
    });
  }
  async dryRun(target, sourceFormat = "base") {
    return this.syncFromCanonical({
      target,
      sourceFormat,
      dryRun: true,
      force: false
    });
  }
}

// src/cli/sync.ts
import { homedir as homedir2 } from "os";

// src/yaml/command-validator.ts
init_validation_engine();
init_yaml_processor();
import { readFile as readFile6, readdir as readdir5 } from "fs/promises";
import { join as join7 } from "path";
import { existsSync as existsSync8 } from "fs";

class CommandValidator {
  validator;
  processor;
  variablePattern = /\{\{([^}]+)\}\}/g;
  constructor() {
    this.validator = new ValidationEngine;
    this.processor = new YamlProcessor;
  }
  async validateDirectory(directoryPath, format = "opencode") {
    const startTime = performance.now();
    if (!existsSync8(directoryPath)) {
      throw new Error(`Directory does not exist: ${directoryPath}`);
    }
    const errors2 = [];
    const warnings = [];
    let totalCommands = 0;
    try {
      const files = await this.findCommandFiles(directoryPath);
      for (const file of files) {
        try {
          const result = await this.validateFile(file, format);
          if (!result.valid) {
            errors2.push(...result.errors);
          }
          warnings.push(...result.warnings);
          totalCommands++;
        } catch (error) {
          errors2.push({
            file,
            message: `Failed to validate command file: ${error.message}`,
            code: "FILE_VALIDATION_ERROR",
            severity: "error"
          });
        }
      }
    } catch (error) {
      errors2.push({
        file: directoryPath,
        message: `Failed to read directory: ${error.message}`,
        code: "DIRECTORY_READ_ERROR",
        severity: "error"
      });
    }
    const processingTime = performance.now() - startTime;
    return {
      valid: errors2.length === 0,
      errors: errors2,
      warnings,
      metadata: {
        fileCount: await this.countFiles(directoryPath),
        totalCommands,
        processingTime
      }
    };
  }
  async validateFile(filePath, format = "opencode") {
    const errors2 = [];
    const warnings = [];
    try {
      const content = await readFile6(filePath, "utf-8");
      const parseResult = this.processor.parse(content);
      if (!parseResult.success) {
        errors2.push({
          file: filePath,
          message: `YAML parsing failed: ${parseResult.error.message}`,
          code: "YAML_PARSE_ERROR",
          severity: "error"
        });
        return { valid: false, errors: errors2, warnings };
      }
      const parsed = parseResult.data;
      if (!parsed.frontmatter) {
        errors2.push({
          file: filePath,
          message: "Command file must have YAML frontmatter",
          code: "MISSING_FRONTMATTER",
          severity: "error"
        });
        return { valid: false, errors: errors2, warnings };
      }
      const schemaValidation = this.validateSchema(parsed.frontmatter, format);
      if (!schemaValidation.valid) {
        errors2.push(...schemaValidation.errors);
      }
      const variableValidation = this.validateVariableReferences(content, parsed.frontmatter);
      errors2.push(...variableValidation.errors);
      warnings.push(...variableValidation.warnings);
      const yamlValidation = await this.validateYamlSyntax(content);
      errors2.push(...yamlValidation.errors);
      warnings.push(...yamlValidation.warnings);
    } catch (error) {
      errors2.push({
        file: filePath,
        message: `Failed to parse command file: ${error.message}`,
        code: "PARSE_ERROR",
        severity: "error"
      });
    }
    return {
      valid: errors2.length === 0,
      errors: errors2,
      warnings
    };
  }
  validateSchema(frontmatter, format) {
    const errors2 = [];
    if (format === "opencode") {
      return this.validateOpenCodeSchema(frontmatter, errors2);
    } else {
      return this.validateClaudeCodeSchema(frontmatter, errors2);
    }
  }
  validateOpenCodeSchema(frontmatter, errors2) {
    if (!frontmatter.name || typeof frontmatter.name !== "string") {
      errors2.push({
        file: "frontmatter",
        message: "Command must have a name field",
        code: "MISSING_NAME",
        severity: "error"
      });
    }
    if (!frontmatter.description || typeof frontmatter.description !== "string") {
      errors2.push({
        file: "frontmatter",
        message: "Command must have a description field",
        code: "MISSING_DESCRIPTION",
        severity: "error"
      });
    }
    if (!frontmatter.mode || frontmatter.mode !== "command") {
      errors2.push({
        file: "frontmatter",
        message: 'OpenCode commands must have mode: "command"',
        code: "INVALID_MODE",
        severity: "error"
      });
    }
    if (frontmatter.inputs) {
      if (!Array.isArray(frontmatter.inputs)) {
        errors2.push({
          file: "frontmatter",
          message: "inputs must be an array",
          code: "INVALID_INPUTS_FORMAT",
          severity: "error"
        });
      } else {
        frontmatter.inputs.forEach((input, index) => {
          if (!input.name || !input.type) {
            errors2.push({
              file: "frontmatter",
              message: `Input at index ${index} must have name and type`,
              code: "INVALID_INPUT_SCHEMA",
              severity: "error"
            });
          }
          if (typeof input.required !== "boolean") {
            errors2.push({
              file: "frontmatter",
              message: `Input "${input.name}" must specify required as boolean`,
              code: "INVALID_INPUT_REQUIRED",
              severity: "error"
            });
          }
        });
      }
    }
    if (frontmatter.outputs) {
      if (!Array.isArray(frontmatter.outputs)) {
        errors2.push({
          file: "frontmatter",
          message: "outputs must be an array",
          code: "INVALID_OUTPUTS_FORMAT",
          severity: "error"
        });
      }
    }
    if (frontmatter.cache_strategy) {
      const validTypes = ["content_based", "time_based", "none"];
      if (!validTypes.includes(frontmatter.cache_strategy.type)) {
        errors2.push({
          file: "frontmatter",
          message: `Cache strategy type must be one of: ${validTypes.join(", ")}`,
          code: "INVALID_CACHE_TYPE",
          severity: "error"
        });
      }
      if (frontmatter.cache_strategy.ttl !== undefined && typeof frontmatter.cache_strategy.ttl !== "number") {
        errors2.push({
          file: "frontmatter",
          message: "Cache strategy ttl must be a number",
          code: "INVALID_CACHE_TTL",
          severity: "error"
        });
      }
    }
    return {
      valid: errors2.length === 0,
      errors: errors2
    };
  }
  validateClaudeCodeSchema(frontmatter, errors2) {
    if (!frontmatter.name || typeof frontmatter.name !== "string") {
      errors2.push({
        file: "frontmatter",
        message: "Command must have a name field",
        code: "MISSING_NAME",
        severity: "error"
      });
    }
    if (!frontmatter.description || typeof frontmatter.description !== "string") {
      errors2.push({
        file: "frontmatter",
        message: "Command must have a description field",
        code: "MISSING_DESCRIPTION",
        severity: "error"
      });
    }
    if (!frontmatter.model || typeof frontmatter.model !== "string") {
      errors2.push({
        file: "frontmatter",
        message: "Claude Code commands must have a model field",
        code: "MISSING_MODEL",
        severity: "error"
      });
    }
    if (frontmatter.model && !frontmatter.model.includes("claude")) {
      errors2.push({
        file: "frontmatter",
        message: "Claude Code commands should use Claude models",
        code: "INVALID_MODEL",
        severity: "warning"
      });
    }
    if (frontmatter.temperature !== undefined) {
      if (typeof frontmatter.temperature !== "number" || frontmatter.temperature < 0 || frontmatter.temperature > 1) {
        errors2.push({
          file: "frontmatter",
          message: "Temperature must be a number between 0 and 1",
          code: "INVALID_TEMPERATURE",
          severity: "error"
        });
      } else if (frontmatter.temperature > 0.5) {
        errors2.push({
          file: "frontmatter",
          message: "Commands should use lower temperature (<= 0.5) for consistency",
          code: "HIGH_TEMPERATURE",
          severity: "warning"
        });
      }
    }
    if (!frontmatter.category) {
      errors2.push({
        file: "frontmatter",
        message: "Claude Code commands should have a category",
        code: "MISSING_CATEGORY",
        severity: "warning"
      });
    }
    if (frontmatter.params) {
      if (typeof frontmatter.params !== "object") {
        errors2.push({
          file: "frontmatter",
          message: "params must be an object",
          code: "INVALID_PARAMS_FORMAT",
          severity: "error"
        });
      } else {
        if (frontmatter.params.required && !Array.isArray(frontmatter.params.required)) {
          errors2.push({
            file: "frontmatter",
            message: "params.required must be an array",
            code: "INVALID_REQUIRED_PARAMS",
            severity: "error"
          });
        }
        if (frontmatter.params.optional && !Array.isArray(frontmatter.params.optional)) {
          errors2.push({
            file: "frontmatter",
            message: "params.optional must be an array",
            code: "INVALID_OPTIONAL_PARAMS",
            severity: "error"
          });
        }
      }
    }
    return {
      valid: errors2.length === 0,
      errors: errors2
    };
  }
  validateVariableReferences(content, frontmatter) {
    const errors2 = [];
    const warnings = [];
    const variableMatches = content.match(this.variablePattern);
    if (variableMatches) {
      const referencedVariables = variableMatches.map((match) => match.replace(/\{\{|\}\}/g, ""));
      const definedInputs = frontmatter.inputs || [];
      const inputNames = definedInputs.map((input) => input.name);
      referencedVariables.forEach((variable) => {
        if (!inputNames.includes(variable)) {
          errors2.push({
            file: "content",
            message: `Variable "{{${variable}}}" is not defined in inputs`,
            code: "UNDEFINED_VARIABLE",
            severity: "error",
            suggestion: `Add "${variable}" to the inputs array or remove the reference`
          });
        }
      });
    }
    if (frontmatter.inputs && frontmatter.inputs.length > 0) {
      const definedInputs = frontmatter.inputs.map((input) => input.name);
      const referencedVariables = (content.match(this.variablePattern) || []).map((match) => match.replace(/\{\{|\}\}/g, ""));
      definedInputs.forEach((inputName) => {
        if (!referencedVariables.includes(inputName)) {
          warnings.push({
            file: "frontmatter",
            message: `Input "${inputName}" is defined but not used in content`,
            suggestion: `Remove unused input or add {{${inputName}}} reference to content`
          });
        }
      });
    }
    return { errors: errors2, warnings };
  }
  async validateYamlSyntax(content) {
    const errors2 = [];
    const warnings = [];
    try {
      const parseResult = this.processor.parse(content);
      if (!parseResult.success) {
        errors2.push({
          file: "yaml",
          message: `YAML syntax error: ${parseResult.error.message}`,
          code: "YAML_SYNTAX_ERROR",
          severity: "error"
        });
        return { errors: errors2, warnings };
      }
    } catch (error) {
      errors2.push({
        file: "yaml",
        message: `YAML syntax error: ${error.message}`,
        code: "YAML_SYNTAX_ERROR",
        severity: "error"
      });
    }
    return { errors: errors2, warnings };
  }
  async findCommandFiles(directoryPath) {
    const files = [];
    async function scanDirectory(dir) {
      const entries = await readdir5(dir, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = join7(dir, entry.name);
        if (entry.isDirectory()) {
          await scanDirectory(fullPath);
        } else if (entry.isFile() && entry.name.endsWith(".md")) {
          try {
            const content = await readFile6(fullPath, "utf-8");
            const parseResult = new YamlProcessor().parse(content);
            if (parseResult.success && parseResult.data.frontmatter && parseResult.data.frontmatter.mode === "command") {
              files.push(fullPath);
            }
          } catch {}
        }
      }
    }
    await scanDirectory(directoryPath);
    return files;
  }
  async countFiles(directoryPath) {
    let count = 0;
    async function scanDirectory(dir) {
      const entries = await readdir5(dir, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = join7(dir, entry.name);
        if (entry.isDirectory()) {
          await scanDirectory(fullPath);
        } else {
          count++;
        }
      }
    }
    await scanDirectory(directoryPath);
    return count;
  }
  generateFixes(errors2) {
    const fixes = [
      "# Command Validation Fix Report",
      "",
      "## Summary",
      `${errors2.length} validation errors found`,
      "",
      "## Fixes"
    ];
    errors2.forEach((error, index) => {
      fixes.push(`
### Error ${index + 1}: ${error.code}`);
      fixes.push(`**File:** ${error.file}`);
      fixes.push(`**Message:** ${error.message}`);
      if (error.suggestion) {
        fixes.push(`**Suggestion:** ${error.suggestion}`);
      }
      fixes.push("");
    });
    return fixes.join(`
`);
  }
}

// src/sync-with-validation.ts
import { readdir as readdir6, writeFile as writeFile5, mkdir as mkdir5, readFile as readFile8 } from "fs/promises";
import { existsSync as existsSync9 } from "fs";
import { join as join8, basename as basename3 } from "path";
import { homedir } from "os";

// src/utils/yaml-validator.ts
init_dist();
import { readFile as readFile7, writeFile as writeFile4 } from "fs/promises";
var YAML_FIXES = [
  {
    pattern: /^(\s*(?:description|help|prompt|text|message|content|value|default|example|note|comment|label|title|name|tooltip|placeholder|error|warning|info|success):\s*)([^"'\n]*?)\s*:\s*([^"'\n]*?)$/gm,
    fix: (match, prefix, beforeColon, afterColon) => {
      if (beforeColon && afterColon) {
        const value = `${beforeColon}: ${afterColon}`.trim();
        return `${prefix}'${value}'`;
      }
      return match;
    },
    description: "Quote values containing colons"
  },
  {
    pattern: /^(\s*(?:description|help|prompt|text|message|content|value|default|example|note|comment|label|title|name|tooltip|placeholder|error|warning|info|success):\s*)([^"'\n]*?\(.*?:.*?\)[^"'\n]*?)$/gm,
    fix: (match, prefix, value) => {
      if (!value.startsWith('"') && !value.startsWith("'")) {
        return `${prefix}'${value}'`;
      }
      return match;
    },
    description: "Quote values with parentheses containing colons"
  },
  {
    pattern: /^(\s*(?:description|help|prompt|text|message|content|value|instructions):\s*)([^"'\n][^\n]*\n\s+[^\n]+)/gm,
    fix: (match, prefix, value) => {
      const lines = value.split(`
`).map((l) => l.trim());
      return `${prefix}|
  ${lines.join(`
  `)}`;
    },
    description: "Use pipe notation for multiline strings"
  }
];
function validateYAML(content) {
  const errors2 = [];
  const warnings = [];
  try {
    $parse(content);
    return { valid: true, errors: errors2, warnings };
  } catch (error) {
    const errorMessage = error.message || "Unknown YAML error";
    const line = error.mark?.line;
    const column = error.mark?.column;
    errors2.push(`YAML Parse Error at line ${line}, column ${column}: ${errorMessage}`);
    const fixed = attemptAutoFix(content, error);
    if (fixed && fixed !== content) {
      try {
        $parse(fixed);
        warnings.push("YAML was auto-fixed");
        return { valid: true, errors: [], warnings, fixed };
      } catch {
        errors2.push("Auto-fix attempted but failed");
      }
    }
    return { valid: false, errors: errors2, warnings };
  }
}
function attemptAutoFix(content, error) {
  let fixed = content;
  for (const fix of YAML_FIXES) {
    fixed = fixed.replace(fix.pattern, fix.fix);
  }
  if (error.message.includes("incomplete explicit mapping pair")) {
    const lines = fixed.split(`
`);
    const errorLine = error.mark?.line - 1;
    if (errorLine >= 0 && errorLine < lines.length) {
      const line = lines[errorLine];
      const match = line.match(/^(\s*)(description|help|prompt|text|message|content|value):\s*(.+)$/);
      if (match) {
        const [, indent, key, value] = match;
        if (value.includes(":") && !value.startsWith('"') && !value.startsWith("'")) {
          lines[errorLine] = `${indent}${key}: '${value}'`;
          fixed = lines.join(`
`);
        }
      }
    }
  }
  return fixed;
}
async function validateMarkdownYAML(filePath) {
  try {
    const content = await readFile7(filePath, "utf-8");
    if (!content.startsWith(`---
`)) {
      return { valid: true, errors: [], warnings: ["No frontmatter found"] };
    }
    const parts = content.split(`---
`);
    if (parts.length < 3) {
      return {
        valid: false,
        errors: ["Invalid frontmatter structure"],
        warnings: []
      };
    }
    const frontmatter = parts[1];
    const result = validateYAML(frontmatter);
    if (filePath.includes("/skills/") || filePath.includes("\\skills\\")) {
      const skillValidation = validateSkillFrontmatter(frontmatter);
      result.errors.push(...skillValidation.errors);
      result.warnings.push(...skillValidation.warnings);
      result.valid = result.valid && skillValidation.valid;
    }
    if (result.fixed) {
      const newContent = `---
${result.fixed}---
${parts.slice(2).join(`---
`)}`;
      result.fixed = newContent;
    }
    return result;
  } catch (error) {
    return {
      valid: false,
      errors: [`Failed to read file: ${error.message}`],
      warnings: []
    };
  }
}
function validateSkillFrontmatter(frontmatter) {
  const errors2 = [];
  const warnings = [];
  try {
    const parsed = $parse(frontmatter);
    if (!parsed.name) {
      errors2.push("Missing required field: name");
    } else if (typeof parsed.name !== "string") {
      errors2.push('Field "name" must be a string');
    } else if (!/^[a-z0-9-]+$/.test(parsed.name)) {
      errors2.push('Field "name" must be hyphen-case (lowercase letters, numbers, and hyphens only)');
    }
    if (!parsed.description) {
      errors2.push("Missing required field: description");
    } else if (typeof parsed.description !== "string") {
      errors2.push('Field "description" must be a string');
    } else if (parsed.description.length < 20) {
      errors2.push('Field "description" must be at least 20 characters long');
    }
    if (parsed.noReply === undefined) {
      errors2.push("Missing required field: noReply");
    } else if (typeof parsed.noReply !== "boolean") {
      errors2.push('Field "noReply" must be a boolean');
    } else if (!parsed.noReply) {
      errors2.push('Field "noReply" must be true for skills (required for message insertion persistence)');
    }
    if (parsed.category && typeof parsed.category !== "string") {
      errors2.push('Field "category" must be a string');
    }
    if (parsed.tags && !Array.isArray(parsed.tags)) {
      errors2.push('Field "tags" must be an array');
    }
    return {
      valid: errors2.length === 0,
      errors: errors2,
      warnings
    };
  } catch (error) {
    return {
      valid: false,
      errors: [`Failed to parse skill frontmatter: ${error.message}`],
      warnings: []
    };
  }
}
async function fixYAMLFile(filePath) {
  const result = await validateMarkdownYAML(filePath);
  if (result.fixed) {
    try {
      await writeFile4(filePath, result.fixed, "utf-8");
      console.log(`\u2705 Fixed YAML in ${filePath}`);
      return true;
    } catch (error) {
      console.error(`\u274C Failed to write fixed file: ${error}`);
      return false;
    }
  }
  return result.valid;
}
if (false) {}

// src/sync-with-validation.ts
init_agent_parser();

class SyncManager {
  projectRoot;
  homeDir;
  constructor() {
    this.projectRoot = process.cwd();
    this.homeDir = homedir();
  }
  getPaths(global = false) {
    const base = global ? this.homeDir : this.projectRoot;
    return {
      agents: {
        source: join8(this.projectRoot, "base-agents"),
        claude: join8(base, ".claude", "agents"),
        opencode: join8(base, ".opencode", "agent"),
        globalClaude: join8(this.homeDir, ".claude", "agents"),
        globalOpenCode: join8(this.homeDir, ".config", "opencode", "agent")
      },
      commands: {
        source: join8(this.projectRoot, "command"),
        claude: join8(base, ".claude", "commands"),
        opencode: join8(base, ".opencode", "command"),
        globalClaude: join8(this.homeDir, ".claude", "commands"),
        globalOpenCode: join8(this.homeDir, ".config", "opencode", "command")
      },
      skills: {
        source: join8(this.projectRoot, "base-skills"),
        claude: join8(base, ".claude", "skills"),
        opencode: join8(base, ".opencode", "skill"),
        globalClaude: join8(this.homeDir, ".claude", "skills"),
        globalOpenCode: join8(this.homeDir, ".config", "opencode", "skill")
      }
    };
  }
  async findAllMarkdownFiles(dir) {
    const files = [];
    try {
      const entries = await readdir6(dir, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = join8(dir, entry.name);
        if (entry.isDirectory()) {
          const subFiles = await this.findAllMarkdownFiles(fullPath);
          files.push(...subFiles);
        } else if (entry.isFile() && entry.name.endsWith(".md")) {
          files.push(fullPath);
        }
      }
    } catch {}
    return files;
  }
  getTargetFormat(targetPath) {
    if (targetPath.includes(".claude")) {
      return "claude-code";
    } else if (targetPath.includes(".opencode")) {
      return "opencode";
    } else if (targetPath.includes(".cursor")) {
      return "cursor";
    }
    return "base";
  }
  isCommandFile(filePath) {
    if (filePath.includes("/command/") || filePath.includes("\\command\\")) {
      return true;
    }
    const paths = this.getPaths();
    if (filePath.startsWith(paths.commands.source)) {
      return true;
    }
    const commandSourcePath = join8(this.projectRoot, "command");
    if (filePath.startsWith(commandSourcePath)) {
      return true;
    }
    return false;
  }
  isSkillFile(filePath) {
    if (filePath.includes("/skills/") || filePath.includes("\\skills\\")) {
      return true;
    }
    const paths = this.getPaths();
    if (filePath.startsWith(paths.skills.source)) {
      return true;
    }
    const skillsSourcePath = join8(this.projectRoot, "base-skills");
    if (filePath.startsWith(skillsSourcePath)) {
      return true;
    }
    return false;
  }
  async syncFile(sourcePath, targetPath, options) {
    try {
      let wasFixed = false;
      if (options.validate !== false) {
        const validation = await validateMarkdownYAML(sourcePath);
        if (!validation.valid) {
          if (options.fix) {
            const fixed = await fixYAMLFile(sourcePath);
            if (!fixed) {
              if (options.verbose) {
                console.error(`  \u274C Cannot fix YAML in ${basename3(sourcePath)}`);
              }
              return "error";
            }
            if (options.verbose) {
              console.log(`  \uD83D\uDD27 Fixed YAML in ${basename3(sourcePath)}`);
            }
            wasFixed = true;
          } else {
            if (options.verbose) {
              console.error(`  \u26A0\uFE0F  Skipping ${basename3(sourcePath)} - invalid YAML`);
            }
            return "skipped";
          }
        } else if (validation.fixed) {
          wasFixed = true;
        }
      }
      const targetFormat = this.getTargetFormat(targetPath);
      const isCommand = this.isCommandFile(sourcePath);
      const isSkill = this.isSkillFile(sourcePath);
      let convertedContent;
      try {
        if (isCommand) {
          const command = await parseCommandFile(sourcePath, "base");
          const converter = new FormatConverter;
          const convertedCommand = converter.convert(command, targetFormat);
          convertedContent = serializeCommand(convertedCommand);
        } else if (isSkill) {
          const content = await readFile8(sourcePath, "utf-8");
          convertedContent = content;
        } else {
          const agent = await parseAgentFile(sourcePath, "base");
          const converter = new FormatConverter;
          const convertedAgent = converter.convert(agent, targetFormat);
          convertedContent = serializeAgent(convertedAgent);
        }
      } catch (conversionError) {
        if (options.verbose) {
          console.error(`  \u274C Conversion failed for ${basename3(sourcePath)}: ${conversionError.message}`);
        }
        return "error";
      }
      const targetDir = join8(targetPath, "..");
      if (!existsSync9(targetDir)) {
        await mkdir5(targetDir, { recursive: true });
      }
      await writeFile5(targetPath, convertedContent, "utf-8");
      if (options.verbose) {
        console.log(`  \u2705 ${basename3(sourcePath)} \u2192 ${targetPath}`);
      }
      return wasFixed ? "fixed" : "copied";
    } catch (error) {
      if (options.verbose) {
        console.error(`  \u274C Error syncing ${basename3(sourcePath)}: ${error.message}`);
      }
      return "error";
    }
  }
  async syncDirectory(sourceDir, targetDirs, options) {
    const result = {
      copied: 0,
      fixed: 0,
      skipped: 0,
      errors: []
    };
    if (!existsSync9(sourceDir)) {
      result.errors.push(`Source directory not found: ${sourceDir}`);
      return result;
    }
    const mdFiles = await this.findAllMarkdownFiles(sourceDir);
    for (const file of mdFiles) {
      const relativePath = file.replace(sourceDir + "/", "");
      const sourcePath = join8(sourceDir, relativePath);
      for (const targetDir of targetDirs) {
        if (!existsSync9(targetDir)) {
          await mkdir5(targetDir, { recursive: true });
        }
        const targetPath = join8(targetDir, relativePath);
        const status2 = await this.syncFile(sourcePath, targetPath, options);
        switch (status2) {
          case "copied":
            result.copied++;
            break;
          case "fixed":
            result.fixed++;
            result.copied++;
            break;
          case "skipped":
            result.skipped++;
            break;
          case "error":
            result.errors.push(`Failed to sync ${file} to ${targetDir}`);
            break;
        }
      }
    }
    return result;
  }
  async sync(options = {}) {
    console.log(`\uD83D\uDD04 Codeflow Sync with Validation
`);
    const paths = this.getPaths(options.global);
    const results = {
      agents: { copied: 0, fixed: 0, skipped: 0, errors: [] },
      commands: { copied: 0, fixed: 0, skipped: 0, errors: [] },
      skills: { copied: 0, fixed: 0, skipped: 0, errors: [] }
    };
    console.log("\uD83D\uDCE6 Syncing agents...");
    const agentTargets = options.global ? [paths.agents.globalClaude, paths.agents.globalOpenCode] : [paths.agents.claude, paths.agents.opencode];
    const agentResult = await this.syncDirectory(paths.agents.source, agentTargets, options);
    results.agents = agentResult;
    console.log(`
\uD83D\uDCE6 Syncing commands...`);
    const commandTargets = options.global ? [paths.commands.globalClaude, paths.commands.globalOpenCode] : [paths.commands.claude, paths.commands.opencode];
    const commandResult = await this.syncDirectory(paths.commands.source, commandTargets, options);
    results.commands = commandResult;
    console.log(`
\uD83D\uDCE6 Syncing skills...`);
    const skillTargets = options.global ? [paths.skills.globalClaude, paths.skills.globalOpenCode] : [paths.skills.claude, paths.skills.opencode];
    const skillResult = await this.syncDirectory(paths.skills.source, skillTargets, options);
    results.skills = skillResult;
    console.log(`
\uD83D\uDCCA Sync Summary:`);
    console.log("\u2500".repeat(40));
    const totalCopied = results.agents.copied + results.commands.copied + results.skills.copied;
    const totalFixed = results.agents.fixed + results.commands.fixed + results.skills.fixed;
    const totalSkipped = results.agents.skipped + results.commands.skipped + results.skills.skipped;
    const totalErrors = results.agents.errors.length + results.commands.errors.length + results.skills.errors.length;
    console.log(`\u2705 Copied: ${totalCopied} files`);
    if (totalFixed > 0) {
      console.log(`\uD83D\uDD27 Fixed: ${totalFixed} files`);
    }
    if (totalSkipped > 0) {
      console.log(`\u23ED\uFE0F  Skipped: ${totalSkipped} files (invalid YAML)`);
    }
    if (totalErrors > 0) {
      console.log(`\u274C Errors: ${totalErrors}`);
      if (results.agents.errors.length > 0) {
        console.log(`
Agent sync errors:`);
        results.agents.errors.forEach((err) => console.log(`  - ${err}`));
      }
      if (results.commands.errors.length > 0) {
        console.log(`
Command sync errors:`);
        results.commands.errors.forEach((err) => console.log(`  - ${err}`));
      }
      if (results.skills.errors.length > 0) {
        console.log(`
Skill sync errors:`);
        results.skills.errors.forEach((err) => console.log(`  - ${err}`));
      }
    }
    if (options.global) {
      console.log(`
\u2728 Global sync complete!`);
      console.log("   Files synced to ~/.config/claude and ~/.config/opencode");
    } else {
      console.log(`
\u2728 Local sync complete!`);
      console.log("   Files synced to .claude and .opencode directories");
    }
    if (totalSkipped > 0 && !options.fix) {
      console.log(`
\uD83D\uDCA1 Tip: Use --fix flag to automatically fix YAML issues`);
    }
  }
  async validateAll() {
    console.log(`\uD83D\uDD0D Validating all files...
`);
    const paths = this.getPaths();
    let hasErrors = false;
    console.log("\uD83D\uDCE6 Validating agents...");
    const agentFiles = existsSync9(paths.agents.source) ? await readdir6(paths.agents.source) : [];
    for (const file of agentFiles.filter((f) => f.endsWith(".md"))) {
      const filePath = join8(paths.agents.source, file);
      const result = await validateMarkdownYAML(filePath);
      if (!result.valid) {
        console.log(`  \u274C ${file}: ${result.errors.join(", ")}`);
        hasErrors = true;
      } else if (result.warnings.length > 0) {
        console.log(`  \u26A0\uFE0F  ${file}: ${result.warnings.join(", ")}`);
      } else {
        console.log(`  \u2705 ${file}`);
      }
    }
    console.log(`
\uD83D\uDCE6 Validating commands...`);
    const commandFiles = existsSync9(paths.commands.source) ? await readdir6(paths.commands.source) : [];
    for (const file of commandFiles.filter((f) => f.endsWith(".md"))) {
      const filePath = join8(paths.commands.source, file);
      const result = await validateMarkdownYAML(filePath);
      if (!result.valid) {
        console.log(`  \u274C ${file}: ${result.errors.join(", ")}`);
        hasErrors = true;
      } else if (result.warnings.length > 0) {
        console.log(`  \u26A0\uFE0F  ${file}: ${result.warnings.join(", ")}`);
      } else {
        console.log(`  \u2705 ${file}`);
      }
    }
    console.log(`
\uD83D\uDCE6 Validating skills...`);
    const skillFiles = existsSync9(paths.skills.source) ? await this.findAllMarkdownFiles(paths.skills.source) : [];
    for (const file of skillFiles) {
      const fileName = basename3(file);
      const result = await validateMarkdownYAML(file);
      if (!result.valid) {
        console.log(`  \u274C ${fileName}: ${result.errors.join(", ")}`);
        hasErrors = true;
      } else if (result.warnings.length > 0) {
        console.log(`  \u26A0\uFE0F  ${fileName}: ${result.warnings.join(", ")}`);
      } else {
        console.log(`  \u2705 ${fileName}`);
      }
    }
    if (hasErrors) {
      console.log(`
\u274C Validation failed! Use --fix flag to auto-fix issues.`);
      process.exit(1);
    } else {
      console.log(`
\u2705 All files have valid YAML!`);
    }
  }
}
if (false) {}

// src/cli/sync.ts
async function isValidCommandFile(filePath) {
  try {
    const validator = new CommandValidator;
    const result = await validator.validateFile(filePath, "opencode");
    return result.valid;
  } catch {
    return false;
  }
}
async function sync(projectPath, options = {}) {
  const target = options.target || (options.global ? "global" : "project");
  const cwd = process.cwd() || ".";
  const resolvedPath = target === "global" ? homedir2() : projectPath || cwd;
  const manifestPath = join9(cwd, "AGENT_MANIFEST.json");
  const hasManifest = existsSync10(manifestPath);
  if (hasManifest) {
    const syncer = new CanonicalSyncer;
    try {
      const result = await syncer.syncFromCanonical({
        projectPath: target === "project" ? resolvedPath : undefined,
        target,
        sourceFormat: "base",
        dryRun: options.dryRun || false,
        force: options.force || false
      });
      console.log(`\uD83D\uDD04 Syncing to ${target} directories...`);
      if (result.synced.length > 0) {
        console.log(`
\u2705 Synced ${result.synced.length} files:`);
        result.synced.forEach((sync2) => {
          console.log(`  \u2713 ${sync2.agent}: ${sync2.from} \u2192 ${sync2.to}`);
        });
      }
      if (result.skipped.length > 0 && options.verbose) {
        console.log(`
\u23ED\uFE0F Skipped ${result.skipped.length} files:`);
        result.skipped.forEach((skip) => {
          console.log(`  \u23ED\uFE0F ${skip.agent}: ${skip.reason}`);
        });
      }
      if (result.errors.length > 0) {
        console.log(`
\u274C Errors (${result.errors.length}):`);
        result.errors.forEach((error) => {
          console.log(`  \u274C ${error.agent}: ${error.message}`);
        });
      }
      const totalProcessed = result.synced.length + result.skipped.length + result.errors.length;
      console.log(`
\uD83D\uDCCA Agent Summary: ${result.synced.length}/${totalProcessed} files synced successfully`);
    } catch (error) {
      console.error(`\u274C Canonical sync failed: ${error.message}`);
      process.exit(1);
    }
    try {
      const skillsSyncManager = new SyncManager;
      await skillsSyncManager.sync({
        global: target === "global",
        force: options.force,
        dryRun: options.dryRun,
        verbose: true
      });
    } catch (error) {
      console.error(`\u274C Skills sync failed: ${error.message}`);
    }
    return;
  }
  if (target === "global") {
    const syncManager = new SyncManager;
    await syncManager.sync({
      global: true,
      force: options.force,
      dryRun: options.dryRun,
      verbose: true
    });
    return;
  }
  if (!existsSync10(resolvedPath)) {
    console.error(`\u274C Directory does not exist: ${resolvedPath}`);
    process.exit(1);
  }
  const codeflowDir = getCodeflowRoot();
  console.log(`\uD83D\uDD04 Syncing from: ${codeflowDir}`);
  console.log(`\uD83D\uDCE6 Syncing to: ${resolvedPath}
`);
  let totalSynced = 0;
  try {
    const sourceCommandDir = join9(codeflowDir, "command");
    const targetCommandDir = join9(resolvedPath, ".opencode/command");
    if (existsSync10(sourceCommandDir)) {
      if (!existsSync10(targetCommandDir)) {
        await mkdir6(targetCommandDir, { recursive: true });
        console.log(`  \u2713 Created directory: .opencode/command`);
      }
      const files = await readdir7(sourceCommandDir);
      const mdFiles = files.filter((f) => f.endsWith(".md"));
      for (const file of mdFiles) {
        const sourceFile = join9(sourceCommandDir, file);
        const targetFile = join9(targetCommandDir, file);
        const targetExists = existsSync10(targetFile);
        let needsOverwrite = !targetExists || options.force;
        if (targetExists && !options.force) {
          const isValid = await isValidCommandFile(targetFile);
          if (!isValid) {
            console.log(`  \u26A0\uFE0F  Target file corrupted, will overwrite: ${file}`);
            needsOverwrite = true;
          }
        }
        if (needsOverwrite) {
          try {
            await copyFile3(sourceFile, targetFile);
            const action = targetExists ? "Overwrote" : "Synced";
            console.log(`  \u2713 ${action} command: ${file}`);
            totalSynced++;
          } catch (error) {
            console.error(`  \u274C Failed to sync command ${file}: ${error.message}`);
          }
        } else {
          console.log(`  \u23ED\uFE0F Skipped command (already exists): ${file}`);
        }
      }
    }
    const sourceAgentDir = join9(codeflowDir, "codeflow-agents");
    const targetAgentDir = join9(resolvedPath, ".opencode/agent");
    if (existsSync10(sourceAgentDir)) {
      if (!existsSync10(targetAgentDir)) {
        await mkdir6(targetAgentDir, { recursive: true });
        console.log(`  \u2713 Created directory: .opencode/agent`);
      }
      const { agents, errors: parseErrors } = await parseAgentsFromDirectory(sourceAgentDir, "base");
      if (parseErrors.length > 0) {
        console.error(`\u274C Failed to parse agents from ${sourceAgentDir}`);
        return;
      }
      if (agents.length === 0) {
        console.log(`\u26A0\uFE0F  No agents found in ${sourceAgentDir}`);
        return;
      }
      const converter = new FormatConverter;
      const agentOnly = agents.filter((item) => ("mode" in item.frontmatter) && item.frontmatter.mode !== "command");
      const convertedAgents = converter.convertBatch(agentOnly, "opencode");
      for (const agent of convertedAgents) {
        try {
          const filename = `${agent.frontmatter.name}.md`;
          const targetFile = join9(targetAgentDir, filename);
          const serialized = serializeAgent(agent);
          await writeFile6(targetFile, serialized, "utf-8");
          console.log(`  \u2713 Synced agent: ${filename}`);
          totalSynced++;
        } catch (error) {
          console.error(`  \u274C Failed to sync agent ${agent.frontmatter.name}: ${error.message}`);
        }
      }
    }
    console.log(`
\u2705 Sync complete! ${totalSynced} files synced`);
  } catch (error) {
    console.error(`\u274C Sync failed: ${error.message}`);
    process.exit(1);
  }
}

// src/cli/watch.ts
async function startWatch(projectPath) {
  const resolvedPath = projectPath || process.cwd();
  const pathValidation = error_handler_default.validatePath(resolvedPath, "directory");
  if (!pathValidation.valid) {
    error_handler_default.displayValidationResult(pathValidation, "project directory");
    return;
  }
  error_handler_default.displayProgress(`Starting file watcher for: ${resolvedPath}`);
  console.log("Note: This is a simplified watcher that syncs once");
  console.log(`For continuous watching, use external tools like nodemon
`);
  try {
    await sync(resolvedPath);
    error_handler_default.displaySuccess("Initial sync complete", [
      "Watcher started - files will be synced when this process runs",
      "Use external tools like nodemon for continuous watching"
    ]);
  } catch (error) {
    error_handler_default.displayError(error_handler_default.createErrorContext("watch", "sync_execution", "sync_failed", "Successful sync operation", error.message, "Check sync operation and try again", {
      requiresUserInput: true,
      suggestions: [
        "Verify project directory exists and is accessible",
        "Check file permissions",
        "Run sync manually to see detailed errors"
      ]
    }));
  }
}

// src/cli/fix-models.ts
import { readFile as readFile9, writeFile as writeFile7 } from "fs/promises";
import { existsSync as existsSync12, readdirSync } from "fs";
import { join as join11 } from "path";
import { homedir as homedir3 } from "os";
import { execSync } from "child_process";

// src/catalog/model-fixer.ts
import { readFileSync, existsSync as existsSync11 } from "fs";
import { join as join10 } from "path";

class ModelFixer {
  modelConfig;
  constructor(projectRoot) {
    this.modelConfig = this.loadModelConfig(projectRoot);
  }
  loadModelConfig(projectRoot) {
    try {
      const configPath = join10(projectRoot, "config", "models.json");
      if (existsSync11(configPath)) {
        const config = JSON.parse(readFileSync(configPath, "utf-8"));
        return config;
      }
    } catch {
      console.warn("\u26A0\uFE0F  Could not load model config, using defaults");
    }
    return {
      opencode: {
        commands: "opencode/code-supernova",
        agents: "opencode/grok-code",
        skills: "opencode/grok-code",
        fallback: "opencode/grok-code"
      },
      claude: {
        default: "claude-sonnet-4-20250514"
      }
    };
  }
  fixModel(content, target, itemType) {
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontmatterMatch) {
      return content;
    }
    let frontmatter = frontmatterMatch[1];
    const bodyContent = content.substring(frontmatterMatch[0].length);
    let correctModel;
    if (target === "claude-code") {
      correctModel = this.modelConfig.claude.default;
    } else if (target === "opencode") {
      correctModel = itemType === "command" ? this.modelConfig.opencode.commands : itemType === "skill" ? this.modelConfig.opencode.agents : this.modelConfig.opencode.agents;
    } else {
      return content;
    }
    const modelLineRegex = /^model:.*$/m;
    if (modelLineRegex.test(frontmatter)) {
      frontmatter = frontmatter.replace(modelLineRegex, `model: ${correctModel}`);
    } else {
      frontmatter += `
model: ${correctModel}`;
    }
    return `---
${frontmatter}
---${bodyContent}`;
  }
  getModel(target, itemType) {
    if (target === "claude-code") {
      return this.modelConfig.claude.default;
    } else if (target === "opencode") {
      return itemType === "command" ? this.modelConfig.opencode.commands : this.modelConfig.opencode.agents;
    }
    return this.modelConfig.opencode.fallback || "opencode/grok-code";
  }
  isValidModel(model, target) {
    if (target === "claude-code") {
      return !model.includes("/");
    } else if (target === "opencode") {
      return model.includes("/");
    }
    return false;
  }
}

// src/cli/fix-models.ts
async function fixModels(options = {}) {
  const isGlobal = options.global !== false;
  const modelFixer = new ModelFixer(process.cwd());
  console.log(`
\uD83D\uDD27 Fixing Model Configurations${isGlobal ? " (Global)" : " (Local)"}...
`);
  if (options.dryRun) {
    console.log(`\uD83D\uDD0D Dry run mode - no changes will be made
`);
  }
  const results = {};
  if (isGlobal) {
    results.openCodeCommands = await fixDirectory(join11(homedir3(), ".config", "opencode", "command"), "opencode", "command", modelFixer, options);
    results.openCodeAgents = await fixDirectory(join11(homedir3(), ".config", "opencode", "agent"), "opencode", "agent", modelFixer, options);
    results.openCodeSkills = await fixDirectory(join11(homedir3(), ".config", "opencode", "skills"), "opencode", "skill", modelFixer, options);
    results.claudeCommands = await fixDirectory(join11(homedir3(), ".claude", "commands"), "claude-code", "command", modelFixer, options);
    results.claudeAgents = await fixDirectory(join11(homedir3(), ".claude", "agents"), "claude-code", "agent", modelFixer, options);
    if (options.allProjects) {
      await fixAllOpenCodeProjects(modelFixer, options, results);
    }
  }
  printSummary(results, options);
}
async function fixDirectory(dirPath, target, itemType, modelFixer, options) {
  const result = {
    fixed: 0,
    skipped: 0,
    errors: 0,
    details: []
  };
  if (!existsSync12(dirPath)) {
    if (options.verbose) {
      console.log(`\u23ED\uFE0F  Skipping ${dirPath} (directory doesn't exist)`);
    }
    return result;
  }
  const targetName = target === "claude-code" ? "Claude Code" : "OpenCode";
  console.log(`\uD83D\uDCC2 Processing ${targetName} ${itemType}s: ${dirPath}`);
  try {
    const files = readdirSync(dirPath).filter((f) => f.endsWith(".md"));
    for (const file of files) {
      const filePath = join11(dirPath, file);
      try {
        const content = await readFile9(filePath, "utf-8");
        const fixedContent = modelFixer.fixModel(content, target, itemType);
        if (content !== fixedContent) {
          if (!options.dryRun) {
            await writeFile7(filePath, fixedContent, "utf-8");
          }
          result.fixed++;
          result.details.push(`\u2713 Fixed ${file}`);
          if (options.verbose) {
            console.log(`  \u2713 Fixed ${file}`);
          }
        } else {
          result.skipped++;
        }
      } catch (error) {
        result.errors++;
        result.details.push(`\u2717 Error processing ${file}: ${error}`);
        if (options.verbose) {
          console.error(`  \u2717 Error processing ${file}: ${error}`);
        }
      }
    }
  } catch (error) {
    console.error(`  \u2717 Error reading directory: ${error}`);
  }
  if (result.fixed === 0 && !options.verbose) {
    console.log("  \u2713 All models already correct");
  }
  return result;
}
async function fixAllOpenCodeProjects(modelFixer, options, results) {
  console.log("\uD83D\uDD0D Searching for OpenCode projects...");
  try {
    const searchPaths = [
      join11(homedir3(), "src"),
      join11(homedir3(), "projects"),
      join11(homedir3(), "development"),
      homedir3()
    ];
    const opencodeProjects = [];
    for (const searchPath of searchPaths) {
      if (!existsSync12(searchPath))
        continue;
      try {
        const output = execSync(`find "${searchPath}" -name ".opencode" -type d 2>/dev/null | head -20`, { encoding: "utf-8", maxBuffer: 1024 * 1024 });
        const projects = output.trim().split(`
`).filter((path2) => path2 && existsSync12(join11(path2, "agent")) || existsSync12(join11(path2, "command"))).map((path2) => path2.replace("/.opencode", ""));
        opencodeProjects.push(...projects);
      } catch (error) {}
    }
    if (opencodeProjects.length === 0) {
      console.log("  No OpenCode projects found");
      return;
    }
    console.log(`  Found ${opencodeProjects.length} OpenCode projects`);
    for (let i = 0;i < opencodeProjects.length; i++) {
      const projectPath = opencodeProjects[i];
      const projectName = projectPath.split("/").pop() || `project-${i + 1}`;
      console.log(`
\uD83D\uDCC2 Processing project: ${projectName}`);
      const agentResult = await fixDirectory(join11(projectPath, ".opencode", "agent"), "opencode", "agent", modelFixer, options);
      const commandResult = await fixDirectory(join11(projectPath, ".opencode", "command"), "opencode", "command", modelFixer, options);
      results[`openCodeProject_${projectName}_agents`] = agentResult;
      results[`openCodeProject_${projectName}_commands`] = commandResult;
    }
  } catch (error) {
    console.error("  \u2717 Error searching for OpenCode projects:", error);
  }
}
function printSummary(results, options) {
  console.log(`
\uD83D\uDCCA Summary:`);
  console.log("\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550");
  let totalFixed = 0;
  let totalSkipped = 0;
  let totalErrors = 0;
  for (const [key, result] of Object.entries(results)) {
    if (result.fixed > 0 || result.errors > 0 || options.verbose) {
      const name = key.replace(/([A-Z])/g, " $1").replace(/^local /, "Local ").replace(/^open Code/, "OpenCode").replace(/^claude/, "Claude").trim();
      console.log(`
${name}:`);
      console.log(`  Fixed: ${result.fixed}`);
      console.log(`  Skipped: ${result.skipped}`);
      if (result.errors > 0) {
        console.log(`  Errors: ${result.errors}`);
      }
    }
    totalFixed += result.fixed;
    totalSkipped += result.skipped;
    totalErrors += result.errors;
  }
  console.log(`
\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550`);
  console.log(`Total: ${totalFixed} fixed, ${totalSkipped} already correct, ${totalErrors} errors`);
  if (options.dryRun) {
    console.log(`
\uD83D\uDD0D Dry run complete - no files were modified`);
  } else if (totalFixed > 0) {
    console.log(`
\u2705 Model configurations fixed successfully!`);
    console.log("\uD83C\uDFAF Claude Code agents and commands should now work correctly");
    console.log("\u2139\uFE0F  OpenCode also supports per-project agents/commands with --all-projects");
  } else if (totalErrors === 0) {
    console.log(`
\u2705 All model configurations are already correct!`);
  }
  if (totalErrors > 0) {
    console.log(`
\u26A0\uFE0F  Some errors occurred during processing`);
    console.log("   Run with --verbose for detailed error information");
  }
}

// src/conversion/validator.ts
init_validation_engine();
import { readFile as readFile10, readdir as readdir8, stat as stat3 } from "fs/promises";
import { existsSync as existsSync13 } from "fs";
import path2 from "path";
class AgentValidator {
  validationEngine;
  constructor() {
    this.validationEngine = new ValidationEngine;
  }
  validateBase(agent) {
    return this.validationEngine.validateBase(agent);
  }
  validateClaudeCode(agent) {
    return this.validationEngine.validateClaudeCode(agent);
  }
  validateOpenCode(agent) {
    return this.validationEngine.validateOpenCode(agent);
  }
  validateAgent(agent) {
    switch (agent.format) {
      case "base":
        return this.validateBase(agent.frontmatter);
      case "claude-code":
        return this.validateClaudeCode(agent.frontmatter);
      case "opencode":
        return this.validateOpenCode(agent.frontmatter);
      default:
        return {
          valid: false,
          errors: [
            {
              message: `Unknown agent format: ${agent.format}`,
              severity: "error"
            }
          ],
          warnings: []
        };
    }
  }
  validateBatch(agents) {
    const results = agents.map((agent) => ({
      ...this.validateAgent(agent),
      agent
    }));
    const summary = {
      valid: results.filter((r) => r.valid).length,
      errors: results.reduce((sum, r) => sum + r.errors.length, 0),
      warnings: results.reduce((sum, r) => sum + r.warnings.length, 0)
    };
    return { results, summary };
  }
  validateRoundTrip(original, converted) {
    const errors2 = [];
    const warnings = [];
    if (original.format !== converted.format) {
      errors2.push({
        message: `Format mismatch: expected ${original.format}, got ${converted.format}`,
        severity: "error"
      });
    }
    if (original.name !== converted.name) {
      errors2.push({
        field: "name",
        message: `Name changed during conversion: ${original.name} -> ${converted.name}`,
        severity: "error"
      });
    }
    if (original.content.trim() !== converted.content.trim()) {
      errors2.push({
        field: "content",
        message: "Content changed during conversion",
        severity: "error"
      });
    }
    const preservedFields = ["name", "description"];
    if (original.format === "base" && converted.format === "base") {
      preservedFields.push("mode", "model", "temperature");
    }
    for (const field of preservedFields) {
      const originalValue = original.frontmatter[field];
      const convertedValue = converted.frontmatter[field];
      if (originalValue === undefined && convertedValue === undefined) {
        continue;
      }
      if (field === "tools") {
        continue;
      }
      if (JSON.stringify(originalValue) !== JSON.stringify(convertedValue)) {
        errors2.push({
          field: `frontmatter.${field}`,
          message: `Field '${field}' changed during conversion: ${JSON.stringify(originalValue)} -> ${JSON.stringify(convertedValue)}`,
          severity: "error"
        });
      }
    }
    return {
      valid: errors2.length === 0,
      errors: errors2,
      warnings
    };
  }
  async validateNoDuplicates(agentDirectories) {
    const agentsByName = {};
    const duplicates = [];
    async function findMarkdownFiles(dir, baseDir = "") {
      const files = [];
      try {
        const entries = await readdir8(dir);
        for (const entry of entries) {
          const fullPath = path2.join(dir, entry);
          const stats = await stat3(fullPath);
          if (stats.isDirectory()) {
            const subFiles = await findMarkdownFiles(fullPath, path2.join(baseDir, entry));
            files.push(...subFiles);
          } else if (entry.endsWith(".md")) {
            files.push(fullPath);
          }
        }
      } catch (error) {
        console.warn(`\u26A0\uFE0F Could not read directory ${dir}: ${error.message}`);
      }
      return files;
    }
    for (const directory of agentDirectories) {
      const files = await findMarkdownFiles(directory);
      for (const file of files) {
        const basename4 = path2.basename(file, ".md");
        const format = this.detectFormatFromPath(file);
        if (!agentsByName[basename4]) {
          agentsByName[basename4] = [];
        }
        agentsByName[basename4].push({
          file,
          format,
          directory: path2.dirname(file)
        });
      }
    }
    Object.entries(agentsByName).forEach(([name, locations]) => {
      const expectedFormats = ["base", "claude-code", "opencode"];
      const actualFormats = locations.map((l) => l.format);
      const extraCopies = locations.filter((loc, index) => {
        const format = loc.format;
        const firstOccurrence = actualFormats.indexOf(format);
        return index !== firstOccurrence;
      });
      if (extraCopies.length > 0) {
        duplicates.push({
          agentName: name,
          totalCopies: locations.length,
          expectedCopies: 3,
          extraCopies: extraCopies.map((c) => c.file),
          canonicalSources: locations.filter((l) => l.format === "base" && l.file.includes("codeflow-agents/") && !l.file.includes("backup/") || l.format === "claude-code" && (l.file.includes("claude-agents/") || l.file.includes(".claude/agents/")) && !l.file.includes("backup/") || l.format === "opencode" && (l.file.includes("opencode-agents/") || l.file.includes(".opencode/agent/")) && !l.file.includes("backup/")).map((c) => c.file)
        });
      }
      const missingFormats = expectedFormats.filter((f) => !actualFormats.includes(f));
      if (missingFormats.length > 0) {
        duplicates.push({
          agentName: name,
          issue: "missing_canonical_formats",
          missingFormats,
          existingLocations: locations.map((l) => l.file)
        });
      }
    });
    return {
      valid: duplicates.length === 0,
      totalAgents: Object.keys(agentsByName).length,
      canonicalAgentCount: Object.keys(agentsByName).filter((name) => agentsByName[name].length >= 3 && agentsByName[name].some((l) => l.directory.includes("codeflow-agents")) && (agentsByName[name].some((l) => l.directory.includes("claude-agents")) || agentsByName[name].some((l) => l.directory.includes(".claude"))) && (agentsByName[name].some((l) => l.directory.includes("opencode-agents")) || agentsByName[name].some((l) => l.directory.includes(".opencode")))).length,
      duplicates
    };
  }
  async validateCanonicalIntegrity() {
    let manifestPath;
    try {
      const discovery = await findAgentManifest();
      manifestPath = discovery.path;
    } catch {
      return {
        valid: false,
        manifestAgents: 0,
        expectedCount: 42,
        errors: [
          {
            agent: "manifest",
            issue: "AGENT_MANIFEST.json not found",
            suggestion: "Run setup from the codeflow repository or copy AGENT_MANIFEST.json manually"
          }
        ]
      };
    }
    if (!existsSync13(manifestPath)) {
      return {
        valid: false,
        manifestAgents: 0,
        expectedCount: 42,
        errors: [
          {
            agent: "manifest",
            issue: "AGENT_MANIFEST.json not found",
            suggestion: "Create AGENT_MANIFEST.json with canonical agent definitions"
          }
        ]
      };
    }
    const manifest = JSON.parse(await readFile10(manifestPath, "utf-8"));
    const errors2 = [];
    for (const agent of manifest.canonical_agents || []) {
      for (const [format, filePath] of Object.entries(agent.sources || {})) {
        if (!existsSync13(filePath)) {
          errors2.push({
            agent: agent.name,
            issue: `Missing canonical ${format} file: ${filePath}`
          });
        }
      }
      if (errors2.length === 0 && agent.sources) {
        try {
          const baseContent = await readFile10(agent.sources.base, "utf-8");
          const claudeContent = await readFile10(agent.sources["claude-code"], "utf-8");
          const opencodeContent = await readFile10(agent.sources.opencode, "utf-8");
          const baseDesc = this.extractDescription(baseContent);
          const claudeDesc = this.extractDescription(claudeContent);
          const opencodeDesc = this.extractDescription(opencodeContent);
          if (!this.descriptionsMatch(baseDesc, claudeDesc, opencodeDesc)) {
            errors2.push({
              agent: agent.name,
              issue: "Content divergence detected across formats",
              suggestion: "Review and sync agent descriptions and core functionality"
            });
          }
        } catch (error) {
          errors2.push({
            agent: agent.name,
            issue: `Error reading canonical files: ${error.message}`
          });
        }
      }
    }
    return {
      valid: errors2.length === 0,
      manifestAgents: manifest.canonical_agents?.length || 0,
      expectedCount: 42,
      errors: errors2
    };
  }
  validateOpenCodeAgent(agent) {
    const errors2 = [];
    const warnings = [];
    if (!agent.description || agent.description.trim().length === 0) {
      errors2.push({
        field: "description",
        message: "OpenCode agents must have a non-empty description",
        severity: "error"
      });
    }
    if (!["primary", "subagent", "all"].includes(agent.mode || "")) {
      errors2.push({
        field: "mode",
        message: `Invalid mode '${agent.mode}'. Must be 'primary', 'subagent', or 'all'`,
        severity: "error"
      });
    }
    if (agent.model && !agent.model.includes("/")) {
      warnings.push({
        field: "model",
        message: `Model '${agent.model}' should use provider/model format for OpenCode`
      });
    }
    const hasTools = agent.tools !== undefined && (typeof agent.tools !== "string" || agent.tools !== "undefined");
    const hasPermissions = agent.permission !== undefined && (typeof agent.permission !== "string" || agent.permission !== "undefined");
    if (!hasTools && !hasPermissions) {
      errors2.push({
        field: "tools",
        message: "Either tools or permission field must be defined",
        severity: "error"
      });
    }
    if (agent.tools && typeof agent.tools === "object") {
      if (agent.tools.write && !agent.tools.read) {
        warnings.push({
          field: "tools",
          message: "Write permission typically requires read permission"
        });
      }
    }
    if (agent.permission && typeof agent.permission === "object") {
      if (agent.permission.write === "allow" && agent.permission.read !== "allow") {
        warnings.push({
          field: "permission",
          message: "Write permission typically requires read permission"
        });
      }
    }
    if (agent.temperature !== undefined && (agent.temperature < 0 || agent.temperature > 2)) {
      errors2.push({
        field: "temperature",
        message: `Temperature ${agent.temperature} is outside valid range 0-2`,
        severity: "error"
      });
    }
    return {
      valid: errors2.length === 0,
      errors: errors2,
      warnings
    };
  }
  async validateBatchWithDetails(agents) {
    const results = [];
    const summary = {
      total: agents.length,
      valid: 0,
      errors: 0,
      warnings: 0,
      errorsByType: {},
      warningsByType: {}
    };
    for (const agent of agents) {
      const result = this.validateAgent(agent);
      results.push({ ...result, agent: agent.name });
      if (result.valid) {
        summary.valid++;
      } else {
        summary.errors += result.errors.length;
        result.errors.forEach((error) => {
          const key = error.field || "general";
          summary.errorsByType[key] = (summary.errorsByType[key] || 0) + 1;
        });
      }
      summary.warnings += result.warnings.length;
      result.warnings.forEach((warning) => {
        const key = warning.field || "general";
        summary.warningsByType[key] = (summary.warningsByType[key] || 0) + 1;
      });
    }
    return { results, summary };
  }
  generateFixScript(validationResults) {
    const fixes = [];
    validationResults.forEach((result) => {
      if (!result.valid && "agent" in result) {
        fixes.push(`# Fixes for ${result.agent}`);
        result.errors.forEach((error) => {
          fixes.push(`# ${error.message}`);
          if ("suggestion" in error && error.suggestion) {
            fixes.push(`# Suggestion: ${error.suggestion}`);
          }
        });
        fixes.push("");
      }
    });
    return fixes.join(`
`);
  }
  detectFormatFromPath(filePath) {
    if (filePath.includes("codeflow-agents/"))
      return "base";
    if (filePath.includes(".claude/agents/"))
      return "claude-code";
    if (filePath.includes(".opencode/agent/"))
      return "opencode";
    if (filePath.includes("claude-agents/"))
      return "claude-code";
    if (filePath.includes("opencode-agents/"))
      return "opencode";
    return "unknown";
  }
  extractDescription(content) {
    const lines = content.split(`
`);
    for (const line of lines) {
      if (line.includes("description:")) {
        return line.split("description:")[1].trim();
      }
    }
    return content.substring(0, 200);
  }
  descriptionsMatch(desc1, desc2, desc3) {
    const keywords1 = desc1.toLowerCase().split(/\s+/);
    const keywords2 = desc2.toLowerCase().split(/\s+/);
    const keywords3 = desc3.toLowerCase().split(/\s+/);
    const common12 = keywords1.filter((k) => keywords2.includes(k)).length;
    const common13 = keywords1.filter((k) => keywords3.includes(k)).length;
    const common23 = keywords2.filter((k) => keywords3.includes(k)).length;
    return common12 > 2 && common13 > 2 && common23 > 2;
  }
  getRecommendations(agent) {
    const recommendations = [];
    const validation = this.validateAgent(agent);
    for (const warning of validation.warnings) {
      recommendations.push(warning.message);
    }
    if (agent.format === "claude-code") {
      const claudeAgent = agent.frontmatter;
      if (!claudeAgent.name) {
        recommendations.push("Claude Code agents require a name field");
      }
      if (!claudeAgent.description) {
        recommendations.push("Claude Code agents require a description field");
      }
      if (agent.content.length < 100) {
        recommendations.push("Agent content is quite short, consider adding more detailed instructions");
      }
    } else if (agent.format === "opencode") {
      const openCodeAgent = agent.frontmatter;
      if (!openCodeAgent.mode) {
        recommendations.push("Consider specifying a mode (subagent or primary) to clarify the agent's role");
      }
      if (!openCodeAgent.model) {
        recommendations.push("Consider specifying a model to ensure consistent behavior");
      }
      if (openCodeAgent.temperature === undefined) {
        recommendations.push("Consider setting a temperature value to control output randomness");
      }
      if (agent.content.length < 100) {
        recommendations.push("Agent content is quite short, consider adding more detailed instructions");
      }
    } else {
      const baseAgent = agent.frontmatter;
      if (!baseAgent.mode) {
        recommendations.push("Consider specifying a mode (subagent or primary) to clarify the agent's role");
      }
      if (!baseAgent.model) {
        recommendations.push("Consider specifying a model to ensure consistent behavior");
      }
      if (baseAgent.temperature === undefined) {
        recommendations.push("Consider setting a temperature value to control output randomness");
      }
      if (agent.content.length < 100) {
        recommendations.push("Agent content is quite short, consider adding more detailed instructions");
      }
    }
    return recommendations;
  }
}

// src/cli/validate.ts
init_agent_parser();
import { existsSync as existsSync14 } from "fs";
import { readdir as readdir9, stat as stat4 } from "fs/promises";
import path3 from "path";

// src/cli/global.ts
import { join as join12 } from "path";
import os2 from "os";
function getGlobalPaths() {
  const envBase = process.env.CODEFLOW_GLOBAL_CONFIG || process.env.CODEFLOW_HOME;
  if (envBase && envBase.trim().length > 0) {
    return {
      global: envBase,
      commands: join12(envBase, "command"),
      agents: {
        base: join12(envBase, "agent"),
        claudeCode: join12(envBase, "agent"),
        opencode: join12(envBase, "agent")
      }
    };
  }
  const home = os2.homedir();
  return {
    global: join12(home, ".claude"),
    commands: join12(home, ".claude", "commands"),
    commandsByFormat: {
      claudeCode: join12(home, ".claude", "commands"),
      opencode: join12(home, ".config", "opencode", "command")
    },
    agents: {
      base: join12(home, ".codeflow", "agents"),
      claudeCode: join12(home, ".claude", "agents"),
      opencode: join12(home, ".config", "opencode", "agent")
    }
  };
}

// src/cli/validate.ts
async function validate(options) {
  const validator = new AgentValidator;
  const format = options.format || "all";
  let searchPath = options.path || ".";
  if (options.global) {
    error_handler_default.displayProgress("Validating global agent directories");
    const globalPaths = getGlobalPaths();
    const globalResults = [];
    if (format === "all" || format === "base") {
      if (existsSync14(globalPaths.agents.base)) {
        const result = await validateGlobalDirectory(globalPaths.agents.base, "base");
        globalResults.push(result);
      }
    }
    if (format === "all" || format === "claude-code") {
      if (existsSync14(globalPaths.agents.claudeCode)) {
        const result = await validateGlobalDirectory(globalPaths.agents.claudeCode, "claude-code");
        globalResults.push(result);
      }
    }
    if (format === "all" || format === "opencode") {
      if (existsSync14(globalPaths.agents.opencode)) {
        const result = await validateGlobalDirectory(globalPaths.agents.opencode, "opencode");
        globalResults.push(result);
        await validateOpenCodeFlatStructure(globalPaths.agents.opencode);
      }
    }
    displayGlobalValidationResults(globalResults, { format, verbose: options.verbose });
    return;
  }
  const pathValidation = error_handler_default.validatePath(searchPath, "directory");
  if (!pathValidation.valid) {
    error_handler_default.displayValidationResult(pathValidation, "search path");
    return;
  }
  try {
    const directories = {
      "claude-code": ["claude-agents"],
      opencode: [],
      base: ["agent", "codeflow-agents", "base-agents"],
      all: [
        "agent",
        "codeflow-agents",
        "base-agents",
        "claude-agents"
      ]
    };
    const dirsToSearch = directories[format] || directories.all;
    const files = [];
    async function findMarkdownFiles(dir) {
      const foundFiles = [];
      try {
        const entries = await readdir9(dir);
        for (const entry of entries) {
          const fullPath = path3.join(dir, entry);
          const stats = await stat4(fullPath);
          if (stats.isDirectory()) {
            const dirName = path3.basename(fullPath);
            const generatedFolders = [".claude", ".opencode", ".cursor"];
            if (generatedFolders.some((genFolder) => fullPath.includes(genFolder))) {
              continue;
            }
            const subFiles = await findMarkdownFiles(fullPath);
            foundFiles.push(...subFiles);
          } else if (entry.endsWith(".md")) {
            foundFiles.push(fullPath);
          }
        }
      } catch (error) {
        error_handler_default.displayWarning(`Could not read directory ${dir}: ${error.message}`, ["Check directory permissions", "Verify the directory exists"]);
      }
      return foundFiles;
    }
    for (const dir of dirsToSearch) {
      const fullDir = path3.isAbsolute(dir) ? dir : path3.join(searchPath, dir);
      if (existsSync14(fullDir)) {
        const dirName = path3.basename(fullDir);
        const generatedDirs = [".claude", ".opencode", ".cursor", "opencode-agents"];
        if (generatedDirs.some((genDir) => fullDir.includes(genDir))) {
          continue;
        }
        const foundFiles = await findMarkdownFiles(fullDir);
        files.push(...foundFiles);
      }
    }
    error_handler_default.displayProgress(`Validating ${files.length} agent files (format: ${format})`);
    if (options.checkDuplicates) {
      error_handler_default.displayProgress("Checking for duplicate agents");
      const duplicateResult = await validator.validateNoDuplicates([
        "codeflow-agents",
        "claude-agents",
        "opencode-agents"
      ]);
      console.log(`\uD83D\uDCCA Duplicate Detection Results:`);
      console.log(`  Total unique agents: ${duplicateResult.totalAgents}`);
      console.log(`  Canonical agents (exactly 3 formats): ${duplicateResult.canonicalAgentCount}`);
      console.log(`  Duplicate issues found: ${duplicateResult.duplicates.length}`);
      if (duplicateResult.duplicates.length > 0) {
        console.log(`
\u274C Duplicate Issues:`);
        duplicateResult.duplicates.forEach((dup) => {
          if (dup.issue === "missing_canonical_formats") {
            console.log(`  ${dup.agentName}: Missing formats ${dup.missingFormats?.join(", ")}`);
          } else {
            console.log(`  ${dup.agentName}: ${dup.totalCopies} copies (expected 3)`);
            dup.extraCopies?.forEach((file) => console.log(`    Extra: ${file}`));
          }
        });
      }
      const criticalIssues = duplicateResult.duplicates?.filter((d) => ["canonical_conflict", "schema_missing", "permission_violation"].includes(d.issue)) || [];
      if (criticalIssues.length > 0) {
        error_handler_default.displayError(error_handler_default.createErrorContext("validate", "duplicate_detection", "critical_validation_issues", "No critical validation issues", `${criticalIssues.length} critical issues found`, "Address critical issues before proceeding", {
          requiresUserInput: true,
          suggestions: [
            "Fix canonical conflicts by ensuring consistent agent definitions",
            "Add missing schema files",
            "Check and fix permission violations"
          ]
        }));
        process.exit(1);
      }
      const legacyIssues = duplicateResult.duplicates?.filter((d) => d.issue === "legacy_duplicate") || [];
      if (legacyIssues.length > 0) {
        error_handler_default.displayWarning(`${legacyIssues.length} legacy duplicates found`, [
          "Consider consolidating duplicate agents",
          "Check if legacy duplicates are still needed"
        ]);
      }
    }
    if (options.canonicalCheck) {
      error_handler_default.displayProgress("Validating canonical source integrity");
      try {
        const canonicalResult = await validator.validateCanonicalIntegrity();
        console.log(`\uD83D\uDCCA Canonical Integrity Results:`);
        console.log(`  Expected agents: ${canonicalResult.expectedCount}`);
        console.log(`  Manifest agents: ${canonicalResult.manifestAgents}`);
        console.log(`  Integrity issues: ${canonicalResult.errors.length}`);
        if (canonicalResult.errors.length > 0) {
          console.log(`
\u274C Integrity Issues:`);
          canonicalResult.errors.forEach((error) => {
            console.log(`  ${error.agent}: ${error.issue}`);
            if (error.suggestion) {
              console.log(`    \uD83D\uDCA1 ${error.suggestion}`);
            }
          });
        }
        if (!canonicalResult.valid) {
          error_handler_default.displayError(error_handler_default.createErrorContext("validate", "canonical_integrity", "canonical_validation_failed", "Valid canonical integrity", `${canonicalResult.errors.length} integrity issues found`, "Fix integrity issues and try again", {
            requiresUserInput: true,
            suggestions: [
              "Ensure AGENT_MANIFEST.json exists and is valid",
              "Run setup from the codeflow repository root",
              "Copy the manifest manually if needed"
            ]
          }));
          process.exit(1);
        }
      } catch (error) {
        error_handler_default.displayError(error_handler_default.createErrorContext("validate", "canonical_integrity", "canonical_validation_error", "Successful canonical validation", error.message, "Check AGENT_MANIFEST.json and try again", {
          requiresUserInput: true,
          suggestions: [
            "Ensure AGENT_MANIFEST.json exists and is valid",
            "Run setup from the codeflow repository root",
            "Copy the manifest manually if needed"
          ]
        }));
        process.exit(1);
      }
    }
    const agents = [];
    const parseErrors = [];
    for (const file of files) {
      try {
        const formatType = file.includes("claude-agents") || file.includes(".claude/") ? "claude-code" : file.includes("opencode-agents") || file.includes(".opencode/") ? "opencode" : file.includes("codeflow-agents") || file.includes("/agent/") ? "base" : "base";
        const agent = await parseAgentFile(file, formatType);
        if (agent) {
          agents.push(agent);
        }
      } catch (error) {
        console.log(`\u274C DEBUG: Parse error for ${file}: ${error.message}`);
        parseErrors.push({ file, error: error.message });
      }
    }
    if (parseErrors.length > 0) {
      error_handler_default.displayWarning(`${parseErrors.length} files failed to parse`, [
        "Check file formats and syntax",
        "Run with --verbose for detailed error information"
      ]);
      parseErrors.forEach(({ file, error }) => {
        console.error(`  ${file}: ${error}`);
      });
    }
    const { results, summary } = await validator.validateBatchWithDetails(agents);
    console.log(`
\uD83D\uDCCA Validation Summary:`);
    console.log(`  Total: ${summary.total}`);
    console.log(`  \u2705 Valid: ${summary.valid}`);
    console.log(`  \u274C Errors: ${summary.errors}`);
    console.log(`  \u26A0\uFE0F  Warnings: ${summary.warnings}`);
    if (summary.errors > 0) {
      console.log(`
Top error categories:`);
      Object.entries(summary.errorsByType).sort(([, a], [, b]) => b - a).slice(0, 5).forEach(([field, count]) => {
        console.log(`  ${field}: ${count} issues`);
      });
    }
    if (options.verbose) {
      console.log(`
\uD83D\uDCDD Detailed Results:`);
      results.forEach((result) => {
        if (!result.valid) {
          console.log(`
\u274C ${result.agent}:`);
          result.errors.forEach((error) => {
            console.log(`  ${error.field}: ${error.message}`);
            if ("suggestion" in error && error.suggestion) {
              console.log(`    \uD83D\uDCA1 ${error.suggestion}`);
            }
          });
        }
        if (result.warnings.length > 0) {
          console.log(`
\u26A0\uFE0F  ${result.agent} warnings:`);
          result.warnings.forEach((warning) => {
            console.log(`  ${warning.field}: ${warning.message}`);
          });
        }
      });
    }
    if (options.fix) {
      const fixScript = validator.generateFixScript(results);
      console.log(`
\uD83D\uDD27 Fix suggestions written to: agent-fixes.txt`);
      await Bun.write("agent-fixes.txt", fixScript);
    }
    if (summary.errors > 0) {
      error_handler_default.displayWarning(`Validation completed with ${summary.errors} errors`, [
        "Review the validation results above",
        "Fix critical issues before proceeding",
        "Use --fix option to generate fix suggestions"
      ]);
      process.exit(1);
    }
    error_handler_default.displaySuccess("Agent validation completed successfully", [
      "All agents passed validation",
      "No critical issues found"
    ]);
  } catch (error) {
    error_handler_default.handleCommonError(error, "validate");
  }
}
async function validateGlobalDirectory(dirPath, format) {
  const validator = new AgentValidator;
  const agents = [];
  const errors2 = [];
  const warnings = [];
  try {
    async function findMarkdownFiles(dir) {
      const foundFiles = [];
      try {
        const entries = await readdir9(dir);
        for (const entry of entries) {
          const fullPath = path3.join(dir, entry);
          const stats = await stat4(fullPath);
          if (stats.isDirectory()) {
            const subFiles = await findMarkdownFiles(fullPath);
            foundFiles.push(...subFiles);
          } else if (entry.endsWith(".md")) {
            foundFiles.push(fullPath);
          }
        }
      } catch (error) {
        error_handler_default.displayWarning(`Could not read directory ${dir}: ${error.message}`, ["Check directory permissions", "Verify the directory exists"]);
      }
      return foundFiles;
    }
    const files = await findMarkdownFiles(dirPath);
    for (const file of files) {
      try {
        const agent = await parseAgentFile(file, format);
        if (agent) {
          agents.push(agent);
        }
      } catch (error) {
        errors2.push({ file, error: error.message });
      }
    }
    const { results, summary } = await validator.validateBatchWithDetails(agents);
    return {
      format,
      path: dirPath,
      agents,
      errors: results.flatMap((r) => r.errors),
      warnings: results.flatMap((r) => r.warnings)
    };
  } catch (error) {
    return {
      format,
      path: dirPath,
      agents: [],
      errors: [{ error: error.message }],
      warnings
    };
  }
}
async function validateOpenCodeFlatStructure(opencodePath) {
  try {
    const entries = await readdir9(opencodePath);
    const subdirectories = [];
    for (const entry of entries) {
      const fullPath = path3.join(opencodePath, entry);
      try {
        const stats = await stat4(fullPath);
        if (stats.isDirectory()) {
          subdirectories.push(entry);
        }
      } catch {}
    }
    if (subdirectories.length > 0) {
      const errorMessage = `OpenCode agents found in subdirectories (invalid structure). Found ${subdirectories.length} subdirectories: ${subdirectories.slice(0, 3).join(", ")}${subdirectories.length > 3 ? "..." : ""}. OpenCode requires flat structure - agents must be directly in the agent directory. Run "codeflow migrate-opencode-agents" to fix this issue.`;
      throw new Error(errorMessage);
    }
  } catch (error) {
    if (error instanceof Error && error.message.includes("OpenCode agents found in subdirectories")) {
      throw error;
    }
    error_handler_default.displayWarning(`Could not validate OpenCode flat structure: ${error.message}`, ["Check directory permissions", "Verify directory exists"]);
  }
}
function displayGlobalValidationResults(results, options) {
  console.log(`
\uD83D\uDCCA Global Validation Results:`);
  let totalAgents = 0;
  let totalErrors = 0;
  let totalWarnings = 0;
  results.forEach((result) => {
    totalAgents += result.agents.length;
    totalErrors += result.errors.length;
    totalWarnings += result.warnings.length;
    console.log(`  ${result.format}:`);
    console.log(`    Path: ${result.path}`);
    console.log(`    Agents: ${result.agents.length}`);
    console.log(`    Errors: ${result.errors.length}`);
    console.log(`    Warnings: ${result.warnings.length}`);
    if (result.errors.length > 0 && result.errors.length <= 5) {
      console.log(`    Recent errors:`);
      result.errors.slice(0, 3).forEach((error) => {
        console.log(`      \u2022 ${error.file || "Unknown"}: ${error.error || error.message || "Unknown error"}`);
      });
    }
  });
  console.log(`
\uD83D\uDCCA Summary:`);
  console.log(`  Total agents: ${totalAgents}`);
  console.log(`  \u2705 Valid: ${totalAgents - totalErrors}`);
  console.log(`  \u274C Errors: ${totalErrors}`);
  console.log(`  \u26A0\uFE0F  Warnings: ${totalWarnings}`);
  if (totalErrors > 0) {
    error_handler_default.displayWarning(`Global validation completed with ${totalErrors} errors`, [
      "Review the validation results above",
      "Fix critical issues before proceeding"
    ]);
    process.exit(1);
  }
  error_handler_default.displaySuccess("Global agent validation completed successfully", [
    "All global agents passed validation",
    "No critical issues found"
  ]);
}

// src/cli/list.ts
import { existsSync as existsSync15, readdirSync as readdirSync2 } from "fs";
import { join as join13, resolve as resolve3 } from "path";
import { readFile as readFile11 } from "fs/promises";
async function extractMetadata(filePath) {
  try {
    const content = await readFile11(filePath, "utf-8");
    const stats = { size: Buffer.byteLength(content, "utf8") };
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (frontmatterMatch) {
      const frontmatter = frontmatterMatch[1];
      const descMatch = frontmatter.match(/description:\s*(.+)/);
      if (descMatch) {
        return { description: descMatch[1].replace(/['"]/g, "").trim(), ...stats };
      }
    }
    const lines = content.split(`
`).filter((line) => line.trim());
    const firstLine = lines.find((line) => !line.startsWith("#") && line.trim().length > 10);
    if (firstLine) {
      return {
        description: firstLine.substring(0, 100) + (firstLine.length > 100 ? "..." : ""),
        ...stats
      };
    }
    return stats;
  } catch {
    return { size: 0 };
  }
}
async function listDirectory(dir, type) {
  if (!existsSync15(dir)) {
    return [];
  }
  try {
    const items = [];
    const isBaseFormat = dir.includes("codeflow-agents") || dir.endsWith("command");
    async function scanDirectory(currentDir) {
      const entries = readdirSync2(currentDir, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = join13(currentDir, entry.name);
        if (entry.isDirectory() && isBaseFormat) {
          await scanDirectory(fullPath);
        } else if (entry.isFile() && entry.name.endsWith(".md")) {
          const metadata = await extractMetadata(fullPath);
          let platform = "base";
          if (dir.includes(".claude")) {
            platform = "claude-code";
          } else if (dir.includes(".opencode")) {
            platform = "opencode";
          } else if (dir.includes("codeflow-agents") || dir === "command") {
            platform = "base";
          }
          let actualType = type;
          try {
            const content = await readFile11(fullPath, "utf-8");
            const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
            if (frontmatterMatch) {
              const frontmatter = frontmatterMatch[1];
              if (frontmatter.includes("subagent_type:") || frontmatter.includes("mode: subagent")) {
                actualType = "agent";
              } else if (frontmatter.includes("mode: command") || frontmatter.includes("subtask: true")) {
                actualType = "command";
              }
            }
          } catch {}
          items.push({
            name: entry.name.replace(".md", ""),
            type: actualType,
            platform,
            path: fullPath,
            ...metadata
          });
        }
      }
    }
    await scanDirectory(dir);
    return items;
  } catch (error) {
    console.warn(`Warning: Could not read directory ${dir}: ${error instanceof Error ? error.message : "Unknown error"}`);
    return [];
  }
}
function formatAsTable(items) {
  if (items.length === 0) {
    return "No items found.";
  }
  const headers = ["Name", "Type", "Platform", "Size", "Description"];
  const rows = items.map((item) => [
    item.name,
    item.type,
    item.platform,
    item.size ? `${Math.round(item.size / 1024)}KB` : "0KB",
    item.description || "No description"
  ]);
  const colWidths = headers.map((header, i) => Math.max(header.length, ...rows.map((row) => row[i]?.length || 0)));
  const formatRow = (row) => row.map((cell, i) => cell.padEnd(colWidths[i])).join(" | ");
  const separator = colWidths.map((width) => "-".repeat(width)).join("-|-");
  return [formatRow(headers), separator, ...rows.map(formatRow)].join(`
`);
}
function formatAsJson(items) {
  return JSON.stringify(items, null, 2);
}
function formatAsSimple(items) {
  if (items.length === 0) {
    return "No items found.";
  }
  return items.map((item) => `${item.name} (${item.type}, ${item.platform})`).join(`
`);
}
async function list(projectPath = process.cwd(), options = {}) {
  const projectPathResolved = resolve3(projectPath);
  const { type = "all", platform = "all", format = "table", verbose = false } = options;
  console.log(`\uD83D\uDCCB Listing Codeflow items in: ${projectPathResolved}`);
  const items = [];
  if (type === "agents" || type === "all") {
    const agentDirs = [".claude/agents", ".opencode/agent", "codeflow-agents"];
    for (const dir of agentDirs) {
      const fullPath = join13(projectPathResolved, dir);
      if (existsSync15(fullPath)) {
        const agentItems = await listDirectory(fullPath, "agent");
        items.push(...agentItems);
      }
    }
  }
  if (type === "commands" || type === "all") {
    const commandDirs = [".claude/commands", ".opencode/command", "command"];
    for (const dir of commandDirs) {
      const fullPath = join13(projectPathResolved, dir);
      if (existsSync15(fullPath)) {
        const commandItems = await listDirectory(fullPath, "command");
        items.push(...commandItems);
      }
    }
  }
  let filteredItems = items;
  if (platform !== "all") {
    filteredItems = items.filter((item) => item.platform === platform);
  }
  filteredItems.sort((a, b) => {
    if (a.type !== b.type) {
      return a.type.localeCompare(b.type);
    }
    return a.name.localeCompare(b.name);
  });
  let output;
  switch (format) {
    case "json":
      output = formatAsJson(filteredItems);
      break;
    case "simple":
      output = formatAsSimple(filteredItems);
      break;
    case "table":
    default:
      output = formatAsTable(filteredItems);
      break;
  }
  console.log(`
${output}`);
  const summary = {
    total: filteredItems.length,
    agents: filteredItems.filter((i) => i.type === "agent").length,
    commands: filteredItems.filter((i) => i.type === "command").length,
    platforms: {
      "claude-code": filteredItems.filter((i) => i.platform === "claude-code").length,
      opencode: filteredItems.filter((i) => i.platform === "opencode").length,
      base: filteredItems.filter((i) => i.platform === "base").length
    }
  };
  console.log(`
\uD83D\uDCCA Summary:`);
  console.log(`   Total items: ${summary.total}`);
  console.log(`   Agents: ${summary.agents}`);
  console.log(`   Commands: ${summary.commands}`);
  console.log(`   Claude Code: ${summary.platforms["claude-code"]}`);
  console.log(`   OpenCode: ${summary.platforms["opencode"]}`);
  console.log(`   Base: ${summary.platforms["base"]}`);
  if (verbose) {
    console.log(`
\uD83D\uDD0D Verbose information:`);
    console.log(`   Project path: ${projectPathResolved}`);
    console.log(`   Filter type: ${type}`);
    console.log(`   Filter platform: ${platform}`);
    console.log(`   Output format: ${format}`);
  }
}

// src/cli/info.ts
import { existsSync as existsSync16 } from "fs";
import { join as join14, resolve as resolve4 } from "path";
import { readFile as readFile12 } from "fs/promises";
async function info(itemName, projectPath = process.cwd(), options = {}) {
  const projectPathResolved = resolve4(projectPath);
  const { format = "detailed", showContent = false } = options;
  console.log(`\uD83D\uDD0D Getting info for: ${itemName}`);
  console.log(`\uD83D\uDCC1 Project path: ${projectPathResolved}`);
  const searchLocations = [
    {
      path: join14(projectPathResolved, ".claude", "agents", `${itemName}.md`),
      type: "agent",
      platform: "claude-code"
    },
    {
      path: join14(projectPathResolved, ".opencode", "agent", `${itemName}.md`),
      type: "agent",
      platform: "opencode"
    },
    {
      path: join14(projectPathResolved, ".claude", "commands", `${itemName}.md`),
      type: "command",
      platform: "claude-code"
    },
    {
      path: join14(projectPathResolved, ".opencode", "command", `${itemName}.md`),
      type: "command",
      platform: "opencode"
    }
  ];
  let foundItem = null;
  for (const location of searchLocations) {
    if (existsSync16(location.path)) {
      foundItem = location;
      break;
    }
  }
  if (!foundItem) {
    console.error(`\u274C Item '${itemName}' not found in project.`);
    console.error(`\uD83D\uDCA1 Use 'codeflow list' to see available items.`);
    process.exit(1);
  }
  console.log(`\u2705 Found ${foundItem.type}: ${itemName} (${foundItem.platform})`);
  console.log(`\uD83D\uDCC4 Path: ${foundItem.path}`);
  try {
    const content = await readFile12(foundItem.path, "utf-8");
    const stats = { size: Buffer.byteLength(content, "utf8"), lines: content.split(`
`).length };
    console.log(`\uD83D\uDCCA File stats: ${Math.round(stats.size / 1024)}KB, ${stats.lines} lines`);
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (frontmatterMatch) {
      const frontmatter = frontmatterMatch[1];
      console.log(`
\uD83D\uDCCB Frontmatter:`);
      const lines = frontmatter.split(`
`);
      for (const line of lines) {
        if (line.trim()) {
          console.log(`   ${line}`);
        }
      }
    }
    if (showContent) {
      console.log(`
\uD83D\uDCDD Content:`);
      console.log(`---`);
      console.log(content);
      console.log(`---`);
    }
    if (format === "yaml" && frontmatterMatch) {
      console.log(`
\uD83D\uDCC4 YAML Format:`);
      console.log(frontmatterMatch[0]);
    } else if (format === "json") {
      console.log(`
\uD83D\uDCC4 JSON Format:`);
      try {
        const yamlLines = frontmatterMatch ? frontmatterMatch[1].split(`
`) : [];
        const jsonObj = {};
        for (const line of yamlLines) {
          const match = line.match(/^(\w+):\s*(.+)$/);
          if (match) {
            const [, key, value] = match;
            jsonObj[key] = value.replace(/['"]/g, "").trim();
          }
        }
        console.log(JSON.stringify(jsonObj, null, 2));
      } catch {
        console.log("Could not convert to JSON format");
      }
    }
  } catch {
    console.error("\u274C Error reading file");
    process.exit(1);
  }
}

// src/cli/update.ts
import { execSync as execSync2 } from "child_process";
// package.json
var package_default = {
  name: "@agentic-codeflow/cli",
  version: "0.20.4",
  description: "AI Agent & Command Distribution Platform with Verbalized Sampling - Deploy 33+ specialized AI agents and workflow commands with integrated VS strategy generation to any project instantly",
  type: "module",
  bin: {
    codeflow: "./dist/cli.js"
  },
  keywords: [
    "cli",
    "ai",
    "development",
    "workflow",
    "automation",
    "agent",
    "mcp",
    "claude",
    "opencode"
  ],
  homepage: "https://github.com/ferg-cod3s/codeflow",
  repository: {
    type: "git",
    url: "https://github.com/ferg-cod3s/codeflow.git"
  },
  bugs: {
    url: "https://github.com/ferg-cod3s/codeflow/issues"
  },
  author: "Codeflow Team <team@codeflow.dev>",
  license: "MIT",
  files: [
    "src/cli/**/*",
    "src/config/**/*",
    "src/utils/**/*",
    "src/sync/**/*",
    "src/catalog/**/*",
    "src/adapters/**/*",
    "src/conversion/**/*",
    "src/yaml/**/*",
    "src/security/**/*",
    "src/optimization/**/*",
    "src/math.ts",
    "src/sync-with-validation.ts",
    "base-agents/**/*",
    "command/**/*",
    "AGENT_MANIFEST.json",
    "README.md",
    "LICENSE",
    "docs/README.md",
    "docs/MCP_QUICKSTART.md",
    "docs/SLASH_COMMANDS.md"
  ],
  publishConfig: {
    access: "public"
  },
  scripts: {
    "vs:validate": "bun run src/verbalized-sampling/cli.ts validate . --strict",
    "vs:test": "bun run src/verbalized-sampling/cli.ts test",
    "vs:inject": "bun run src/verbalized-sampling/cli.ts inject",
    "vs:export": "bun run src/verbalized-sampling/cli.ts export",
    "vs:import": "bun run src/verbalized-sampling/cli.ts import",
    "vs:sync": "bun run src/verbalized-sampling/cli.ts sync",
    "vs:info": "bun run src/verbalized-sampling/cli.ts info",
    "vs:init": "bun run src/verbalized-sampling/cli.ts init",
    "precommit:vs": "./vs-cli validate . --strict",
    "lint:vs": "./vs-cli validate . --strict --no-warnings",
    "test:vs": "./vs-cli test 'Sample problem' --type research",
    postinstall: "echo '\u2713 @agentic-codeflow/cli installed successfully'",
    "install:node": "npm link",
    typecheck: "tsc --noEmit",
    "typecheck:node": "tsc --noEmit --project tsconfig.node.json",
    test: "bun run run-tests.ts",
    "test:node": "node --loader ts-node/esm run-tests.ts",
    "test:unit": "bun run run-tests.ts unit",
    "test:unit:node": "node --loader ts-node/esm run-tests.ts unit",
    "test:integration": "bun run run-tests.ts integration",
    "test:integration:node": "node --loader ts-node/esm run-tests.ts integration",
    "test:e2e": "bun run run-tests.ts e2e",
    "test:e2e:node": "node --loader ts-node/esm run-tests.ts e2e",
    "test:e2e:sequential": "bun run scripts/run-e2e-tests.ts",
    "test:e2e:sequential:node": "node --loader ts-node/esm scripts/run-e2e-tests.ts",
    "migrate-opencode-agents": "bun run scripts/migrate-opencode-agents.ts",
    "test:watch": "bun test --watch",
    "test:watch:node": "node --loader ts-node/esm node_modules/.bin/mocha --watch tests/**/*.test.ts",
    "test:coverage": "bun run run-tests.ts --coverage",
    "test:coverage:node": "node --loader ts-node/esm run-tests.ts --coverage",
    "test:agents": "bun test tests/unit/agents",
    "test:agents:node": "node --loader ts-node/esm node_modules/.bin/mocha tests/unit/agents/**/*.test.ts",
    "test:commands": "bun test tests/unit/commands",
    "test:commands:node": "node --loader ts-node/esm node_modules/.bin/mocha tests/unit/commands/**/*.test.ts",
    "test:cli": "bun test tests/unit/cli",
    "test:cli:node": "node --loader ts-node/esm node_modules/.bin/mocha tests/unit/cli/**/*.test.ts",
    "test:conversion": "bun test tests/unit/catalog/conversion.test.ts",
    "test:conversion:node": "node --loader ts-node/esm node_modules/.bin/mocha tests/unit/catalog/conversion.test.ts",
    sync: "bun run src/sync-with-validation.ts",
    "sync:node": "node --loader ts-node/esm src/sync-with-validation.ts",
    "sync:global": "bun run src/sync-with-validation.ts --global",
    "sync:global:node": "node --loader ts-node/esm src/sync-with-validation.ts --global",
    "sync:fix": "bun run src/sync-with-validation.ts --fix",
    "sync:fix:node": "node --loader ts-node/esm src/sync-with-validation.ts --fix",
    "sync:validate": "bun run src/sync-with-validation.ts --validate",
    "sync:validate:node": "node --loader ts-node/esm src/sync-with-validation.ts --validate",
    "sync:claude": "./sync-claude-global.sh",
    "sync:smart": "./scripts/sync-with-model-config.sh",
    "sync:opencode": "./scripts/sync-with-model-config.sh",
    "fix:models": "./scripts/fix-opencode-models.sh && ./scripts/fix-opencode-agent-models.sh",
    "fix:models:global": "./scripts/fix-global-models.js",
    "fix:models:global:all": "./scripts/fix-global-models.js --all-projects",
    "yaml:validate": "bun run src/utils/yaml-validator.ts",
    "yaml:validate:node": "node --loader ts-node/esm src/utils/yaml-validator.ts",
    "yaml:fix": "bun run src/utils/yaml-validator.ts --fix",
    "yaml:fix:node": "node --loader ts-node/esm src/utils/yaml-validator.ts --fix",
    "mcp:server": "bun run mcp/codeflow-server.mjs",
    "mcp:server:node": "node mcp/codeflow-server.mjs",
    "mcp:dev": "bun run --watch mcp/codeflow-server.mjs",
    "mcp:dev:node": "node --watch mcp/codeflow-server.mjs",
    server: "bun run src/cli/index.ts server start",
    "server:node": "node --loader ts-node/esm src/cli/index.ts server start",
    "server:dev": "bun run --watch src/cli/index.ts server start",
    "server:dev:node": "node --watch --loader ts-node/esm src/cli/index.ts server start",
    lint: "eslint .",
    "lint:fix": "eslint . --fix",
    "validate:imports": "node scripts/validate-imports.js",
    format: "prettier --write .",
    "validate:agents": "node scripts/validate-agent-models.js",
    changelog: "conventional-changelog -p angular -i CHANGELOG.md -s -r 0",
    "changelog:first": "conventional-changelog -p angular -i CHANGELOG.md -s",
    release: "./scripts/release.sh",
    "release:patch": "./scripts/release.sh --bump-patch",
    "release:minor": "./scripts/release.sh --bump-minor",
    "release:major": "./scripts/release.sh --bump-major",
    "release:publish": "./scripts/release.sh --publish",
    "release:publish:patch": "./scripts/release.sh --publish --bump-patch",
    "release:publish:minor": "./scripts/release.sh --publish --bump-minor",
    "release:publish:major": "./scripts/release.sh --publish --bump-major",
    prepublishOnly: 'mkdir -p dist && bun run typecheck && bun run build:cli && bun run lint || echo "Lint warnings found but continuing with publish"',
    "prepublishOnly:node": 'npm run typecheck:node && npm run build:cli:node && npm run lint || echo "Lint warnings found but continuing with publish"',
    prepack: "bun run typecheck",
    "prepack:node": "npm run typecheck:node",
    "build:cli": "esbuild src/cli/index.ts --bundle --platform=node --target=node18 --format=esm --outfile=dist/cli.js --packages=external && chmod +x dist/cli.js",
    "build:cli:node": "esbuild src/cli/index.ts --bundle --platform=node --target=node18 --format=esm --packages=external --outfile=dist/cli.js",
    prepare: "echo 'Husky prepared'"
  },
  dependencies: {
    "@aws-sdk/client-cloudwatch": "^3.911.0",
    "@aws-sdk/client-sns": "^3.911.0",
    "@modelcontextprotocol/sdk": "^1.18.1",
    boxen: "^8.0.1",
    chalk: "^5.6.2",
    "cli-table3": "^0.6.5",
    inquirer: "^12.9.6",
    ora: "^9.0.0",
    semver: "^7.7.2",
    winston: "^3.18.3",
    yaml: "^2.8.1",
    zod: "^4.1.11"
  },
  devDependencies: {
    "@commitlint/cli": "^19.8.1",
    "@commitlint/config-conventional": "^19.8.1",
    "@eslint/js": "^9.36.0",
    "@types/bun": "latest",
    "@types/node": "^20.0.0",
    "@types/semver": "^7.7.1",
    "@typescript-eslint/eslint-plugin": "^8.44.0",
    "@typescript-eslint/parser": "^8.44.0",
    "bun-types": "^1.3.1",
    "conventional-changelog-angular": "^8.0.0",
    "conventional-changelog-cli": "^5.0.0",
    esbuild: "^0.24.0",
    eslint: "^9.36.0",
    "eslint-config-prettier": "^9.1.2",
    "eslint-plugin-jsx-a11y": "^6.10.2",
    husky: "^9.1.7",
    mocha: "^10.8.2",
    nyc: "^17.1.0",
    prettier: "^3.6.2",
    "ts-node": "^10.9.2",
    typescript: "^5.9.2"
  }
};

// src/cli/update.ts
async function checkForUpdates() {
  const currentVersion = package_default.version;
  try {
    const registryInfo = execSync2("npm view codeflow version", { encoding: "utf8" }).trim();
    const latestVersion = registryInfo;
    const hasUpdate = latestVersion !== currentVersion;
    return { hasUpdate, latestVersion, currentVersion };
  } catch {
    try {
      const gitTags = execSync2("git tag --sort=-version:refname | head -1", {
        encoding: "utf8"
      }).trim();
      const latestVersion = gitTags;
      const hasUpdate = latestVersion !== currentVersion && latestVersion !== "";
      return { hasUpdate, latestVersion, currentVersion };
    } catch {
      console.warn("Could not check for updates from git or npm");
      return { hasUpdate: false, currentVersion };
    }
  }
}
async function performUpdate(options) {
  const { force = false, verbose = false } = options;
  console.log("\uD83D\uDD04 Updating Codeflow CLI...");
  try {
    if (verbose) {
      console.log("Running: npm install -g codeflow");
    }
    execSync2("npm install -g codeflow", {
      stdio: verbose ? "inherit" : "pipe"
    });
    console.log("\u2705 Codeflow CLI updated successfully!");
    console.log("\uD83D\uDCA1 You may need to restart your terminal for changes to take effect.");
  } catch (error) {
    console.error(`\u274C Failed to update Codeflow CLI: ${error instanceof Error ? error.message : "Unknown error"}`);
    if (!force) {
      console.error("\uD83D\uDCA1 Try running with --force if you encounter permission issues");
      process.exit(1);
    }
  }
}
async function update(options = {}) {
  const { check = false, force = false, verbose = false } = options;
  if (check) {
    console.log("\uD83D\uDD0D Checking for Codeflow CLI updates...");
    const updateInfo2 = await checkForUpdates();
    console.log(`\uD83D\uDCE6 Current version: ${updateInfo2.currentVersion}`);
    if (updateInfo2.hasUpdate && updateInfo2.latestVersion) {
      console.log(`\uD83D\uDE80 Update available: ${updateInfo2.latestVersion}`);
      console.log('\uD83D\uDCA1 Run "codeflow update" to install the latest version');
      return;
    } else {
      console.log("\u2705 Codeflow CLI is up to date");
      return;
    }
  }
  const updateInfo = await checkForUpdates();
  if (updateInfo.hasUpdate && updateInfo.latestVersion) {
    console.log(`\uD83D\uDCE6 Current version: ${updateInfo.currentVersion}`);
    console.log(`\uD83D\uDE80 Latest version: ${updateInfo.latestVersion}`);
    console.log("\uD83D\uDD04 Updating...");
    await performUpdate({ force, verbose });
  } else {
    console.log("\u2705 Codeflow CLI is already up to date");
  }
}

// src/cli/clean.ts
import { existsSync as existsSync17, readdirSync as readdirSync3, unlinkSync } from "fs";
import { join as join15, resolve as resolve5 } from "path";
function cleanCache(projectPath) {
  const cacheDirs = [join15(projectPath, ".cache"), join15(projectPath, "node_modules/.cache")];
  const files = [];
  let totalSize = 0;
  for (const cacheDir of cacheDirs) {
    if (existsSync17(cacheDir)) {
      try {
        const items = readdirSync3(cacheDir, { recursive: true });
        for (const item of items) {
          const itemPath = join15(cacheDir, item.toString());
          try {
            const stats = __require("fs").statSync(itemPath);
            if (stats.isFile()) {
              files.push(itemPath);
              totalSize += stats.size;
            }
          } catch {}
        }
      } catch {
        console.warn(`Warning: Could not read cache directory ${cacheDir}`);
      }
    }
  }
  return { files, size: totalSize };
}
function cleanTemp(projectPath) {
  const files = [];
  let totalSize = 0;
  const checkDirectories = [
    projectPath,
    join15(projectPath, ".claude"),
    join15(projectPath, ".opencode")
  ];
  for (const dir of checkDirectories) {
    if (existsSync17(dir)) {
      try {
        const items = readdirSync3(dir, { recursive: true });
        for (const item of items) {
          const itemPath = join15(dir, item.toString());
          const itemStr = item.toString();
          if (itemStr.endsWith(".tmp") || itemStr.endsWith(".temp") || itemStr === ".DS_Store" || itemStr === "Thumbs.db" || itemStr.includes("/temp/")) {
            try {
              const stats = __require("fs").statSync(itemPath);
              if (stats.isFile()) {
                files.push(itemPath);
                totalSize += stats.size;
              }
            } catch {}
          }
        }
      } catch {
        console.warn(`Warning: Could not read directory ${dir}`);
      }
    }
  }
  return { files, size: totalSize };
}
function cleanOrphaned(projectPath) {
  const files = [];
  let totalSize = 0;
  const orphanedPatterns = [
    join15(projectPath, ".claude", "commands", "*.bak"),
    join15(projectPath, ".opencode", "command", "*.bak")
  ];
  for (const pattern of orphanedPatterns) {
    const dir = pattern.replace("/*.bak", "");
    if (existsSync17(dir)) {
      try {
        const items = readdirSync3(dir);
        for (const item of items) {
          if (item.endsWith(".bak")) {
            const filePath = join15(dir, item);
            try {
              const stats = __require("fs").statSync(filePath);
              files.push(filePath);
              totalSize += stats.size;
            } catch {}
          }
        }
      } catch {
        console.warn(`Warning: Could not read directory ${dir}`);
      }
    }
  }
  return { files, size: totalSize };
}
async function clean(projectPath = process.cwd(), options = {}) {
  const projectPathResolved = resolve5(projectPath);
  const { dryRun = false, force = false, verbose = false, type = "all" } = options;
  console.log(`\uD83E\uDDF9 Cleaning Codeflow project: ${projectPathResolved}`);
  if (dryRun) {
    console.log("\uD83D\uDD0D DRY RUN MODE - No files will be deleted");
  }
  const results = [];
  if (type === "cache" || type === "all") {
    console.log(`
\uD83D\uDCC1 Cleaning cache files...`);
    const cacheResult = cleanCache(projectPathResolved);
    results.push({ type: "cache", ...cacheResult });
    if (cacheResult.files.length > 0) {
      console.log(`   Found ${cacheResult.files.length} cache files (${Math.round(cacheResult.size / 1024)}KB)`);
      if (verbose) {
        cacheResult.files.forEach((file) => console.log(`   ${file}`));
      }
    } else {
      console.log("   No cache files found");
    }
  }
  if (type === "temp" || type === "all") {
    console.log(`
\uD83D\uDDC2\uFE0F  Cleaning temporary files...`);
    const tempResult = cleanTemp(projectPathResolved);
    results.push({ type: "temp", ...tempResult });
    if (tempResult.files.length > 0) {
      console.log(`   Found ${tempResult.files.length} temp files (${Math.round(tempResult.size / 1024)}KB)`);
      if (verbose) {
        tempResult.files.forEach((file) => console.log(`   ${file}`));
      }
    } else {
      console.log("   No temp files found");
    }
  }
  if (type === "orphaned" || type === "all") {
    console.log(`
\uD83D\uDD0D Cleaning orphaned files...`);
    const orphanedResult = cleanOrphaned(projectPathResolved);
    results.push({ type: "orphaned", ...orphanedResult });
    if (orphanedResult.files.length > 0) {
      console.log(`   Found ${orphanedResult.files.length} orphaned files (${Math.round(orphanedResult.size / 1024)}KB)`);
      if (verbose) {
        orphanedResult.files.forEach((file) => console.log(`   ${file}`));
      }
    } else {
      console.log("   No orphaned files found");
    }
  }
  const totalFiles = results.reduce((sum, r) => sum + r.files.length, 0);
  const totalSize = results.reduce((sum, r) => sum + r.size, 0);
  console.log(`
\uD83D\uDCCA Summary:`);
  console.log(`   Total files to clean: ${totalFiles}`);
  console.log(`   Total size: ${Math.round(totalSize / 1024)}KB`);
  if (totalFiles === 0) {
    console.log("\u2705 Nothing to clean");
    return;
  }
  if (dryRun) {
    console.log("\uD83D\uDD0D Dry run completed - no files were deleted");
    return;
  }
  if (!force) {
    console.log(`
\u26A0\uFE0F  This will delete the files listed above.`);
    console.log("\uD83D\uDCA1 Use --force to skip confirmation, or --dry-run to preview without deleting");
    const confirm = process.argv.includes("--yes") || process.argv.includes("-y");
    if (!confirm) {
      console.log("\u274C Operation cancelled. Use --force to proceed without confirmation.");
      process.exit(1);
    }
  }
  console.log(`
\uD83D\uDDD1\uFE0F  Deleting files...`);
  let deletedCount = 0;
  let errorCount = 0;
  for (const result of results) {
    for (const file of result.files) {
      try {
        unlinkSync(file);
        deletedCount++;
        if (verbose) {
          console.log(`   Deleted: ${file}`);
        }
      } catch (error) {
        errorCount++;
        console.warn(`   Failed to delete ${file}: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
  }
  console.log(`
\u2705 Clean completed:`);
  console.log(`   Files deleted: ${deletedCount}`);
  console.log(`   Errors: ${errorCount}`);
  console.log(`   Space freed: ${Math.round(totalSize / 1024)}KB`);
}

// src/cli/export.ts
import { existsSync as existsSync18, readdirSync as readdirSync4 } from "fs";
import { join as join16, resolve as resolve6 } from "path";
import { readFile as readFile13, writeFile as writeFile9 } from "fs/promises";
async function exportProject(options = {}) {
  const projectPath = options.projectRoot || process.cwd();
  const projectPathResolved = resolve6(projectPath);
  const { format = "json", output, includeContent = true, verbose = false } = options;
  console.log(`\uD83D\uDCE4 Exporting Codeflow project: ${projectPathResolved}`);
  const exportedItems = [];
  const errors2 = [];
  console.log("\uD83E\uDD16 Collecting agents...");
  const agentDirs = [".claude/agents", ".opencode/agent"];
  for (const dir of agentDirs) {
    const fullPath = join16(projectPathResolved, dir);
    if (existsSync18(fullPath)) {
      try {
        const files = readdirSync4(fullPath).filter((f) => f.endsWith(".md"));
        for (const file of files) {
          const filePath = join16(fullPath, file);
          try {
            const content = includeContent ? await readFile13(filePath, "utf-8") : undefined;
            const stats = __require("fs").statSync(filePath);
            let platform = "base";
            if (dir.includes(".claude")) {
              platform = "claude-code";
            } else if (dir.includes(".opencode")) {
              platform = "opencode";
            }
            exportedItems.push({
              name: file.replace(".md", ""),
              type: "agent",
              platform,
              path: filePath,
              content,
              metadata: {
                size: stats.size,
                lastModified: stats.mtime
              }
            });
            if (verbose) {
              console.log(`   Exported agent: ${file}`);
            }
          } catch (error) {
            errors2.push(`Failed to export agent ${file}: ${error instanceof Error ? error.message : "Unknown error"}`);
          }
        }
      } catch (error) {
        errors2.push(`Failed to read agent directory ${dir}: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
  }
  console.log("\uD83D\uDCAC Collecting commands...");
  const commandDirs = [".claude/commands", ".opencode/command"];
  for (const dir of commandDirs) {
    const fullPath = join16(projectPathResolved, dir);
    if (existsSync18(fullPath)) {
      try {
        const files = readdirSync4(fullPath).filter((f) => f.endsWith(".md"));
        for (const file of files) {
          const filePath = join16(fullPath, file);
          try {
            const content = includeContent ? await readFile13(filePath, "utf-8") : undefined;
            const stats = __require("fs").statSync(filePath);
            let platform = "base";
            if (dir.includes(".claude")) {
              platform = "claude-code";
            } else if (dir.includes(".opencode")) {
              platform = "opencode";
            }
            exportedItems.push({
              name: file.replace(".md", ""),
              type: "command",
              platform,
              path: filePath,
              content,
              metadata: {
                size: stats.size,
                lastModified: stats.mtime
              }
            });
            if (verbose) {
              console.log(`   Exported command: ${file}`);
            }
          } catch (error) {
            errors2.push(`Failed to export command ${file}: ${error instanceof Error ? error.message : "Unknown error"}`);
          }
        }
      } catch (error) {
        errors2.push(`Failed to read command directory ${dir}: ${error instanceof Error ? error.message : "Unknown error"}`);
      }
    }
  }
  console.log(`\u2705 Collected ${exportedItems.length} items`);
  if (errors2.length > 0) {
    console.warn(`\u26A0\uFE0F  ${errors2.length} errors during export:`);
    errors2.forEach((error) => console.warn(`   ${error}`));
  }
  const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
  const defaultOutput = `codeflow-export-${timestamp}.${format}`;
  const outputPath = output ? resolve6(output) : join16(projectPathResolved, defaultOutput);
  try {
    let exportData;
    switch (format) {
      case "json":
        exportData = JSON.stringify({
          metadata: {
            exportedAt: new Date().toISOString(),
            projectPath: projectPathResolved,
            totalItems: exportedItems.length,
            includeContent
          },
          items: exportedItems
        }, null, 2);
        break;
      case "yaml":
        exportData = `metadata:
  exportedAt: ${new Date().toISOString()}
  projectPath: ${projectPathResolved}
  totalItems: ${exportedItems.length}
  includeContent: ${includeContent}

items:
${exportedItems.map((item) => `  - name: ${item.name}
    type: ${item.type}
    platform: ${item.platform}
    path: ${item.path}
    metadata:
      size: ${item.metadata?.size}
      lastModified: ${item.metadata?.lastModified.toISOString()}
${includeContent ? `    content: |
${item.content?.split(`
`).map((line) => `      ${line}`).join(`
`)}` : ""}`).join(`
`)}
`;
        break;
      case "tar":
      case "targz":
      case "zip":
        exportData = JSON.stringify({
          metadata: {
            exportedAt: new Date().toISOString(),
            projectPath: projectPathResolved,
            totalItems: exportedItems.length,
            includeContent
          },
          items: exportedItems
        }, null, 2);
        break;
      default:
        throw new Error(`Unsupported export format: ${format}`);
    }
    await writeFile9(outputPath, exportData, "utf-8");
    console.log(`
\u2705 Export completed successfully!`);
    console.log(`\uD83D\uDCC4 Exported to: ${outputPath}`);
    console.log(`\uD83D\uDCCA Summary:`);
    console.log(`   Total items: ${exportedItems.length}`);
    console.log(`   Agents: ${exportedItems.filter((i) => i.type === "agent").length}`);
    console.log(`   Commands: ${exportedItems.filter((i) => i.type === "command").length}`);
    console.log(`   File size: ${Math.round(Buffer.byteLength(exportData, "utf8") / 1024)}KB`);
    if (includeContent) {
      console.log(`\uD83D\uDCA1 Tip: Use --no-content to export metadata only (smaller file)`);
    }
    return {
      success: true,
      outputPath,
      totalItems: exportedItems.length,
      errors: errors2
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    console.error(`\u274C Failed to write export file: ${errorMessage}`);
    return {
      success: false,
      totalItems: exportedItems.length,
      errors: [...errors2, errorMessage]
    };
  }
}

// src/cli/research.ts
import { join as join17 } from "path";
import { existsSync as existsSync19 } from "fs";
import { writeFile as writeFile10 } from "fs/promises";

class ResearchCLI {
  projectRoot;
  agentRegistry;
  workflowOrchestrator;
  progressState;
  constructor(projectRoot) {
    this.projectRoot = projectRoot;
    this.progressState = {
      currentPhase: "",
      phasesCompleted: 0,
      totalPhases: 4
    };
  }
  async initialize() {
    try {
      const agenticMcpPath = join17(this.projectRoot, "packages", "agentic-mcp", "dist");
      if (!existsSync19(agenticMcpPath)) {
        this.agentRegistry = { agents: [] };
        this.workflowOrchestrator = {
          executeResearchWorkflow: async (_options) => ({
            summary: "Mock research result",
            qualityMetrics: {
              overallScore: 80,
              completeness: 85,
              accuracy: 75,
              confidence: "medium"
            },
            recommendations: ["Mock recommendation"],
            nextSteps: ["Mock next step"]
          })
        };
        console.log(`\u2705 Using mock research system (package not built)
`);
        return;
      }
      const { buildSafeAgentRegistry } = await import(`${agenticMcpPath}/agent-registry.js`);
      const { executeResearchWorkflow } = await import(`${agenticMcpPath}/research-workflow.js`);
      this.agentRegistry = await buildSafeAgentRegistry();
      this.workflowOrchestrator = { executeResearchWorkflow };
      console.log(`\u2705 Research system initialized
`);
    } catch (error) {
      throw new Error(`Failed to initialize research system: ${error}`);
    }
  }
  async executeResearch(options) {
    console.log(`\uD83D\uDD2C Starting Deep Research Workflow
`);
    console.log(`Query: "${options.query}"
`);
    await this.initialize();
    try {
      this.showProgress("Initializing", 0);
      const result = await this.workflowOrchestrator.executeResearchWorkflow({
        query: options.query,
        includeExternalResearch: options.includeWeb ?? false,
        engageDomainSpecialists: options.specialists && options.specialists.length > 0,
        maxSpecialists: options.specialists ? options.specialists.length : 3
      }, this.agentRegistry);
      console.log(`
`);
      this.showProgress("Complete", 4);
      console.log(`
\u2705 Research Complete!
`);
      await this.displayResults(result);
      if (options.output) {
        await this.saveResults(result, options.output);
      }
      return result;
    } catch (error) {
      console.error(`
\u274C Research failed:`, error);
      throw error;
    }
  }
  async displayResults(result) {
    console.log("\u2550".repeat(80));
    console.log("  RESEARCH REPORT");
    console.log("\u2550".repeat(80));
    console.log();
    if (result.summary) {
      console.log("\uD83D\uDCCB SUMMARY");
      console.log("\u2500".repeat(80));
      console.log(result.summary);
      console.log();
    }
    if (result.codebaseAnalysis) {
      console.log("\uD83D\uDCBB CODEBASE ANALYSIS");
      console.log("\u2500".repeat(80));
      console.log(result.codebaseAnalysis);
      console.log();
    }
    if (result.documentationInsights) {
      console.log("\uD83D\uDCDA DOCUMENTATION INSIGHTS");
      console.log("\u2500".repeat(80));
      console.log(result.documentationInsights);
      console.log();
    }
    if (result.externalResearch) {
      console.log("\uD83C\uDF10 EXTERNAL RESEARCH");
      console.log("\u2500".repeat(80));
      console.log(result.externalResearch);
      console.log();
    }
    if (result.domainSpecialistFindings && result.domainSpecialistFindings.length > 0) {
      console.log("\uD83C\uDFAF SPECIALIST FINDINGS");
      console.log("\u2500".repeat(80));
      result.domainSpecialistFindings.forEach((finding) => {
        console.log(`  \u2022 ${finding.specialist}: ${finding.summary}`);
      });
      console.log();
    }
    if (result.recommendations && result.recommendations.length > 0) {
      console.log("\uD83D\uDCA1 RECOMMENDATIONS");
      console.log("\u2500".repeat(80));
      result.recommendations.forEach((rec, index) => {
        console.log(`  ${index + 1}. ${rec}`);
      });
      console.log();
    }
    if (result.nextSteps && result.nextSteps.length > 0) {
      console.log("\uD83D\uDE80 NEXT STEPS");
      console.log("\u2500".repeat(80));
      result.nextSteps.forEach((step, index) => {
        console.log(`  ${index + 1}. ${step}`);
      });
      console.log();
    }
    if (result.qualityMetrics) {
      console.log("\uD83D\uDCCA QUALITY METRICS");
      console.log("\u2500".repeat(80));
      console.log(`  Overall Score: ${result.qualityMetrics.overallScore}/100`);
      console.log(`  Completeness:  ${result.qualityMetrics.completeness}/100`);
      console.log(`  Accuracy:      ${result.qualityMetrics.accuracy}/100`);
      console.log(`  Confidence:    ${result.qualityMetrics.confidence}`);
      console.log();
    }
    console.log("\u2550".repeat(80));
  }
  async saveResults(result, outputPath) {
    try {
      const content = this.formatResultsAsMarkdown(result);
      await writeFile10(outputPath, content, "utf-8");
      console.log(`
\uD83D\uDCBE Results saved to: ${outputPath}`);
    } catch (error) {
      console.error(`Failed to save results: ${error}`);
    }
  }
  formatResultsAsMarkdown(result) {
    const timestamp = new Date().toISOString();
    let markdown = `# Research Report

`;
    markdown += `Generated: ${timestamp}

`;
    markdown += `---

`;
    if (result.summary) {
      markdown += `## Summary

${result.summary}

`;
    }
    if (result.codebaseAnalysis) {
      markdown += `## Codebase Analysis

${result.codebaseAnalysis}

`;
    }
    if (result.documentationInsights) {
      markdown += `## Documentation Insights

${result.documentationInsights}

`;
    }
    if (result.externalResearch) {
      markdown += `## External Research

${result.externalResearch}

`;
    }
    if (result.domainSpecialistFindings && result.domainSpecialistFindings.length > 0) {
      markdown += `## Specialist Findings

`;
      result.domainSpecialistFindings.forEach((finding) => {
        markdown += `### ${finding.specialist}

${finding.summary}

`;
      });
    }
    if (result.recommendations && result.recommendations.length > 0) {
      markdown += `## Recommendations

`;
      result.recommendations.forEach((rec, index) => {
        markdown += `${index + 1}. ${rec}
`;
      });
      markdown += `
`;
    }
    if (result.nextSteps && result.nextSteps.length > 0) {
      markdown += `## Next Steps

`;
      result.nextSteps.forEach((step, index) => {
        markdown += `${index + 1}. ${step}
`;
      });
      markdown += `
`;
    }
    if (result.qualityMetrics) {
      markdown += `## Quality Metrics

`;
      markdown += `- Overall Score: ${result.qualityMetrics.overallScore}/100
`;
      markdown += `- Completeness: ${result.qualityMetrics.completeness}/100
`;
      markdown += `- Accuracy: ${result.qualityMetrics.accuracy}/100
`;
      markdown += `- Confidence: ${result.qualityMetrics.confidence}

`;
    }
    return markdown;
  }
  showProgress(phase, completed) {
    const total = this.progressState.totalPhases;
    const percentage = Math.round(completed / total * 100);
    const barLength = 40;
    const filledLength = Math.round(barLength * completed / total);
    const bar = "\u2588".repeat(filledLength) + "\u2591".repeat(barLength - filledLength);
    process.stdout.write(`\r[${bar}] ${percentage}% - ${phase}`);
  }
  async showInteractiveMenu() {
    console.log(`\uD83D\uDD2C Research Command - Deep Codebase & Documentation Analysis
`);
    console.log("Usage:");
    console.log(`  codeflow research "<query>" [options]
`);
    console.log("Options:");
    console.log("  --output <file>      Save results to file");
    console.log("  --include-web        Include external web research");
    console.log("  --specialists <list> Specific domain specialists to use (comma-separated)");
    console.log("  --min-quality <num>  Minimum quality score threshold (default: 50)");
    console.log(`  --verbose           Show detailed progress
`);
    console.log("Examples:");
    console.log('  codeflow research "authentication implementation"');
    console.log('  codeflow research "database schema" --output report.md');
    console.log('  codeflow research "API security" --include-web --specialists security-scanner');
    console.log(`  codeflow research "performance bottlenecks" --min-quality 70
`);
    console.log("Workflow:");
    console.log("  1. Discovery Phase    - Locate relevant code and documentation");
    console.log("  2. Analysis Phase     - Deep analysis of findings");
    console.log("  3. Research Phase     - External research (optional)");
    console.log(`  4. Specialist Phase   - Domain-specific insights (conditional)
`);
    console.log("\uD83D\uDCA1 Tip: Start with discovery commands before deep research for better results");
  }
}
async function research(options) {
  const cli = new ResearchCLI(options.projectRoot || process.cwd());
  try {
    if (!options.query) {
      await cli.showInteractiveMenu();
      return {};
    }
  } catch (error) {
    console.error("Research command failed:", error);
    throw error;
  }
}

// src/cli/build-manifest.ts
import { readdir as readdir10, writeFile as writeFile11, mkdir as mkdir8 } from "fs/promises";
import { join as join18, dirname as dirname4 } from "path";
import { existsSync as existsSync20 } from "fs";
function getCategoryFromName(name) {
  if (name.includes("codebase"))
    return "core-workflow";
  if (name.includes("research"))
    return "core-workflow";
  if (name.includes("web-search"))
    return "core-workflow";
  if (name.includes("operations"))
    return "operations";
  if (name.includes("development") || name.includes("migrations"))
    return "development";
  if (name.includes("quality") || name.includes("testing") || name.includes("performance"))
    return "quality-testing";
  if (name.includes("security"))
    return "security";
  if (name.includes("ux") || name.includes("ui"))
    return "design-ux";
  if (name.includes("content") || name.includes("localization"))
    return "content";
  if (name.includes("growth") || name.includes("seo"))
    return "growth";
  if (name.includes("infrastructure") || name.includes("deployment") || name.includes("devops"))
    return "infrastructure";
  return "specialized";
}
async function scanAgentsDirectory(projectRoot) {
  const agentsDir = join18(projectRoot, "base-agents");
  if (!existsSync20(agentsDir)) {
    throw new Error(`Codeflow agents directory not found: ${agentsDir}`);
  }
  const agents = [];
  const categories = await readdir10(agentsDir);
  for (const category of categories) {
    const categoryPath = join18(agentsDir, category);
    if (!existsSync20(categoryPath))
      continue;
    const files = await readdir10(categoryPath);
    const mdFiles = files.filter((f) => f.endsWith(".md"));
    for (const file of mdFiles) {
      const agentName = file.replace(".md", "");
      agents.push({ name: agentName, category });
    }
  }
  return agents.sort((a, b) => a.name.localeCompare(b.name));
}
async function buildManifest(options = {}) {
  const {
    output = "AGENT_MANIFEST.json",
    dryRun = false,
    verbose = false,
    projectRoot = process.cwd()
  } = options;
  if (verbose) {
    console.log(`\uD83C\uDFD7\uFE0F Generating agent manifest...
`);
  }
  try {
    const agents = await scanAgentsDirectory(projectRoot);
    if (verbose) {
      console.log(`Found ${agents.length} canonical agents:`);
    }
    const manifest = {
      canonical_agents: agents.map((agent) => ({
        name: agent.name,
        description: `Agent: ${agent.name.replace(/-|_/g, " ")}`,
        category: agent.category || getCategoryFromName(agent.name),
        sources: {
          base: `base-agents/${agent.category}/${agent.name}.md`,
          "claude-code": `.claude/agents/${agent.name}.md`,
          opencode: `.opencode/agent/${agent.name}.md`
        }
      })),
      total_agents: agents.length,
      last_updated: new Date().toISOString(),
      canonical_directories: ["base-agents/", ".claude/agents/", ".opencode/agent/"],
      format_info: {
        base: {
          description: "Base format for MCP integration",
          model_format: "anthropic/model-name",
          primary_use: "MCP server integration"
        },
        "claude-code": {
          description: "Claude Code format",
          model_format: "anthropic/model-name",
          primary_use: "Claude Code client integration"
        },
        opencode: {
          description: "OpenCode format",
          model_format: "provider/model-name",
          primary_use: "OpenCode client integration"
        }
      }
    };
    if (dryRun) {
      console.log("\uD83D\uDD0D Dry run - would generate manifest:");
      console.log(JSON.stringify(manifest, null, 2));
      return;
    }
    const outputDir = dirname4(output);
    if (outputDir !== "." && !existsSync20(outputDir)) {
      await mkdir8(outputDir, { recursive: true });
    }
    await writeFile11(output, JSON.stringify(manifest, null, 2));
    console.log(`
\u2705 Agent manifest created successfully!`);
    console.log(`\uD83D\uDCDD ${output} contains ${manifest.total_agents} agents`);
    const categories = {};
    manifest.canonical_agents.forEach((agent) => {
      const cat = agent.category;
      categories[cat] = (categories[cat] || 0) + 1;
    });
    console.log(`
\uD83D\uDCCA Agents by category:`);
    Object.entries(categories).forEach(([cat, count]) => {
      console.log(`  ${cat}: ${count} agents`);
    });
  } catch (error) {
    console.error(`\u274C Failed to build manifest: ${error.message}`);
    throw error;
  }
}

// src/cli/index.ts
import { readFileSync as readFileSync2 } from "fs";
import { join as join19, resolve as resolve7, sep } from "path";
import { existsSync as existsSync21 } from "fs";
import { homedir as homedir4 } from "os";
var packageJson = JSON.parse(readFileSync2(new URL("../package.json", import.meta.url), "utf-8"));
var HELP_TEXT = `codeflow - Intelligent AI workflow management and development automation

CodeFlow is a CLI built with Bun and TypeScript that manages agents and commands for AI-assisted development workflows.

Usage:
  codeflow <command> [options]

Commands:
   setup [project-path]       Set up codeflow directory structure and copy agents/commands
   status [project-path]      Check which files are up-to-date or outdated
   sync [project-path]        Synchronize agents and commands with global configuration
   fix-models [options]       Fix model configurations (default: global, use --local or --all-projects)
   convert <source> <target> <format>  Convert agents between formats
   watch start [options]      Start automatic file synchronization daemon
   build-manifest [options]   Build or rebuild the agent manifest file

   validate [path]            Validate agents and commands for integrity issues
   list [path]                List installed agents and commands
   info <item-name> [path]    Show detailed information about an agent or command
   update                     Check for and install CLI updates
   clean [path]               Clean up cache, temp, and orphaned files
   export [path]              Export project setup to a file
   research "<query>" [options]  Execute deep research workflow for codebase analysis

Options:
  -f, --force               Force overwrite existing setup
  -t, --type <type>         Project type: claude-code, opencode, cursor, or all
  --validate                Validate agents during operations (default: true)
  --dry-run                 Show what would be changed without writing files
  -g, --global              Sync to global directories (~/.claude, ~/.config/opencode)
  --project <path>          Project directory for operations
  --source <format>         Source format: base, claude-code, opencode
  --target <format>         Target format: base, claude-code, opencode
  --source-format <format>  Source format for sync (default: base)
   --local                   Fix models in current project (for fix-models command)
   --all-projects             Fix models in all discovered projects (for fix-models command)
   --global                  Validate global agent directories (~/.claude, ~/.config/opencode)

Examples:
  codeflow setup ~/my-project
  codeflow setup --type claude-code    # Setup for Claude Code only
  codeflow setup --type opencode       # Setup for OpenCode only  
  codeflow setup --type all            # Setup for all platforms
  codeflow status .
  codeflow sync                        # Sync to project directories
  codeflow sync --global               # Sync to global directories (~/.claude, ~/.config/opencode)
  codeflow sync --global --dry-run     # Preview global sync changes
   codeflow fix-models                  # Fix model IDs globally
   codeflow fix-models --local          # Fix model IDs in current project
   codeflow fix-models --all-projects   # Fix model IDs in all discovered projects
  codeflow convert ./codeflow-agents ./claude-agents claude-code
  codeflow watch start --global
  codeflow list                        # List all available agents and commands
  codeflow list --type agents          # List only agents
  codeflow list --platform claude-code # List Claude Code items only

SETUP OPTIONS:
  Use 'codeflow setup' to initialize agents and commands in your project
  
  Platform Types:
    claude-code    - Setup for Claude Code (.claude/ directory)
    opencode       - Setup for OpenCode (.opencode/ directory)  
    cursor         - Setup for Cursor (.cursor/ directory)
    all (default)  - Setup for all platforms
  
  Global vs Project:
    --global       - Install to global directories (~/.claude, ~/.config/opencode)
    (no flag)      - Install to project directory

AVAILABLE COMMANDS (25 total):
  /audit        - Audit codebase for issues and improvements
  /benchmark    - Performance benchmarking and analysis
  /code-review  - Comprehensive code review and analysis
  /commit       - Create structured git commits
  /continue     - Resume execution from last step
  /debug        - Debug and troubleshoot issues
  /deploy       - Deploy applications and infrastructure
  /document     - Create documentation and guides
  /env-setup    - Set up development environments
  /execute      - Implement plans with verification
  /help         - Get development guidance and workflow info
  /impact-analysis - Analyze impact of changes
  /migrate      - Migrate code and configurations
  /monitor      - Set up monitoring and observability
  /plan         - Create detailed implementation plans
  /project-docs - Generate complete project documentation
  /refactor     - Refactor and improve code structure
  /research     - Comprehensive codebase analysis
  /review       - Validate implementations against plans
  /security-scan - Security vulnerability scanning
  /test         - Generate and run test suites
  /ticket       - Work with tickets and issues

CORE AGENT TYPES (135 total):
  Research & Analysis:
    codebase-locator        - Finds WHERE files and components exist
    codebase-analyzer       - Understands HOW specific code works
    codebase-pattern-finder - Discovers similar implementation patterns
    research-locator        - Finds existing documentation and decisions
    research-analyzer       - Extracts insights from specific documents
    web-search-researcher   - Performs targeted web research

  Development & Engineering:
    full-stack-developer    - Cross-functional development
    api-builder            - API design and implementation
    database-expert        - Database optimization and design
    security-scanner       - Vulnerability assessment
    ux-optimizer          - User experience optimization
    frontend-developer     - React/Next.js/UI development
    backend-architect     - System design and architecture

  Specialized Domains:
    ai-engineer           - LLM applications and AI integration
    cloud-architect       - Multi-cloud infrastructure design
    devops-operations-specialist - Operations and deployment
    quality-testing-performance-tester - Performance testing
    ml-engineer          - Machine learning systems
    blockchain-developer  - Web3 and smart contracts

  Meta & Orchestration:
    smart-subagent-orchestrator - Complex multi-agent workflows
    agent-architect       - Create custom agents
    system-architect      - System design and architecture

Workflow Philosophy:
  - Always run locator agents first, then analyzers
  - Use specialized domain agents for complex tasks
  - Emphasize context compression and fresh analysis

For more detailed guidance:
  - Use 'codeflow list' to see all available agents and commands
  - Use 'codeflow info <name>' to get details about specific items
  - See docs/README.md for comprehensive documentation`;
function safeResolve(base, candidate, allowedRoots = []) {
  if (candidate.includes("..")) {
    throw new Error(`Path traversal detected: ${candidate} contains ".."`);
  }
  const resolved = join19(base, candidate);
  const normalized = resolve7(resolved);
  const isAllowed = allowedRoots.length === 0 || allowedRoots.some((root) => {
    const rootNormalized = resolve7(root);
    return normalized.startsWith(rootNormalized + sep) || normalized === rootNormalized;
  });
  if (!isAllowed) {
    throw new Error("Path traversal detected: " + candidate + " resolves outside allowed directories");
  }
  return normalized;
}
function getFormatDirectory(format, projectPath) {
  const codeflowRoot = getCodeflowRoot();
  switch (format) {
    case "base":
      return join19(codeflowRoot, "codeflow-agents");
    case "claude-code": {
      const projectClaudeDir = join19(projectPath, ".claude", "agents");
      return existsSync21(projectClaudeDir) ? projectClaudeDir : join19(codeflowRoot, "claude-agents");
    }
    case "opencode": {
      const projectOpenCodeDir = join19(projectPath, ".opencode", "agent");
      return existsSync21(projectOpenCodeDir) ? projectOpenCodeDir : join19(codeflowRoot, "opencode-agents");
    }
    default:
      throw new Error(`Unknown format: ${format}`);
  }
}
var values;
var positionals;
try {
  const parsed = parseArgs({
    args: process.argv,
    options: {
      help: {
        type: "boolean",
        short: "h",
        default: false
      },
      version: {
        type: "boolean",
        default: false
      },
      force: {
        type: "boolean",
        short: "f",
        default: false
      },
      type: {
        type: "string",
        short: "t"
      },
      validate: {
        type: "boolean",
        default: true
      },
      "dry-run": {
        type: "boolean",
        default: false
      },
      global: {
        type: "boolean",
        short: "g",
        default: false
      },
      project: {
        type: "string"
      },
      source: {
        type: "string"
      },
      target: {
        type: "string",
        default: "project"
      },
      "source-format": {
        type: "string",
        default: "base"
      },
      output: {
        type: "string",
        short: "o"
      },
      "include-web": {
        type: "boolean",
        default: false
      },
      specialists: {
        type: "string"
      },
      verbose: {
        type: "boolean",
        short: "v",
        default: false
      },
      "min-quality": {
        type: "string"
      },
      platform: {
        type: "string"
      },
      format: {
        type: "string"
      },
      "all-projects": {
        type: "boolean",
        default: false
      },
      local: {
        type: "boolean",
        default: false
      }
    },
    strict: true,
    allowPositionals: true
  });
  values = parsed.values;
  positionals = parsed.positionals;
} catch (error) {
  if (error.code === "ERR_PARSE_ARGS_UNKNOWN_OPTION") {
    console.error(`Error: ${error.message}`);
    console.error("Run 'codeflow --help' for usage information");
    process.exit(1);
  }
  throw error;
}
var args = positionals.slice(2);
var command = args[0];
if (values.version) {
  console.log(`Codeflow ${packageJson.version}`);
  process.exit(0);
}
if (values.help || command === "help" || !command) {
  console.log(HELP_TEXT);
  process.exit(0);
}
async function main() {
  switch (command) {
    case "setup": {
      const setupPath = args[1];
      const safeSetupPath = safeResolve(process.cwd(), setupPath || ".", [
        process.cwd(),
        homedir4()
      ]);
      await setup(safeSetupPath, {
        global: values.global,
        force: values.force,
        type: values.type
      });
      break;
    }
    case "status": {
      const statusPath = args[1];
      const safeStatusPath = safeResolve(process.cwd(), statusPath || ".", [
        process.cwd(),
        homedir4()
      ]);
      await status(safeStatusPath);
      break;
    }
    case "sync": {
      const syncPath = args[1];
      const safeSyncPath = safeResolve(process.cwd(), syncPath || ".", [process.cwd(), homedir4()]);
      await sync(safeSyncPath, {
        global: values.global,
        force: values.force,
        dryRun: values["dry-run"],
        verbose: true
      });
      break;
    }
    case "fix-models": {
      const hasLocalFlag = values.local || process.argv.includes("--local") || process.argv.includes("-l");
      await fixModels({
        dryRun: values["dry-run"],
        verbose: values.help || false,
        global: !hasLocalFlag,
        allProjects: values["all-projects"]
      });
      break;
    }
    case "convert": {
      if (values.source && values.target) {
        const projectPath = values.project || process.cwd();
        const sourceFormat = values.source;
        const targetFormat = values.target;
        const sourceDir = getFormatDirectory(sourceFormat, projectPath);
        const targetDir = getFormatDirectory(targetFormat, projectPath);
        if (targetFormat === "base") {
          console.error("Error: Cannot convert to base format");
          process.exit(1);
        }
        await convert(sourceDir, targetDir, targetFormat);
        break;
      }
      const source = args[1];
      const target = args[2];
      const format = args[3];
      if (!source || !target || !format) {
        console.error("Error: convert requires source, target, and format arguments");
        console.error("Usage: codeflow convert <source> <target> <format>");
        console.error("Formats: base, claude-code, opencode");
        process.exit(1);
      }
      if (!["base", "claude-code", "opencode"].includes(format)) {
        console.error(`Error: Invalid format '${format}'`);
        console.error("Valid formats: base, claude-code, opencode");
        process.exit(1);
      }
      if (format === "base") {
        console.error("Error: Cannot convert to base format");
        process.exit(1);
      }
      await convert(source, target, format);
      break;
    }
    case "watch": {
      const watchAction = args[1];
      if (watchAction === "start") {
        const watchPath = args[2];
        await startWatch(watchPath);
      } else {
        console.error(`Error: Unknown watch action '${watchAction}'`);
        console.error("Available actions: start");
        process.exit(1);
      }
      break;
    }
    case "validate": {
      await validate({
        format: values.format || "all",
        path: args[1],
        checkDuplicates: values["check-duplicates"],
        canonicalCheck: values["canonical-check"],
        fix: values.fix,
        verbose: values.verbose,
        global: values.global
      });
      break;
    }
    case "list": {
      const listPath = args[1];
      const safeListPath = safeResolve(process.cwd(), listPath || ".", [process.cwd(), homedir4()]);
      await list(safeListPath, {
        type: values.type || "all",
        platform: values.platform || "all",
        format: values.format || "table",
        verbose: values.verbose
      });
      break;
    }
    case "info": {
      const itemName = args[1];
      if (!itemName) {
        console.error("Error: info requires an item name");
        console.error("Usage: codeflow info <item-name>");
        process.exit(1);
      }
      const infoPath = args[2];
      const safeInfoPath = safeResolve(process.cwd(), infoPath || ".", [process.cwd(), homedir4()]);
      await info(itemName, safeInfoPath, {
        format: values.format || "detailed",
        showContent: values["show-content"]
      });
      break;
    }
    case "update": {
      const updateAction = args[1];
      await update({
        check: updateAction === "check" || values.check,
        force: values.force,
        verbose: values.verbose
      });
      break;
    }
    case "clean": {
      const cleanPath = args[1];
      const safeCleanPath = safeResolve(process.cwd(), cleanPath || ".", [
        process.cwd(),
        homedir4()
      ]);
      await clean(safeCleanPath, {
        dryRun: values["dry-run"],
        force: values.force,
        verbose: values.verbose,
        type: values.type || "all"
      });
      break;
    }
    case "export": {
      const exportPath = args[1];
      const safeExportPath = safeResolve(process.cwd(), exportPath || ".", [
        process.cwd(),
        homedir4()
      ]);
      await exportProject({
        projectRoot: safeExportPath,
        format: values.format || "json",
        output: values.output,
        includeContent: values["include-content"],
        verbose: values.verbose
      });
      break;
    }
    case "research": {
      const researchQuery = args[1];
      await research({
        query: researchQuery,
        output: values.output,
        "include-web": values["include-web"],
        specialists: values.specialists,
        verbose: values.verbose,
        "min-quality": values["min-quality"]
      });
      break;
    }
    case "build-manifest": {
      await buildManifest({
        output: values.output,
        dryRun: values["dry-run"],
        verbose: values.verbose,
        projectRoot: values.project || process.cwd()
      });
      break;
    }
    default:
      console.error(`Error: Unknown command '${command}'`);
      console.error("Run 'codeflow --help' for usage information");
      process.exit(1);
  }
}
main().catch((error) => {
  console.error("CLI Error:", error);
  process.exit(1);
});
